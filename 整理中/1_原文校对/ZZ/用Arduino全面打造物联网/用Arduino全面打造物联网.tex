\documentclass{book}
\usepackage{ctex}
\usepackage{graphicx}
\usepackage{hyperref}

\begin{document}


\section{版权信息}

书名：用Arduino全面打造物联网

作者：孙骏荣,苏海永,夏毓彦

排版：昷一

出版社：清华大学出版社

出版时间：2016-12-01

ISBN：9787302451976

— · 版权所有 侵权必究 · —

孙骏荣

具有六年多Arduino专案开发与相关研究经验，曾使用Arduino进行数字艺术、自主运动载体工具的实现，也在机电整合应用的项目中使用过其他单片机，目前从事工业自动化领域开发。近年来，也常受邀担任Arduino课程讲师，在学校与相关机构讲解整合应用与软件开发。

苏海永

Appsduino总经理

学历：

交通大学资讯科学系

经历：

台湾第一部通过欧规的传真机开发与设计

华邦电子／无线通信事业部产品规划经理

亚全科技／协理（GPS与SoC系统单片机设计与规划）

涉猎领域：

嵌入式系统，无线通信系统，物联网设计应用，移动APP，云端整合应用


\section{内容简介}

本书以Arduino这个著名的开放式软硬件平台为工具，结合丰富的范例，系统全面地介绍了物联网的三大要素“物”“联”和“网”的产品开发和具体实现。书中涵盖了物联网的概念与技术，主控端、传感端、通信和联网等模块的硬件集成、软件开发和软硬件整合等。另外，云下载资源中还提供了范例程序、电路图等资源，以配合本书的学习和实践。

本书适合物联网产品开发从业者与技术人员使用，也可以用作高校学生学习硬件设计的实践教程。


\section{PREFACE}

物联网这个名词真是让人又爱又恨。这个名词绝对是这几年最常被人提出来讨论的议题之一，但是因为它所涉及的范围广，听得越多反而越不知道什么是物联网真正的应用所在。其实它早在我们生活周围了！智能手机，不！我们应该称之为智能终端，因为手机早已不只是手机，它可以让用户随时随地通过因特网得到所有想知道的信息，以及随时随地和朋友互动，这就是物联网的应用之一。我们把物联网细分成3部分：“物”，各种各样的设备，甚至包括人类都是其中一部分；“联”，将所有的物品通过有线或无线的方式连接在一起，彼此能够交换信息；“网”，将物物相连成网，这个网将成为应用与价值的所在。

笔者接触Arduino也快10年了，看着它开始在中国台湾落地萌芽，到现在百花齐放，每天都有人发表新的应用和新的想法，Arduino不再只是冷冰冰的硬件，而是实现大家心中梦想的最佳垫脚石。以Arduino来展开物联网的介绍，无疑是希望用最简单的东西让大家能够体验物联网的无所不及。本书篇幅有限，只能点出每种应用的关键与角色，书中有太多太多主题可以再单独深入研究下去。坦白地说，笔者也无法将每个技术或领域研究透彻，因此本书若有错误或引用不当之处，欢迎随时来信指教。

希望以此书抛砖引玉，吸引更多玩家一起悠游物联网的世界。

Scott Sun

2016夏


\section{改编说明}

本书以Arduino这个著名的开放式软硬件平台为工具，结合丰富的范例，系统全面地介绍了物联网的三大要素“物”“联”和“网”的产品开发和具体实现。书中涵盖了主控端、传感端、通信和联网等模块的硬件集成、软件开发和软硬件整合。Arduino设计平台的“开放”已不只是“软件开源”意义上的开放了，它的硬件设计也完全“开源”了——即硬件的设计电路也完全开放了，是一个彻头彻尾的开放式软硬件开发和设计的平台。

正因为这种开放性，本书既适合作为大专院校的学生学习硬件设计基础的实践课程专用书，也可以作为业界人士转向物联网产品开发的技术参考书。

除了开发或者实践用的Arduino硬件套件需要单独购买外，其他开发环境和工具软件可以从网站上下载完整版（如果是freeware）或者下载免费版。为了便于读者迅速搭建开发和测试的环境，我们把本书用到的这些软件在官网中的下载地址陈列于下。

（1）Arduino IDE软件环境：https://www.arduino.cc/en/Main/Software。

（2）Fritzing电路规划软件：http://fritzing.org/download/。

（3）Wireshark网络分析器：https://www.wireshark.org/download.html。

（4）Accessport串行通信软件：http://www.sudt.com/cn/ap/download.htm。

另外，本书一共提供了3个压缩文件供读者下载，以配合本书的学习和实践。下载网址为http://pan.baidu.com/s/1i43qtfB（注意区分字母的大小写及数字和字母），若有疑问，可发邮件至booksaga@126.com。

（1）范例程序：所有范例程序及其配合运行的程序，都提供了源代码。

（2）电路图：19个硬件设计电路图，可用开源的Fritzing电子设计自动化软件查看和修改。

（3）参考文件（原厂只提供了繁体中文版）：14个电子文件，包括一氧化碳传感器、无线传感开发系统、程序库、扩展板／模块和各种传感器等的使用手册或者使用说明书。

最后，祝大家顺利、迅速地成为物联网时代产品开发的专业人才。

资深架构师 赵 军

2016年10月


\section{在线下载说明}

本书范例程序、电路图、参考文件请至下面的网址下载（注意数字和字母大小写）：http://pan.baidu.com/s/1i43qtfB。

其内容仅供合法持有本书的读者使用，未经授权不得抄袭、转载或任意散布。如果下载有问题，请联系电子邮箱booksaga@126.com，邮件主题为“用Arduino全面打造物联网下载”。


\section{1-1　物联网的起源与发展}

物联网（Internet of Things, IoT）这个名词可以解释得很简单，物品能够连上网络就算是物联网。

英特尔（Intel）、IBM、微软、台积电、ARM、思科（CISCO）等这些国际知名的企业一致认定，物联网（Internet of Things）将是未来10到15年内会被持续关注且最重要的发展方向。

为什么他们会有这样的认识呢？

有什么样的预兆或趋势就这么认定一定要跟上物联网的浪潮呢？

曾经有一句顺口溜：雾里开花物联网。难道物联网不会是一个昙花一现的主题吗？

我们只需要了解一件事情就会明白：到2020年时，预计会有超过500亿的设备连接上网。这些设备可能是手持设备、家电、移动设备等。而那时候的世界人口也才接近80亿（根据联合国在2010年的估计）。也就是说可连上网的设备已经远远超过世界的人口总数。500亿这个数字还只是硬设备的预估而已，还没计算这些设备会带来的商机、生意模式和信息流的需求等。

回到现今，如果还没有听过物联网，我们会怀疑你的信息来源。如果还没想要加入物联网的行列，我们只能说真的太落伍了。赶紧跟着本书，一起了解并加入成为物联网的一员吧。

物联网这个名词可以解释得很简单，物品能够连上网络就算是物联网。也可以解释得很复杂，这里就不说明很复杂的解释是什么样的了。物联网有很多的变形与应用，会让大家越来越搞不清楚方向，这也正是为什么会有那句顺口溜的原因，因为大家都在谈，但是越谈越不懂。直到2014年左右，人家说真相总是越辩越明，终于让大家看到了物联网的一些轮廓。未来究竟是怎么样的没有人说得清，不过大家的目标是一致的，就是物联网相关技术与应用的持续发展会给人类的生活带来越来越多的便利与进步。

物联网这个名词到底是怎样被提出来的呢？还是要看看起源才能循着脉络通往应用的大海。

大家应该还记得RFID（Radio Frequency IDentification）这项技术吧，即无线射频识别（见图1-1）。通过标签（Tag）与读写器（Card Reader）进行数据交换，用来识别物品的种类，最初的应用是想取代条形码（Barcode）来进一步提升物品识别的效率以及应用。而物联网的概念就是在RFID的技术下，由Auto-ID实验室所提出的，把所有物品通过无线识别技术与因特网连接起来，用以实现智能化的管理。举个例子来说，当你在超市想要购买一个哈密瓜时，只要通过手持设备扫描一下这个水果上的标签，手持设备就会自动通过网络连接到数据库，获得这个哈密瓜的所有信息，包含产地、肥料和运输的过程等，借此我们就可以决定是否要购买这个哈密瓜。标签上的编号虽然是独一无二的，但是因特网和后端数据库的连接使得我们只需要这个号码就可以知道很多“故事”。

图1-1 RFID的应用与系统架构

因此，物联网早期的定义就是因特网（Internet）的延伸，有人将之视为每15年为一个周期的技术变革之一，从1980年的个人计算机（Personal Computer）到1995年的因特网，而2010年则是物联网的起源年，它将引领技术与应用的趋势。美国总统与中国总理都曾在重要的演讲中提到物联网，并将物联网定位成国家的重点发展方向之一。

图1-2 IBM智慧地球的徽标

而今天物联网的范畴则已经大大超越了最初的想法，IBM公司提出了智慧星球（Smart Planet，见图1-2）的概念。所谓智慧，是指通过全面的感知和信息的传递，让我们可以借助这些数据分析出更好的模式或更好的效率，进而带给人类更智慧的生活。

许多公司包含IBM又再将这个概念收敛到所谓的智慧城市（Smart City），希望智慧这样的概念能够先从城市完善，再慢慢扩展到更大的范围（见图1-3）。

图1-3 施耐德电器提出的智慧城市领域（图片来源：www2.schneider-electric.com）

另外，还有一个很重要的题目也是在物联网的潮流下被提出来的，就是工业4.0（Industry 4.0）。工业4.0其实不只是包含了物联网的概念，还纳入了大数据（Big Data）、云（Cloud）。回顾工业的发展史（见图1-4），从蒸汽机的发明让机器取代人工进行生产，那时是工业1.0的时代。当时代越来越进步，机器和人的分工和流水线生产让我们可以大量生产，我们将这个时代定义为工业2.0。工业3.0则开始导入自动化控制器、IT系统等，这个时代的第一台可编程逻辑控制器（PLC）在1969年由Modicon公司推出。

凭借信息物理系统（Cyber Physical Systems, CPS）的发展，工厂内结合了计算机运算的能力以及传感器与输出设备的集成控制系统，它不只是单机运行的概念，利用网络拓扑结合无线感测网络的通信技术，将整个信息流加上时间与空间的多维度延伸，让生产线的自动化、适应性、效率和质量等都可以大幅提升。2011年德国工业展第一次推出此概念后，德国政府立刻视为重大政策并强力扶持其发展。工业4.0有什么好？试想一下，厂区内的所有设备及机械手臂都有传感器随时监控其能耗状态、马达运转功耗。所有信息全部通过网络上传到中央管理系统。管理阶层能立即从手持设备了解整个工厂运行的效率，并适时提出调整。所有设备的状态也持续被记录且推演出异常状态的评估系统，若观察到设备开始有不正常的趋势，工程师可以提前安排检修，或提早通知原厂安排检查，就不会在发生故障时才做后续的安排，这样能够大大提高设备运行和维护的效率。工业4.0的时代正式来临。

图1-4 工业革命的演进（图片来源：DFKI）

另一个结合大数据的应用是生产线上所有的生产过程全部可以通过传感器记录并传送到数据中心机房存储，每一个产品都有分别的记录和最终检查的结果，因此我们可以通过这些数据导出最适合的生产参数。同样的概念在当前智能农业的作物养殖上也被广泛应用。

物联网的发展带动了很多意想不到的产业，让整个产业思维也开始进行调整。在物联网络中，每个节点应该是低成本却又充满弹性的，这让整个微控制器产业大幅发展，后面的章节我们会谈到。不过，更让人意想不到的是创客（Maker）时代的来临，因为硬件成本逐步下降，让更多人有机会用更简单的方式接触到硬件，加上开放源码的风气，逐渐形成了一个生态系统。大家都可以发挥自己的创意推出令人意想不到的产品，各个国家或地区现在都有年度的创客博览会（见图1-5），大家有兴趣的话可以亲临现场了解一下。像各种各样的3D打印机或无人机等都在这些自造者中不断地被讨论，不断有更新的应用推出。

图1-5 一年一度各地举办的创客博览会

像是无人机，以前还处在学术研究计划或是军事用途中，这两年已经有玩家创作出自己的飞行器，小到手掌大小，大至可以运送货物，世界知名的大疆四轴飞行器（见图1-6）已经在全球各地造成轰动，让空拍成为一股风潮。

图1-6 大疆Phantom 3

亚马逊（Amazon）公司以及许多物流业者更是开始评估使用无人机送货（见图1-7），让送货可以更加便捷。与通信技术结合，亚马逊公司开始考虑怎么样直接将货物送到收货人的手上，即使他不在家。这一切看似不相关，实际上都跟物联网的发展有着密不可分的关系。

图1-7 Amazon的无人送货机

另外一个值得注意的是商业模式的改变，物联网时代数据就是金钱，如何收集大量的数据并且分析出有价值的结果将是未来各大公司研究的目标。有一句话说：“羊毛出在狗身上，猪来买单”，说的就是这个道理。微软公司、IBM公司都开始建立自己的大数据仓库，并且广纳硬件厂商合作结盟，未来单打独斗的人是最吃亏的。物联网时代最重要的三个商业模式（节录自《数字时代》杂志的第247期）：

（1）可销售的数据

厂商可能以极低的价钱或免费提供硬件平台，重点是整个数据流的建立及后端数据的存储。之后可以把这些数据再销售给其他公司，例如，前面提到的农业，最终的价值在于整个作物的养殖参数而非硬件。

（2）产品与服务的打包

最近很有名的几个电动车厂商（例如，Tesla和gogoro）都不只是产品的提供者，还是整体服务方案的提供者，让用户可以无后顾之忧地使用他们的产品。

（3）产品共享

谁说一定要拥有才能使用，越来越多的硬件设备是靠租用或用户按照使用量付费的，比如YouBike。

最后，必须提一下，安全性一直都是物联网时代下的一个课题，更多的数据被收集，表示人们所拥有的隐私也越来越少。数据在如此大规模的通信网络中传输，如何确保其安全性？所有的设备都可以连上网络，意味着每个人都有机会和设备通信，无论目的是好是坏。

眼光放远，我们还是要赞叹物联网时代的来临，它会给整个人类文明带来一个全新的视野，就算有困难、有障碍，相信物联网（见图1-8）的巨轮也会一一克服。

图1-8 物联网示意图（图片来源：www.comsoc.org）

本书的介绍流程首先以物联网中数量最多的感知节点开始，从系统化的观点了解一个节点所需要的基本组成，也就是感测（或称为传感）、计算与通信。接着再往上一层，介绍点与点之间如何连接，从一对一、一对多到多对多的网络架构。后半段则以实际的应用来介绍物联网中的无限可能性。本书的架构是由点至线再到面，希望能利用实际的硬件与应用的介绍让大家轻松了解物联网，也能够学习到大家公认的未来10年最热门的知识。


\section{2-1　基础节点的组成}

点是构成平面最重要也是最基本的单位。它的结构看似简单，却必须担负起、承、转、结尾等不同的角色。凭借数以百计、数以千计的点，可以变化出无穷无尽的网络世界。

在物联网的世界中，最基本也是最重要的莫过于担负起感测重任的节点（Node）了，这些节点必须要有能力进行物理世界的感知。例如温度、压力、酸碱度等，在不同场合的应用中，我们需要不同的物理信号，也由于这些节点在整个物联网架构中算是第一线接触到物理外部世界的节点，因此我们也称之为终端节点（End Node）。

因为物理世界中有太多太多种的信号与测量方式，所以在每个节点当中都要有一个核心，也就是这个节点的脑袋，来协助我们进行信号的初步处理与转换。我们希望感测的信号能够先转换成另一种稳定的信号后，再经过通信往其他端点或更上一层的节点进行传送，因此这个核心要有能力及时进行信号转换与处理，必要时还需要有足够的空间进行数据暂存的操作。

通常节点所要负责的事情都是每一时间间隔会持续重复的事件，举例：

（1）读取温度传感器的数据。

（2）转换读取到的信号并提供内部计算。

（3）暂时存储到一空间等待特定时间进行传递。

（4）通过某一方式将数据往另一节点发送。

图2-1 中断节点的应用程序流程

所以我们会利用程序的编写来完成这个固定的流程，并且让它可以在节点内重复无止境地执行。当然，也会有例外的时候，就是突发事件，专业的说法为中断。中断的意思就是在这个固定的流程中，在不特定的时间插入另一事件让节点进行处理，例如节点收到别的端点传输过来的数据，而这些数据必须在这个节点进行判断与分析（见图2-1）。

整理一下一个完整终端节点可能会有的组成部分，大致可以分成核心、输入和输出两大块，不过每一块细分下去还有很多重点需要仔细去评估与讨论。更不要忘记最重要的系统电源，要是没有电源，即使我们接了再多的组件在节点中也都是无用的。

从图2-2可以看到有很多的系统组件规格是我们在设计一个节点时需要思考评估的，该怎么选择才能够符合我们的需求以及满足实际应用时的需要呢？答案接近不可能！因为我们总是希望马儿跑又要马儿不吃草，能够在一个节点中实现的功能，我们总希望能全部一次到位。但是实际应用中，现场的变化与条件限制往往会让我们当初的设计遇到很大的阻碍。目前最好的方式就是采用模块化的设计，先以基本的单位组成进行现场实验，再根据实验的结果调整组件的规格与搭配。最终才可以找到适合的优化设计。

图2-2 节点的系统组件示例

现在是一个创客的时代，我们可以一步一步地实现规划中的物联网节点设计，也可以踏在巨人的肩膀上，利用众人的智慧与经验累积，修改现成的系统来满足自己的需要。下一章节我们将要介绍许许多多可以轻易获取的开发版，让我们可以快速地进入物联网的世界，建立属于自己的架构。

一个好的系统设计，必定是从核心的规格确定开始第一步。而核心的选择绝对不是越贵越好，而是必须因地制宜，根据不同的应用场合来进行选择。举例来说，英特尔（Intel）公司或超威（AMD）公司的CPU几乎占据了个人计算机的所有市场，针对台式机或笔记本电脑，甚至是服务器的用户，他们会推出不同等级的CPU来满足这些用户的需要。台式机的用户通常会考虑大量的运算及复杂的图形显示，因此CPU运算的性能越高越好，而笔记本电脑的用户因为多半是以移动性为主要考虑因素，因此如何省电以延长使用的时间，就是这类电脑所用的CPU必须考虑的。

这里我们还是以为数最多的终端节点来进行系统设计。在早期笔者会建议直接以X86或RISC（Reduced Instruction Set Computing，精简指令集计算）来进行最初的分类，但是对于如今的技术演进而言，两者的差异已经不太明显。可以看到的是，X86目前以英特尔为主要厂商，但几乎是一家独大的场面；而RISC则以ARM为核心，通过技术的授权与合作，已可以看到许许多多知名的厂商，例如德州仪器（Texas Instruments，TI）、意法半导体（STMicroelectronics）和Atmel等。

这里需要注意的是，一般“标准”的X86处理器，还需要搭配其他芯片与内存，甚至外部存储器，才能构成一个完整的系统，因此在所谓物联网中的终端节点设计上并不会将X86作为第一考虑。但是这里的终端节点不包含智能手机等较高端的设备。在节点设计的考虑下，体积与成本将大大影响硬件的选择。

那么何谓不标准的X86呢？因为英特尔也嗅到物联网中的强大商机，在2013年推出的Quark系列的SoC（System on Chip），主要的对手就是以ARM为主的产品线。从图2-3中可以看到，Quark Soc只需要外接简单的几颗芯片，就可以拥有系统所需要的基本功能。

图2-3 以Intel Quark SoC为核心的Galileo开发板（图片来源：Intel）

好了，在这里我们就先不考虑X86的系统架构了，其实英特尔公司主要是把自己产品线的应用定位在网关（Gateway）的解决方案上，而并非是终端上，所以我们就以RISC为第一个分岔点的选择。既然我们已经往前跨出了一步，那么下一步又该怎么选择呢？其实从这里开始就因人而异了，既可以从成本区分，也可以从外围接口的支持来进行区分。但是，现代设备一定是以轻、薄、短、小、便宜等因素来进行选择的，毕竟外观有时候还是比功能重要许多的。下面将介绍所谓的微控制器（Microcontroller）。

什么是微控制器呢？跟刚才讨论的处理器有什么不一样？刚才谈到的都是处理器，那有没有微处理器（Microprocessor）呢？微控制器（Microcontroller）跟微处理器（Microprocessor）的差异又在哪里？是否有太多问号从脑袋当中跑了出来呢？别担心，我们会很简单地介绍两者的差异，以及为什么我们要利用微控制器来当作物联网的系统核心。

前面提到处理器就像人的大脑一般，还是需要手脚五官等来进行数据的收集与反应的动作。而控制器集成了处理器部分的输入和输出功能在同一颗芯片上，借此节省所需要的电路与提高使用的方便性。因此我们可以说：

微处理器（Microprocessor, MPU）＝中央处理单元（CPU）

微控制器（Microcontroller, MCU）＝MPU＋内存＋周边I/O

其中的内存还分成FLASH、SRAM、EEPROM等，而周边I/O更是包罗万象，例如定时器（Timer）、时钟（Clock）、通信接口（UART/USART）、ADC（Analog to Digital Converter）转换器、DAC（Digital to Analog Converter）转换器、基本输入输出等。这些不同的功能集成在一起就会让微控制器有不同的体积大小，如28针脚的封装、64或100针脚的封装，如图2-4、图2-5所示。

图2-4 Atmel ATMEGA328的两种针脚配置

图2-5 微控制器的组成（参考来源：www.mikroe.com）

其实，现在还有另一个很热门的就是所谓的片上系统（System on Chip, SOC）芯片，它的组成更为复杂，可能包含一个微处理器或微控制器，再加上其他系统芯片，也有可能是多核的，也就是不止一个微控制器包含在里面。由于技术的发展，片上系统芯片已经可以像一台计算机一样应用了。目前许多智能设备都是使用所谓的片上系统芯片作为主要系统核心的。硬件厂商也多半会针对特定应用设计出来不同的片上系统芯片来满足特定需求。

说这些就是为了将目前常见的几种核心种类介绍给大家知道，下面列举几个这几年比较热门的开发板，其核心等级也有所不同，让大家思考看看适合用在哪些应用当中。

Intel Galileo

前面提到了英特尔针对智能设备的普及，研发出一款低端的片上系统芯片：Quark。为了满足创客的需要，推出了Galileo的开发板，2014年底推出了第二代，如图2-6所示。其实Quark的主要内部处理器也就是早期的Pentium CPU，是以386、486作为计算机等级区别的那个年代的Pentium处理器核心。它支持标准的网络、USB以及miniSD卡，特别的是还要支持mini PCI express。不过，身为一台计算机，没有显示接口是它的小小缺憾。它可以支持Linux操作系统，也有支持Arduino的开发环境。顺便提一下，英特尔在Galileo之后又推出了一款Edison（如图2-7所示），其芯片大小接近一张SD卡的体积，不过因为太小了，开发时多半需要连接到另一块载板上。英特尔公司喊出的口号是：What will you make？希望能以在高端处理器的知名度打入目前火红的创客时代。

图2-6 英特尔所推出的Galileo 2（图片来源：arduino.cc）

图2-7 英特尔所推出的Edison（图片来源：arduino.cc）

Raspberry Pi series

Raspberry Pi（树莓派，见图2-8）可以说是继Arduino之后最火红的运算平台了。什么是树莓派绝对是大家不可以不知道的，它是由英国的树莓派基金会所发起，目标在于以低价硬件及自由软件让计算机教育普及化。从2012年推出到现在，已经发展了好几个版本，除了接口上的变化外，它能够搭载标准的Linux操作系统并且支持HDMI的输出一直是它的特色。到了第2代甚至连Windows 10都能够支持，可见其硬件处理器规格之强大。虽然它的硬件并未完全开放让大家自行生产，但是价位与体积足以吸引众多的玩家加入。

图2-8 树莓派的外观

BeagleBone series

BeagleBone也是另一块类似于树莓派的高端微型开发板，它的版本利用PCB板子的颜色来区分，因此图2-9中的版本为BeagleBone Black，其搭载的Cortex-A8性能相当好，可以协助用户开发相当多的应用，例如与网络摄像机搭配进行图像处理等。

图2-9 BeagleBone Black

Udoo

Udoo（见图2-10）是一块多种需求一次满足的开发板，直接在板子上内建了两个核心，一个是基于ARM的高端核心，另一个则是Arduino Due的微控制器。因此用户可以直接将Linux安装在高端核心后，再与另一个核心进行沟通与程序加载。整个开发板就像是一台计算机加上Arduino的开发板。

图2-10 Udoo外观

在前面几个开发板的介绍中，是不是都看到了一个名称：Arduino。Arduino（见图2-11）也是一块开发板，它的基础版核心虽然只是八位的微控制器，但是它可以说是引领这一个创客时代来临最重要的推手之一。它第一个完全开放了硬件电路的原始文件，让所有有兴趣的人可以直接下载并找厂商生产，完全不用收取任何费用，当然这是指个人用途而不是以营利为目的的时候。此外，Arduino的开发环境也是完全免费的，可以直接在网络上下载，只需要解压缩后就可以使用，不需要另外安装，也不需要额外的下载通信线，开发板与计算机之间只需要一根USB线就可以提供电源及用于程序下载。

图2-11 早期的Arduino没有USB接口

Arduino是在2005年由意大利的团队所开发出来的，其宗旨是希望非电子电机专业的人都可以轻易地踏入程序开发与硬件使用的世界，所以他们称Arduino为物理运算平台，希望使用它的人都可以轻松将自己脑袋里的想法转化成现实，希望通过Arduino能够让更多的人对电子电路不再那么陌生和害怕，这样的理念让数字艺术、互动艺术的创作家们也都开始使用Arduino。

Arduino的发展超过了十个年头，已有数以万计的专题基于Arduino开发出来，也有近百个硬件开发板跟Arduino可以挂上点关系。更不用说物联网时代了，不管是机器对机器、设备对设备还是人对设备等的应用，大家都尝试用Arduino来实现。

因此本书将会以Arduino作为整个物联网当中的“拱心石”，从Arduino架构起的物联节点直到整个网络，大家通过本书可以轻松地实现物联网中的任何一个应用。

在开始之前还是要了解一下Arduino的相关硬件与开发环境，之后会再针对各个功能进行详细的介绍。

Arduino在2005年推出后，开始广为人知的版本是Arduino NG，这里的NG可不是NO GOOD的意思！而此时Arduino开发板上的微控制器是Atmel公司所推出的ATMEGA 8，这可是Arduino最关键的部分，也是Arduino持续不变的部分，后续的几代也都沿用了Atmel公司的ATMEGA系列，无论是8位还是32位。NG之后不久就进行了一些小升级，从ATMEGA 8升级到ATMEGA 168，名称也改为NG+。再过不久又进行了核心的变化，由168升级到328，之后就是更多人知道的Arduino UNO（见图2-12），比较多的人知道UNO的原因是在这个时候Arduino已经打开了所谓创客的市场与知名度，甚至在近期的Arduino Leonardo（见图2-13）也没有UNO这么出名，就算核心采用了更好的ATMEGA32u4。在这条主线不断更新的同时，也出现了一些特殊的板子，例如Arduino Nano（见图2-14）、Arduino Pro Mini和Arduino MEGA（见图2-15）等。在Arduino官网上，Leonardo已经被官方退休（retired）了。

图2-12 Arduino UNO (ATMEGA328)

图2-13 Arduino Leonardo (ATMEGA32U4)

图2-14 Arduino Nano (ATMEGA328)

图2-15 Arduino MEGA (ATMEGA2560)

下面整理了这几个开发板的微处理器的差异，可以看到大部分差异都是FLASH、EEPROM等的大小不同。

Arduino.cc网站也很贴心地将所有官方的开发板定义好使用的领域，大家可以参考看看。

图2-16 Netduino

Arduino不只是带领了创客时代，更是引领了风潮，它的外观从最开始到最新版变动都不大，因此各种各样的扩展模块都可以持续使用并应用于开发新的功能模块。这也造就了许多跟进者必须模仿类似的外型以争取用户及其他厂商的认同，例如Netduino（见图2-16）等都可以看到相似的外观。

回头看看Arduino为什么受到欢迎，可以从与8051的比较看出端倪。8051可以说是称霸微控制器的一款单芯片，几乎所有电子电机相关的课程都使用8051来进行教学与实习，从书架上相关书籍与相关的开发板就可以知道受重视的程度。而Arduino推出后，一开始的售价约要200元人民币，到现在已经降低到约60元，这样的一块开发板包含了以下几项。

稳压电源：可以接外部9～12V的电池或变压器。

通信接口：与计算机通过USB以串行通信方式进行数据交换。

数字接口：Arduino提供多达13个接口的数字接口，可以由程序决定其功能。

模拟接口：Arduino直接内置6组模拟信号输入，省去额外的转换芯片。

PWM：数字接口中有数个PWM接口，可以用来控制马达和模拟信号。

程序刻录：借助芯片内的Bootloader，让用户直接通过USB下载程序。

图2-17 Arduino的系统组成

如此多的功能，若是用其他的单芯片可能要花更多的钱才能建立如此完善的系统。如此高性价比的Arduino（见图2-17）当然是慢慢冲击到微控制器的市场，并且激起一阵不小的浪花。

前面介绍了包括Arduino在内的许多类型的开发板，其实就像俗语所说的：不管黑猫白猫，会抓老鼠的就是好猫。如何在物联网中的各种应用中寻找到属于自己适合的开发板，需要时间与经验的累积。如果是入门者，强烈建议用Arduino作为第一个入门的硬件。

Arduino除了硬件的方便性与丰富的接口外，另外令人赞赏的就是它的开发环境完全免费，且只需要解压缩后就可以使用，它还提供了Windows和iOS等版本满足不同爱好者的需要。官方网站上从开始到现在持续保持更新并不断加入新的功能，也针对新的开发板保持持续的支持，因此建议大家每隔一段时间就到官网（见图2-18）上更新一下开发系统。

图2-18 Arduino官方下载位置（www.arduino.cc）

选择适合自己的版本与操作系统后，单击即可开始下载，下载完成后会得到一个压缩文件：

直接把这个文件移到想要存放的文件夹后解压缩即可，建议存放到计算机的C或D磁盘的根目录下，这样以后要使用就会比较方便了。解压缩完会产生另一个文件夹，即Arduino的开发环境，这个文件夹会同时存放多个不同的版本，因此不用担心被覆盖的情况。

本书会以arduino-1.6.8作为所有程序的编辑和开发环境，当然后续一定会有更新的版本，至少会有个依据，可以在遇到问题时比对版本来确认可能出现的原因。打开arduino-1.6.8的文件夹后，会有好几个文件夹包含函数库、硬件配置文件和范例程序等，最重要的是arduino.exe（见图2-19）这个执行文件，即开发环境，只要单击这个执行文件，我们就可以进入Arduino的开发环境中。

图2-19 Arduino的开发环境执行文件

arduino-1.6.8中还有一个arduino\_debug.exe，这是在Windows下的调试工具，当发生无法顺利启动的情况时可以用它来了解情况。在启动环境时注意不要选错了。

图2-20 Arduino开发环境

启动开发环境，如图2-20所示。

整个环境可以分成三大部分，最上方有菜单栏和快捷功能按钮栏，包括文件的新建、保存和打开，以及项目的验证和上传；中间的白色部分则是系统程序编辑的区域，系统程序的编写主要由两个部分所组成：setup和loop两大程序区段。第一个setup指的是初始化和设置的部分，整个程序运行时，只有当电源开启或程序重置时才会执行一遍，因此所有只需单次执行的部分都可以在这里编辑。第二个loop则是程序的主轴，也就是程序会重复执行的部分，就像一般在编写单片机程序时会使用的while(1)一样。开发环境下方则是信息显示，包括编译与上传的结果等，可以借此了解是否有遗漏或是语法漏失而造成程序验证或上传失败。

现在，我们来进行第一个程序的上传练习。对于首次加入Arduino开发行列的创客，建议使用Arduino UNO作为第一块开发板，或基于UNO稍微调整的其他类UNO开发板，原因是UNO的尺寸是Arduino最标准的一种，也是最多扩展板可以支持的尺寸，我们在增加功能或是扩展接口时，这样的标准都会大大方便我们在硬件规划时的整合性。

图2-21 驱动程序安装成功

Arduino所有的开发板背后都没有保护的机制，建议使用塑料柱将Arduino的开发板垫高，或背后贴上绝缘保护，避免针脚焊点接触到金属而短路。

前面提到了Arduino只需要一条USB就可以与计算机连接，同时具有供电和数据传输的功能。请先将计算机和Arduino连接起来，第一次的话需要安装驱动程序，只需要将驱动程序的路径指向Arduino文件夹内的drivers即可，计算机会自动安装，成功后应该能在设备管理器看到，如图2-21所示。

接着再重新启动开发环境，从菜单栏单击“文件”，在范例中选择01.Basics的Blink项目（先不用修改任何程序）。只需要从菜单栏中选择“工具”，再从开发板及端口选项中分别选择当前使用的板子及通信接口即可。以笔者使用的板子为例，从图2-21看到的是COM6，因此在软件中可以选择COM6（见图2-22）。

图2-22 在软件中选择通信接口

接着，也就是最后一步了，单击快捷功能栏中一个向右的箭头，就可以将程序上传到Arduino中。若是成功上传，则会在下方看到如图2-23所示的信息。

图2-23 上传完毕后的信息

此时观察一下Arduino开发板上标示为L的LED灯，应该会一闪一闪地闪烁着，表示我们已经成功将环境构建完成。

若是没有成功也没有关系，把下面几个可能的问题确认一下即可。

（1）设备管理器中的Arduino是否正常显示。

（2）Arduino上的电源是否正常。（确认方式是板子上有一个ON的LED应该会亮灯。）

（3）开发环境中的板子与串行端口是否选择正确。

（4）程序是否编译成功。

在物联网中，谈论到了在各种场合的众多应用，唯一不变的是绝对会有大量信号的感知与检测，为什么要说感知与检测呢？我们可以将信号的读取分成两大类：连续性的数据采集及异常状态的检知。

连续性数据采集的重点在于长时间的观察与记录，通过长时间的数据采集，再搭配时间轴的推演，我们可以分析出优化的反应和预测未来可能的变化。因此，如何确保数据的连续性和每项数据都能包含数值与当下的时间是这类设备最重要的课题，像在农业当中若能长时间把作物生长周期所需要的温度与湿度记录下来，我们就可以按照不同种类的植物构建出最适合的环境，以达到优化的生产效率。

异常状态检知的重点则在于实时性。这类数据要定时进行采集，而每项数据的时间间隔会根据受测物的特性而有所不同。这类设备的重点是如何能够采集到反应瞬间的数据并且立即向后端报告。例如，脉搏的不规律跳动往往来得急去得快，要能够抓到这瞬间的异常现象才能够对病患进行进一步的治疗。

至于信号的种类，基本上就是数字信号和模拟信号两种（见图2-24）。数字信号指的是传感器只会有0和1两种信号的变化。例如，门窗的开或关、开关的开或关、机构的接触与未接触等，这些都属于数字输入的范畴。另外，灯的开关、闸门的开关和马达的启动与停止等则属于数字输出的类型。至于模拟信号，则会有电压或电流的连续性变化，不像数字信号那么简明，模拟信号基本上每个时间的数值都会跟前后有相关性。举例来说，温度、压力和湿度等信号都是连续变化的，会随着时间的推移以及环境的影响而产生下一个时间点的数值。

图2-24 数字信号和模拟信号的差异

2-5-1 数字信号

我们的第一个Arduino程序，上传的是内建的范例，其实它就是一种数字输出的信号控制，通过此程序可以驱动LED的亮暗变化。我们来仔细看看这个程序：

首先看到程序的第20行，有一个pinMode的函数，因为Arduino很聪明地使用自己的数字引脚，每一个引脚可以设置为输入或输出，而设置成何种功能必须在setup中确定，在这里我们把第13个引脚设置为输出（output）。

设置完之后该怎么控制输出信号的变化呢？还记得数字信号只有0和1两种吗？在Arduino硬件上的0和1其实就是电压的高电平（5伏特）和低电平（0伏特），而程序中可以用HIGH和LOW来表示。在程序的第25行，我们用digitalWrite来进行这样的控制，函数有两个参数，第一个是要控制的引脚，第二个则是要输出的信号。是不是很简单、很直观呢？全部只需要两行程序就可以完成一个数字信号的输出控制。这些函数的名称也让人一眼就能知道它们的作用是什么。

而硬件上我们则是直接使用Arduino内建的LED，从电路图来看，第13个引脚默认是LED的控制引脚，因此范例程序中以第13个引脚来进行LED的控制，如图2-25所示。

图2-25 Arduino UNO R3上的LED电路

如果要使用其他引脚进行LED的控制，可以参考图2-26所示的电路范例。

图2-26 两个LED的电路接线

LED是有方向性的，两个引脚通常用长短来区分，短的接到GND。另外，可以看到电路中有一个电阻，其作用是限流，常见搭配的规格为1000欧姆以下。

图2-27 8×8 LED矩阵

学会控制多个LED后，就可以尝试来控制8×8的LED矩阵（见图2-27）了，以变化出不同的图案。

从一个设备的观点来看，灯号的显示是必要的部分，因为大部分设备在追求小巧时，利用灯号来进行状态辨识是一种非常好的办法，因为LED的成本低，若是可以同时用3个LED进行显示，几乎可以有十多种变化来分别表示十多种不同的状态，例如供电来源、系统运行或暂停、通信成功或失败、发生异常情况等，都可以通过LED的亮、暗、闪烁或多个组合让现场操作人员清楚地了解程序运行的状况。甚至在一些工业界使用的系统当中，几乎每一个输出或输入的引脚都会配上一个LED来作为信号显示。

某些大功率的设备想要用Arduino来做控制的话，建议使用一个继电器模块或晶体管作为一个中间信号放大的媒介。因为Arduino每只引脚只有5伏特的电压，功率更是远远小于1瓦，如图2-28所示。

图2-28 Arduino的引脚电流上限（数据源：arduino.cc）

在后面的专题中我们就可以看到利用继电器（见图2-29、图2-30）来做控制的例子。

图2-29 继电器（以机械方式用小信号控制大功率）

图2-30 达灵顿晶体管继电器（以电路方式用小信号控制大功率）

介绍完了如何用数字信号控制Arduino输出，我们知道了可以自由地控制许多Arduino以外的设备，创造出更多动态反应。不过，在整个系统的设计当中，输出的部分几乎都属于后期的反应动作，前面必须要有程序的逻辑判断或特定的事件来启动输出的机制。因此，下一个我们要讲的就是Arduino数字输入的部分。

数字输入看似简单，只有5伏特（高电平）和0伏特（低电平）两种信号变化，但是所搭配的传感器有各种各样的形式，必须按照实际的应用来进行适当的搭配。举例来说，光是按钮就有两种：按下即会弹回、按下即固定且需再次按下才会恢复初始状态。前面一种常见于设备设置键，每按一次就表示菜单变化或选择变化。后面一种则常用于设备状态键，例如启动键。有时候在工业应用中，还会设置两个按钮，操作人员必须同时按下这两个按钮才会真正启动设备，避免因为误触而导致误操作。

更不用说巷口的红外线感应灯了，以红外线判断距离来启动灯光；防盗的磁簧开关则是用磁力来判断门窗的开启或关闭；水银开关则用来检测设备是否倾斜。一个简单的ON/OFF信号就可以让我们感知周围的许多状态。

图2-31 一个按钮控制LED开关

在Arduino中，我们一样可以把第1至13个数字引脚用于数字输入的检测，这里我们先介绍一个简单的范例：通过一个按钮来控制LED，如图2-31所示。

程序当中大部分还是跟前一个范例类似，但是前面多了第5个引脚的功能声明。loop循环里则是多了一个digitalRead的函数，只要填入想要检测的引脚，便会返回当前该引脚的信号状态。所以范例中很简单地使用了一个if/else的条件判断语句来让Arduino Pin 5的状态决定Pin 7 LED的亮暗。

这种按钮没有按下时，物理接线没有接到任何东西，也就是我们说的浮接。浮接的缺点是我们并不能确定此时的信号是否一定是低电平，因此遇到这种类型的按钮时我们会采用提升电路的方式来确保信号，我们先如图2-32所示调整硬件电路。

图2-32 使用Arduino内部提升电路的接法

这时候我们只需要稍微调整一下初始设置的部分，将pinMode里的INPUT改为INPUT\_PULLUP：

有没有发现这时候当按钮还没被按下时，LED就已经亮起，跟刚才的逻辑完全颠倒了，这是因为此时Pin 5的默认值是高电平，也是我们为什么要把按钮的另一端改为接地，这样按钮被按下时Pin 5就会是低电平。

这样提升电路可以确保传感器保持在没有被启动时的状态，因为它内部初始提供了一个高电平的信号，借此能提高系统读取的稳定性，就算外部的传感器发生故障，信号还是可以被保持在一个初始的状态。这在输入端电路上是一种常见的设计，而Arduino已把这种设计内建其中。

在终端设备上，我们不太可能内建键盘或鼠标来操作设备进行参数设置，常见的反而是通过多个开关组合进行信号的排列组合，借此让设备可以自动判断当前开关的设置而执行不同的参数，甚至是初始化。图2-33就是一种标准设备，我们称之为指拨开关。

图2-33 指拨开关

2-5-2 模拟信号

在物联网的应用中，模拟信号可以说比数字信号更加重要，像温度、湿度、压力等这种类型的环境数据都必须通过模拟信号来进行读取。早期的8051芯片并没有模拟信号输入的引脚，而是必须通过另外一个模数转换的芯片来进行第一步的处理，8051再通过数字通信的方式从模数转换芯片读取数据。Arduino则内建了6个模拟输入通道（如图2-34所示），这里的通道数量是指PDIP封装时的数量，如果是TQFP的封装因为有32个引脚，所以模拟输入也就多了两个，这在某些厂商的开发板中可以看到。

图2-34 Arduino的模拟输入引脚

我们在利用芯片的模拟信号读取功能时，要注意几个重要的参数，其中最重要的就是分辨率，在规格表中会用几比特来表示，而Arduino的模拟信号分辨率为10-bit，如图2-35所示。

图2-35 Arduino规格书中的模拟分辨率

10-bit所代表的意思是什么呢？它指的是可以解析的信号大小。举例来说，Arduino的参考电压为5伏特，因此可以量测到的最小分辨率为：

这样的分辨率对于一般的应用来说已经绰绰有余了，若是在“专业”一点的应用中，还是会采用另外一个转换芯片，利用专门的模数转换芯片来提高信号的分辨率及确保模数转换的时间。目前在某些研究专用的模拟信号中已经采集到24-bit的分辨率，这种应用的电路需要非常高超的技术，因为周围的自然噪声信号就有可能会大于实际量测到的信号。

我们利用一个可变电阻来尝试通过Arduino读取电压的变化。可变电阻是一种可调电阻值的电阻，其规格标示的是这个可变电阻的最大值，使用上可以通过某些机械结构来调整阻值，例如旋钮式的可变电阻（见图2-36）或线性可变电阻。

图2-36 可变电阻的接线

从图2-36中可以看到，我们选择旋钮式的可变电阻，其电阻有3个引脚，分别接到电源5V、接地GND和信号，信号这里我们接到Arduino的A0。程序的部分我们先用一个参数定义要读取的模拟输入引脚，再定义一个变量初值为0，后续这个变量就是读取到的信号数值：

接着先忽略setup中的设置（这个部分我们会在下一个章节进行详细的介绍），直接看loop循环中的第一行，有一个简单易懂的函数：analogRead()。这个函数的参数传入要读取的引脚后，就会返回当前的模拟信号数值。是不是很简单呀？

程序上传完成后，选择Arduino软件右上方的串口监控器（见图2-37），就会一直有数值显示出来（见图2-38）。以刚才的程序而言，每秒应该有4项数据。

图2-37 Arduino的串口监视器窗口

图2-38 Arduino返回的模拟数值

此时调整可变电阻，数值就会在最小值0到最大值1023之间变化。这个数值其实是Arduino模拟信号的原始数据（raw data），其实也就是我们刚刚讲的分辨率。这个数值必须再进行计算后才可以得到有意义的物理参数，在此乘上0.0049就会变成伏特。在后面的章节中还有几种不同的模块需要经过公式计算后才能变成真正有意义的数值。

模拟信号怕的就是噪声，因为噪声的影响会导致我们无法确认信号的正确性。这时就不仅仅是信号的读取了，还必须加入一些算法来协助系统提高数据的正确性。例如，算术平均算法和移动平均算法都有各自的优缺点与适合的信号种类。我们列举几个例子以示参考。

先来看看算术平均算法。方法很简单，设置一个要取平均的数据个数：

接着用一个循环来多次读取模拟信号，并且累加在一个变量中，最后输出时就是这个总和除以前面设置的平均数据个数：

再来看看移动平均又是通过怎样的方式来进行的呢？主要在于计算方式上的不同。可以从loop循环中看到，我们使用一个数据数组来进行数据的存储，先将一个最新数据存放到数组的最后。接着使用一个for循环来将所有数据往前搬动一个，这样第一个数据，也就是最旧的一个数据就会被覆盖掉。同时也累加了数组中的这些数据。最后输出时再除以数据个数即可。

这两种平均算法非常简单，不需要太多编程的技巧。不过这两种算法在系统一启动时都必须有一段时间来获得足够的数据个数，当我们想要的平均数越多时会花越多的时间。因此建议在系统程序运行时，必须加入一段初始时间，所有输出或控制逻辑在这段时间内都不操作，避免因为错误的数值结果导致发生错误的响应操作。

还有一种方式，利用多个模拟输入的信道来监视单个对象或环境，使用传感器不同的摆放位置与方式，这样同一时间内就可以获得多个数据来进行平均。甚至因为不同的配置，每个输入数值还可以有不同的加权比重（见图2-39）。

图2-39 使用不同输入并利用加权的权重调整重要性

工欲善其事是，必先利其器。只有事先彻底了解Arduino拥有什么功能，才可以根据不同的需要来实现具体应用。前面的章节只是初浅的介绍，还有许多功能没能仔细说明，例如PWM等，大家可以查阅Arduino其他入门书籍或网络资料以便更深入地熟悉Arduino。这个章节我们将从系统运行的角度观点来进行介绍，让大家知道必须按照不同的应用来完善系统的设计。

2-6-1 时间的重要性

在第一个范例程序中，如果我们要让LED灯先亮一秒再接着暗一秒地反复循环，我们使用的是delay()函数，在函数中填入想要暂留的秒数即可。

问题来了，如果想要控制两盏LED灯，以第一盏亮一秒暗一秒、第二盏亮两秒暗两秒的规律来设计，程序上要怎么规划呢？

这里没有唯一的答案，因为程序好玩的地方就是“殊途同归”，只要能达到效率、功能的要求，程序编写的风格会因人而异。不过，要提醒大家的是：delay()这个函数是让程序的逻辑执行到这里后停留特定的秒数，在这个秒数之内发生的所有输入的变化是无法及时响应的。

一种改进的方式是通过内部的时钟来进行条件判断，借此提高整个程序运作时的灵活度，范例2-7是Arduino的原始范例：BlinkWithoutdelay，笔者只是将注释改为中文，我们可以从loop()中看到，在大部分的时间内程序只执行了一行进行条件判断的语句，唯有当条件满足设置值后才会进行灯号变化的控制。因此，在整个程序中并没有看到delay()这个函数，也不会有程序停留的现象发生，这样的方式在程序要同时处理许多输出状态的变化时更有弹性。

2-6-2 实时反应

前面介绍了Arduino上的输入，包含了数字信号与模拟信号。这两种信号在整个逻辑中都可以用一行程序完成读取数值的操作，不过深入这个函数的源代码，还会发现很多行细节的流程。

试想，当你为了你的系统编写了一个一千多行的程序代码，除了前面几行是读取I/O的状态外，其他都是基于这些状态的逻辑运算及响应的输出。如果传感器的状态在后面进行判断时突然有了变化，因为还没执行到程序中读取传感值的地方，所以实际Arduino无法及时接收到这样的信号。

图2-40就是一个例子，程序只在开始阶段进行状态读取，因此此时Arduino可以接收到外部实际的信号，当到了程序在进行逻辑判断时，外部若有突然的信号产生，此时Arduino并不会接收到。因此整个程序从头到尾外部实际共有三次脉冲信号，不过最终你的程序只记录到其中一次的状态变化。

图2-40 外部数字信号的变化与内部实际收到的结果

针对数字信号，其状态的变化称为“事件”。事件的种类可分为5种，整理如下：

（续表）

一般我们在读取数字信号时，都是以判断电位的高低为主，上升沿或下降沿则比较少见，其实针对极短瞬间的脉冲信号，只要能抓到电位从低到高变化的瞬间，也就能掌握到这个信号。另外，有些周期性的信号通过两个上升沿信号的间隔长短也能检测到转速、位移等的变化。

那么有没有什么办法可以让Arduino只要一有状态的变化，马上就可以有所响应呢？当然是有的，我们称为中断（interrupt），指的就是在正常循环的程序中，若有中断的发生是可以立刻被感知的，以数字输入来说，我们需要的是外部中断，这里的“外部”指的就是其他信号源发给Arduino的。Arduino有特殊的引脚支持外部中断。不同的版本有不同的引脚及支持的数量。

我们可以把比较重要的信号连接到这些引脚上，实时地让Arduino接收到设备的状态变化。我们用“按钮的状态来变化LED”的范例来看看这两者的差异。

先看看范例2-8，它先是很标准地进行按钮状态的读取，再进行LED灯光的控制：

接着再来看看范例2-9：

首先在setup()里面可以看到一个特别的函数：attachInterrupt()。这个函数一共有三个参数，第一个是检测外部中断的引脚，这里的数字指的是中断的号码，而非实际的引脚，大家可以参考前面的表格，范例里的0就是UNO的Pin 2。第二个参数是指当中断启动后要执行的操作，因此大多是一个函数，要注意的是这个函数内是有一些限制的，例如delay()和millis()都不会起作用。另外，里面会用到的参数最好在定义前加上volatile，大家可以参考范例中变量state的定义，这样用的原因是让编译程序避免对此参数做优化的操作，详细的说明大家可以在网上查阅。最后一个参数则是利用判断信号的种类来启动此中断功能，范例使用change，表示信号只要有变化就会启动中断内的函数，也就是blink。

主程序loop则相当简单，只是持续进行LED的输出控制。下面可以看到blink函数也只有一行：每次执行都改变state的状态。

大家可以通过这两个范例程序来比较差异性，因为这里程序执行的内容相对简单，也许没有办法明显地看出差异，但是有时候通过中断的使用可以大大提升我们整体系统的效率。

2-6-3 信号警报

前一个章节介绍的是数字信号的事件变化，这个章节则要看看模拟信号的特性以及系统该怎么样处理模拟信号的变化。

从前面的认识中可以知道，模拟信号是一个具有连续性且与前面数值有所关联的信号，有些应用可能需要持续观察信号的数值变化与趋势。因此，在以模拟信号作为系统上的输入源时，我们会设置一至多个警戒区间（见图2-41），借此判断信号是否发生异常的情况。

图2-41 模拟信号与高低警戒值

在系统程序的设计上，我们会用另一个变量来记录这样的异常信号，一种方式是累加发生的次数；另一种则是指记录发生过，例如用灯号亮起表示。这两种方式都会再搭配其他的重置开关，将累加归零或将灯号恢复。

2-6-4 电源规划

Arduino当初的设计就可以从USB直接使用计算机作为电力的来源（见图2-42）。另外，也支持通过变压器来当作外部电源，通常使用变压器是因为Arduino同时还接着扩展板与其他设备，USB不到500mA的电流限制会影响到系统的稳定性。（虽说标准USB的额定电流大小为500mA，有时候主板设计从业者为了保护硬件因为过大功率而损坏，会让极限小于500mA，这点因不同厂商而异，并非一定。）

图2-42 Arduino UNO左侧电源输入（上为USB，下为变压器端子）

Arduino借助稳压IC的帮忙，让变压器端可以接受7～12V（原厂建议值）的电压，表示日常生活常见的9V方型电池和12V电池都可以当作Arduino电力来源，另外现在智能设备非常需要的移动电源也非常适合当作Arduino独立运行时的电力来源。此外，Arduino的硬件上还另外提供了3.3V作为其他设备的电力接点，让用户不用针对3.3V的设备再额外提供降压电路。

那么Arduino在系统运行时实际的耗电量大约是多少呢？这个计算对于物联网的终端设备是一个不容忽视的问题，因为有时侯我们可能需要将设备放置于户外没有电力供应的区域，如何让Arduino有个稳定且足够续航运行的电力来源便是我们身为系统设计者需要考虑的。

此外，刚才提到的移动电源或如图2-43所示的太阳能供电系统因为属于可多次充放电的电源类型，所以实际充满电时其电压多少会高于默认电压，在整个使用过程中电压会慢慢下降，到达临界点则会突然失效（见图2-44）。因此，如果我们可以随时检测外部电源的电压变化，就可以在失效点前提早做准备，例如发出信号通知管理员，或开始将重要参数进行保存，以避免系统失效时的数据丢失。

图2-43 以太阳能板进行供电

图2-44 常见充电电池的放电曲线


\section{3-1　浅谈物联网通信}

数以万计的点洒落在空间中，彼此之间有着默契的相连，几个之间组成一个网络。这样的网络连接非常有价值，点与点、网络与网络间共享着信息与数据，带给空间无穷无尽的变化。

通信在物联网中可以说是相当重要的一环，毕竟物联网三个字中，“联网”指的就是通信。早期的物联网可以是指任何物品或设备能够连接到因特网，后来谈到所谓的机器对机器（Machine to Machine, M2M）的沟通，又把物联网提升到物物相连的境界。云计算机应用的兴起使整个物联网的架构也随之完整。所以要搞懂物联网，首先一定要搞清楚各种通信接口和架构，从通信的角度出发，就能很快理解整个物联网运行和工作的原理。

通信就像人们在对话一样，要有发话或信息给接收对方的方式，例如嘴巴就是一种发话的接口，或比手画脚，也算是一种。无论采用怎样的方式，重点是要能够让对方（也就是接收信息的人）可以明白你的意思，这就是一种通信。如果两个人同时说话，可能会无法百分之百了解对方的意思，因为接收信息的同时你也在发送信息，所以通信当中会有各种顺序规则，让两个人的对话能够很顺畅地一来一往继续下去。如果同时有很多人呢？例如在会议时，又该怎样让每条信息都顺利地给接收方知道，并且正确地发送给想要的人呢？这就包含更多的学问了。下面我们将逐一介绍通信相关的知识，并通过Arduino逐一演示。

通信架构

最简单的通信就是两个人直接的对话，也就是两个设备之间能够通过相同的方式来传送信息，什么叫做相同的方式呢？我们晚一点再细说，不过想想如果有一个人只会说中文，另一个人只会说英文，沟通上就困难许多了。我们把这样的两个设备相互交换数据的架构（见图3-1）称为网络。

图3-1 一对一的通信架构

虽然这样的网络非常简单，但是在许多时候我们都要从这样的基础架构开始来建立起稳定的通信。因为这两个设备既可能只相距1米，也可能相隔100千米，要选择哪种通信方式就要考验我们的系统设计了。

图3-2 5个通信节点

图3-3 主从（Master-Slave）架构（红色为主站）

图3-4 主从架构的通信总线示意图（红色为主站）

接着，我们再加入3个设备。一瞬间通信的架构就变得复杂许多了，如图3-2所示。你会看到一个设备除要跟其他4个设备发送信息外，同时也会接收它们回传的数据。这样就像没有老师在的教室，大家一定是各聊各的，整个教室乱哄哄的。

这样的混乱情况，我们可以利用主从（Master-Slave）架构来解决，如图3-3所示。主从架构的意思就是网络中同一时间只有一个人可以发号施令，由他进行命令的发布，其他人则必须等待接收到正确信号后才可以有所动作，因此通信网络就会变成如图3-4所示的样子。

* 数据端和客户端为笔者自行使用的名词，这样的说法比较好记。

图3-5 主从（Server-Client）架构（黄色为数据端）

这样主站和从站的系统设计通常见于数据比较单一或网络内设备不多的情况下，因为同一时间内只会有一个设备（无论主站或从站）进行信息发送，而其他站都会接收到这个信息。因此主从架构的硬件通常采用总线（Bus）的方式，例如RS-485或SPI等，而每个站也一定会有独立的站号（ID）配置，方便辨识是否需要按照信息来做出响应。

不过到了现在的因特网时代，数据存取的方式又复杂了许多，很多数据放置在远程的主机内，而用户可以通过各种设备来进行存取，甚至可以同时进行，这种通信方式也算是主从架构的一种，不过我们把它定义为Server-Client（见图3-5）。这里的数据端*（Server）是数据所在的位置。客户端*（Client）则是会连接到数据端发送存取数据的请求的一端。同一时间数据端可以允许多个客户端进行连接与数据存取。例如，我们现在常用的云硬盘或实时软件，可以通过不同设备进行数据读取，甚至还可以分享给好友。因此在物联网时代，服务器主机的机房需求也在持续升温中。

数据端无法预测随时被客户端请求连接的数量，它是被动等待连接的建立。因此，从系统设计的角度上，数据服务端的硬件需求较高，不过因为数据可以被集中管理，所以拥有较高的安全性。

你可能会问，如果网络当中突然加入一个设备，或其中一个设备出现了故障，对整个网络会造成什么影响呢？以主从式的架构来说，建议要有重试（Re-try）的架构，这样对于突然少了一个从站的情况，主站能够尝试再与从站联系。如果是多了一个从站，因为主站本来就不知道新增设备的编号，主站不会去跟它进行沟通。但是如果突然加入的设备设置成主站，问题就大了！因为两个主站可能会同时发送命令，造成通信连接的格式混乱，而从站便无法顺利正确地收到预定的数据分组（称为数据包或者分组）。服务架构的网络管理都集中于主机上，因此不管新增还是减少网络中的设备，主机端都可以执行相对应的操作。

图3-6 Ad-hoc点对点网络架构示意图

当然也有力求平等的架构，比如Ad-hoc网络就是一种点对点的通信模式（见图3-6），整个网络中各个设备并没有地位的区分，所有的设备都可以互相传送数据，网络中也可以随时新增或删除设备，不过整个网络的通信效率和设备的耗能规划反而是这种网络的关键，因为单一设备不只是要负责自己的数据传送，也需要随时帮忙转发其他设备的数据。

从物联网的系统来看，由于应用不同、网络内的设备数量多寡不同，因此谁也说不准哪种通信架构更合适。不过可以知道的是，大家都在持续为物联网通信的优化而不懈努力。

前面谈的通信架构不一定都是以硬件来实现的，有的还必须搭配软件才能完整实现整个功能。下面我们单从系统硬件的角度来整理一下常见的网络拓扑结构。

图3-7 线性拓扑

线性拓扑（见图3-7）

每个设备所需要处理的数据源与目标都已固定，网络系统的弹性不大，但是功能实现起来比较简单。

图3-8 星形拓扑

星形拓扑（见图3-8）

整个网络环绕一个核心设备，所有周围的设备都把数据往此中心传送，若此核心突然出现问题，则整个网络将会失去功能。

图3-9 树状拓扑

树状拓扑（见图3-9）

当网络节点数量越来越多时，我们可以将所有设备分成数个小团体和几个层级，这样可以有效管理整个网络内的数据流。不过当层级拉得越多越厚时，数据传送的时间也会越来越长。

图3-10 网状拓扑

网状拓扑（见图3-10）

这大概是物联网中被最多人研究的拓扑之一，点与点之间如何寻找到最佳路径进行数据传送，每个节点如何能在有限的电力来源下保持最长久的运行。有太多太多好玩的主题可以在这里深入、挑战。

在介绍各种常见的通信方式之前，我们要先来谈谈通信接口（Interface）和通信协议（Protocol）的不同。通信接口是指所定义好的电缆接线、电器特性和信号等，基于相同的定义让两个以上的设备可以相互连接。而通信协议是基于前述的接口上所共通的数据格式。举例来说，人类负责说话的嘴巴是一种接口，而中文、英文等则是沟通的协议。当我们使用相同的接口和协议时，才能让对方了解我们想传达的意思。

通信上最熟为人知的架构：OSI（Open System Interconnection）模型，就是由ISO组织提出让计算机间的通信网络能有固定的标准结构。该架构共有7层：应用层（Application Layer）、表示层（Presentation Layer）、会话层（Session Layer）、传输层（Transport Layer）、网络层（Network Layer）、数据链路层（Data link Layer）和物理层（Physical Layer），如图3-11所示。

图3-11 OSI的7层通信架构

注：由于OSI架构是由国际机构所定义的，因此中文译名多有差异，建议同时提供英文对应的名词。

最底层就是我们所谓的实体接口，以计算机间的有线网络来说，就是由铜线组成的实体网络线。每一层都有它特定的功能，用来桥接其下面一层与上面一层的服务。整个OSI带给用户的优点是降低网络的复杂程度、标准化、加速各层的开发、确保通信质量。

至于本书要提到的通信架构，大约可以简化成应用层、协议层、传输层和物理层。应用层指的是我们系统中产生数据的执行程序所在的层。协议层指的是数据以特定的数据分组整理成固定格式。传输层指的是通信的方式，例如寻址、握手等。最后物理层指的是整个网络的拓扑及使用到的电气信号、接口接头等。后续的介绍中大家可以通过这样的分层，清楚了解每种通信方式的优缺点以及适用的场合与范围。

本节先介绍物理层中我们常用的通信种类。最简单的分类方式是以有线（wired）和无线（wireless）作为基础进行区分。不过，这里我们谈的是物联网，所以从覆盖范围的大小谈起。

大家常常听到的局域网（Local Area Network, LAN），其范围定义成数百米内，通常一栋建筑或一间工厂都在同一个局域网的范围内。范围再小的就是个人网络（Personal Area Network, PAN），顾名思义就是以个人为单位的网络架构，像蓝牙网络就是一个非常典型的个人网络。而比局域网更大的则是广域网（Wide Area Network, WAN），这个范围大概是以国家为单位的网络。

图3-12 各种网络的大小比较

在这3个网络中，由于覆盖的范围不同、应用的差异及其特性条件，因此通信的速度也有所不同，大致上是PAN<WAN<LAN（见图3-12）。

所以当前常听到的通信技术会根据其属性与其应用，朝通信速度或通信距离两个方向进行发展，目前还没有同时又快又远的通信技术被研发出来，并且这样的技术是不是真的有其应用也还是未知数。

传输方式

至于传输的方式，可以从方向、方式等进行分类。所谓的方向，指的是两者之间传递的方向性，大致可分为单向（广播）、半双工和全双工（见图3-13）。

单向传输就像是收音机的广播一样，从一个主要设备进行数据信号的发送，其余设备只要能拥有相同的接收配备就可以接收到信息，但是不能反向将数据传回去。

半双工则是两个设备双方都可以互相发送数据，但是因为设备能力有限，同一时间内只能作为发送方或接收方，无法同时发送与接收，所以必须通过额外的硬件信号或特定的协议来辨识何时需要作为发送方、何时可以转换为接收方。例如，无线步话机就是一种半双工的通信方式。当按下通话键后，就只有自己可以发出信息，其他人必须轮流等待。

图3-13 各种通信技术的比较

全双工则是设备硬件在同一时间既可以发送信息，也可以接收数据。这样的方式必须将发送与接收规划成各自独立的信道，比如打电话，麦克风与耳机就是分开的两组硬件，以处理不同的信息。

另外，信号的传输方式则可以分成并行与串行两种。早期的打印机就是并行传输，想要传送的数据以数条数据线路同时进行传输，传输速度较快，由于需要的硬件线路比较多，因此线路上的成本较高，所占体积也比较大。现在的设备都越做越小，芯片处理能力也越来越强，在这种情况下，并行传输已经比较少见了。串行传输不同于并行传输的地方在于数据是通过固定的引脚按序将数据传送出去的，比如RS-232、USB和网络等，当前主流的通信方式以串行传输为主。

从前面的介绍可以知道，现今的通信方式以串行通信（Serial Communication）为主流。主要的原因就是硬件越做越小，芯片的能力也越来越强，因此无论芯片间的通信或设备间的数据交换，都以串行通信为主要方式，例如SPI和网络通信都是。

图3-14 计算机上RS-232的接口

RS-232（见图3-14）则是串行通信的经典之一，被广泛用于计算机与其他设备间的通信，甚至延伸到设备与设备间的数据交换。RS-232对电气特性、逻辑电位和各种信号线功能都做了规定。在标准主板上看到的9个引脚的接头（DB-9）就是RS-232的接口。所谓的RS就是Recommended Standard，即“推荐标准”的意思，其他类似的还有RS-485和RS-422。这些都是EIA联盟所制定出来的，会再标注RS-232-C表示不同版本。

RS-232接口的主要功能是为数据终端设备（Data Terminal Equipment, DTE）和数据通信设备（Data Communication Equipment, DCE）提供实体连接，也就是我们前面讲的物理层。例如计算机就是DTE，而打印机则是DCE。当初设计RS-232是用来连接调制解调器进行数据传输，也因此它的引脚的定义通常也和调制解调器传输有关。通过硬件引脚的方式来判断数据的流向，称为硬件握手。

从上面的表格可以知道，RS-232的9个引脚的信号方向是固定的，借助这些引脚的顺序变化才可以顺利完成DTE和DCE之间的数据传送。说到这里，大家有没有猜到，RS-232若在半双工的通信模式，两个设备间必须通过其他的硬件引脚来确认现在谁负责传送、谁负责接收。

RS-232的信号基准电压是以正负15V来作为逻辑电位的变化，其中负电位的部分为逻辑信号1，正电位的部分为逻辑信号0。从图3-15可以清楚看出这样的电位变化与信号的对比。

从图3-15中可以发现信号的时间长度是固定的，我们称为波特率（Baud rate），单位是bit per second（bps）。常见的所谓9600，也就是1秒内会有9600个二进制位（bit）。从这里还可以看到，RS-232的通信中，会有起始位（START BIT）和停止符（STOP BIT），起始位就是将电位拉到正15V（逻辑0），停止位则是将电位信号拉回负15V（逻辑1）。中间的数据则有8个位，在某些情况下则会有7个位的选择。另外，有校验机制来确保RS-232的通信没有受到干扰，称为奇偶校验（PARITY），方式是如果我们设置成偶校验，表示8个数据位加上奇偶校验位必须要有偶数个逻辑1，反之奇校验就是要有奇数个逻辑1。

图3-15 RS-232的信号电位变化

整个RS-232通信中的设置整理如下：

在RS-232的通信中，双方必须针对以上参数具有相同的设置，接收方才可以正确判断数据的逻辑信号，正确解析出数据的内容。例如，最常见的“9600，8N1”表示的就是波特率为9600bps，8个数据位，没有奇偶校验，有1个停止位。在使用RS-232跟其他设备通信时，必定要先确认设置。

RS-232在计算机与其他设备的沟通基准电压是正负15V，但是在微控制器中，因为多半以5V或3.3V来作为系统电源，所以RS-232的基准电压也随之降至5V或3.3V，习惯将其称为TTL（Transistor-Transistor Logic）基准。例如，Arduino的Pin0和Pin1就是RS-232的TTL基准，微控制器的信号还需要通过另一个转换芯片来提升基准电压至正负15V。

接着我们就来看看Arduino是如何进行串行通信的。首先从RS-232开始。

图3-16 Arduino板子上的TX和RX

Arduino和计算机都是通过RS-232的信号来进行程序上传与数据传送的，刚才提到Arduino板子上的Pin0和Pin1就是串行通信的引脚，如图3-16所示。

在板子上也有通信专用的LED指示灯（见图3-17），我们可以利用指示灯清楚地了解当前Arduino是否在进行传输或接收数据。

图3-17 Arduino的传送LED指示灯

先通过第一个程序了解一下如何启动Arduino的串行通信及如何传送数据。程序3-1很简单，我们只在setup()中放置了两个函数：

Serial.begin()

Serial.print()

第一个函数负责启动Arduino的串行通信，从函数的名称可以很直观地看出它的功能。它需要输入一个参数，也就是我们说的波特率，在范例程序中先以9600作为设置值。第二个函数则是要打印（输出）的字符串，范例中我们是从Arduino发送一串字符给计算机，参数中要输出的字符串必须使用""括起来。

我们将范例程序上传到Arduino后，Arduino的开发软件不止可以用来开发项目，还可以帮忙观察通信数据。请单击右上角的串口监视器窗口，如图3-18所示。

图3-18 串口监视器窗口

打开后应该会看到我们刚才想要显示的信息已经显示出来了。这时看一下右下方是否也是9600，如图3-19所示。

图3-19 在计算机显示的字符串

前面提到串行通信的前提必须是两边的设备都有同样的设置，因为Arduino默认为8个二进制位，没有奇偶校验，有1个停止位。因此我们只有从设置波特率的不同来观察这个现象。我们将串口监视器窗口右下角的参数改为其他速率，就会发现结果跟刚才完全不一样了（见图3-20）。这是因为此时计算机判定数据的格式与Arduino发出的并不相同。

图3-20 范例3-1在计算机显示的字符串（计算机端波特率为38400bps）

接着我们把字符串显示的部分移到loop()中，其余完全不做任何修改。上传后会发现每次输出的字符串全部都连在一起了，无法很清楚地分辨出该断行的位置，如图3-21所示。

图3-21 连续输出字符串（没有换行）

稍微调整一下程序，在print后面加上ln：

编译后再次上传，得到的结果就会非常清楚易懂，如图3-22所示。

图3-22 连续输出字符串（有换行）

会有这样差异的原因是println这个函数会在字符串最后加上回车（carriage return, CR）及换行（line feed, LF）字符。这两个字符属于不可见字符，即为有文字操作功能但是不显示出来。可以参阅附录C的ASCII表了解还有哪些字符也属于不可见字符。回车（CR）符的十进制值为10，十六进制值为0x0A。换行（LF）符的十进制值是13，十六进制值是0x0D。我们可以分别用"\\textbackslash\{\}r"和"\\textbackslash\{\}n"来表示它们。因此，在print后面加上ln也可以用print("\\textbackslash\{\}n\\textbackslash\{\}r")来实现相同的功能：

刚才提到十进制和十六进制，在串行通信上是否可以表现出它们的不同呢？在Arduino里，当然可以。只要我们在函数中加上要表示格式的设置即可。

从范例可以看到，只需要在println中加入第二个参数表示想要输出的格式，就可以将原有的数值转换后显示（见图3-23）。也可以知道print默认为十进制的格式。

图3-23 不同格式的显示

若不确定是否正确，则可以用操作系统内建的计算器来验证。先把计算器设置为“程序员”模式，才可以显示不同的格式，如图3-24所示。

图3-24 利用计算器验算（数值为100）

当然英文字母也是可以的，大家也可以利用Arduino內建范例的ASCII Table来观察相同的显示（见图3-25）。

图3-25 以不同进制格式来显示字母

所谓的通信，就是既要有输出也要有输入，这样两个设备才可以相互交换数据，而不止是单向的数据传输而已。Arduino怎么接收电脑发送的信息呢？只需要“读取”而已。

从范例可以看到，只需要一行Serial.read()就可以进行串行的数据读取。电脑端则可以从串口监视器窗口的上方进行数据输出，从图3-26可以看到我们输出了一个字母Q，下方则是Arduino传送回来的数据，可以发现Q再次被传送回来。不过同时也发现了一个问题，为什么除了Q以外，窗口内还显示出许多方框？这些方框其实是用于表示不可见字符的。因为范例程序是每两秒进行一次Arduino数据的读取和输出，而我们并不是随时都在进行数据的传送，但是Arduino还是按照程序的规定定期读取串行端口，所以许多没有意义的不可见字符被显示了出来。

图3-26 计算机与Arduino两方进行数据传送

数据的传送也算是一种事件的处理，因为无法预测何时会有数据需要Arduino进行接收，因此最好的方式是以中断来触发数据接收的事件。Arduino的串行通信也将通信中断的函数集成好了，使用上非常简单：

可以从范例看到，只需要使用Serial.available()就可以判断是否正在等待接收数据，想象Arduino的串行通信有一个暂存区，微控制器会先将所有外部传来的串行数据放置于此，这个函数就是在统计这个暂存区中数据的多寡，当满足我们设置的条件后，就会通知程序。

别小看这个函数及其所能带来的功能，一般来说串行通信的数据传送除了前面提到的硬件握手（handshaking）外，还会采用固定格式来确保数据传送的完整性。下面列举一个简单的例子：

[起始字符][标头字符串][数据长度][数据][校验码][停止字符]

例：[\$] [DATA] [0x05] [HELLO] [0x0D 0x0A]

这是一个非常标准的串行数据串，例如GPS的接收器就会以类似的字串按固定间隔发出时间和经纬度信息等。数据有多个字段时，可以使用逗号将其隔开。

从范例程序可以看到，使用Serial.available()可以先进行第一次的字符串长度判断，这里我们先只读取到标头字符。因为暂存区的字符满足条件设置后进入if判断语句内，我们要判断第一个字符是否为起始字符。要注意，有些设备的起始字符不止一个！起始字符确认无误后才可以再进到下一个阶段，进行标头字串的确认，如果是则显示Arduino got the data。如果标头字串有误或是有其他类型，则继续执行下一步的判断，一直到信息的结尾。这样我们就可以完整读取到信息字符串。Arduino软件内也内建了很多关于字符串处理的函数及范例，大家可以好好利用。

了解计算机和Arduino如何以串行通信进行数据交换与沟通后，我们就可以知道两个Arduino之间也可以使用相同的方式来进行数据交换了，唯一要注意的是接线的方式（见图3-27）。

图3-27 两个Arduino使用串行通信时的连接

要注意的是Pin 0(RX)必须和Pin 1(TX)对接，而不是Pin 0(TX)对Pin 0(TX)，Pin 1(RX)对Pin 1(RX)。另外，GND也是非常重要的一条线，因为串行通信的信号利用的是基准电压的变化，所以两个Arduino必须将GND连接起来才会有相同的基准电压的变化。

两个以上的RS-232设备要进行通信时，接线方式又会变得复杂一些，如图3-28所示。

图3-28 三个设备使用RS-232通信时的连接情况

从通信架构图可以看到，虽然才接了三个Arduino，但是连线的复杂度却高了不少。另外，从左边的传送引脚接到右边的两组接收引脚中可以看到，当左边发出信息时，右边两个设备都会收到相同的信息，两个设备都必须处理接收进来的信息，这样系统会花不少时间判断信息的内容，进而决定是否要有对应的操作。反过来说，右边两个设备的发送端同时接到了左边设备的接收端，因此右边的设备绝对不可以在同一时间对左边设备发送信息，从而造成左边系统程序无法顺利解析数据。

要避免这样的情况，我们必须让这个网络有主从的概念，设置左方为主站，而信息都必须带有可识别的代号，可以是一个ID号码或是一个独立的名称。这样右方的从站收到信息后，要先判断ID是否与自身的相同。若是，则进行信息解析并做出响应。若不是，则直接忽略信息，从而加快系统的响应。从站要进行数据的发送时，也必须先向主站发出请求，得到许可后再进行数据的发送（见图3-29），这样就可以避免两个从站同时发出信息让主站无法判断的情况。

图3-29 数据回报流程

RS-232常见于两个设备间的通信，甚至后面章节也会看到Arduino和扩展模块之间常常使用RS-232进行数据交换。只是这里要注意芯片的系统电源是5伏特还是3.3伏特。因为芯片制程技术的演进会用更低的电压来确保功耗的降低，借以达到省电的目的。

但是RS-232在多个设备间除了会造成接线上的困扰外，还有一个致命的缺陷：设备间的通信距离不能超过15米。这个距离的限制在现在的应用当中越来越被凸显出来，因为物联网中多个设备在大范围内的应用是越来越普遍的。因此在工业的实际应用中，会用RS-485来作为主要传输的接口。

RS-485与RS-232最大的不同在于物理层和电器特性，RS-485为两线式的总线（BUS），利用电压差来表示逻辑0和1的变化，通过这些改变使得RS-485更容易进行多点通信和部署广域网。至于数据端，RS-485与RS-232一样没有定义通信格式或是协议，因此原本是用RS-232的设备可以轻易通过外部硬件来转换成RS-485的信号。

从图3-30中可以更清楚地看出RS-485的优点：布线的成本可以降低很多，尤其是在多个设备的通信网络中。例如，在工业自动化中，几乎八成以上的仪表设备都采用RS-485来与其他设备连接，以降低成本与需要引脚的数量。这里为什么GND会是虚线呢？原因是RS-485使用两条信号总线的电压差，因此是否在同一个基准电压的重要性就没有那么强烈了，但是在某些特殊场合中因为现场噪声比较大，或是实在距离太远，电源系统是相互独立的，在这些情况会再把第三条GND连接上。

图3-30 RS-485通信网络示意图

另外，在RS-485中还有一个很特别的地方一定要注意，因为它会影响到整体网络的通信质量，那就是终端电阻（Terminal Resister，见图3-31）。有些品牌知名度较高的仪表设备会内建这个终端电阻在每个设备中，但实际上只需要在整个总线上加上一个即可，通常会给离主站最远的设备配置终端电阻，厂商或是一些参考资料上会建议选配120欧姆的阻值，这个阻值会因为每个现场的不同而进行微调。最好的方式是采用一个可变电阻来进行现场调适，当通信质量达到最好时，就是最适合的阻值。因此没有所谓的“标准值”。

图3-31 RS-485的终端电阻配置方式

另外，建议使用双绞线进行RS-485的网络连接，因为双绞线的缠绕方式可以有效消除干扰，以加强对噪声的抵抗力。

Arduino并没有RS-485的引脚，如果需要RS-485的通信则必须搭配另外一个转换芯片，例如MAX485（见图3-32）。

图3-32 RS-485的转换芯片MAX485（图片来源：MAX485 Datasheet）

晶片左边的部分跟Arduino连接（见图3-33），其中RO（Receiver Output）接到Arduino的Pin0（RX），DI（Driver Input）接到Arduino的Pin1（TX）。另外，在RE（Receiver Output Enable）和DE（Driver Output Enable）中，注意到RE上面多了一个横杠吗？它的意思是取反，从内部逻辑电路中也可以看到接线末端有一个小圆圈，表示逻辑判断的NOT，当外部信号输入HIGH到RE时，内部最终信号会转换成LOW。这样的设计刚好让我们可以将RE和DE两个短路，通过同一个信号来转换RS-485的传送或接收。

图3-33 MAX485范例电路

在程序的部分，RS-485一样会通过主站先发送要求数据的命令，然后由从站进行信息传送。这时要特别注意主站的485模式切换，必须先确保从站完整接收到信息后才可以切回接收模式，不然会造成数据传送的不完整。至于主站要等待多久才切换，会因为参数配置与设备距离长短等原因而有所不同，因此必须实测后才可以得知。大家可以思考一下该怎么样才能做到自动切换，这里称为Auto flow control，或是寻找支持此功能的芯片以让485通信非常有效率，而不会把时间浪费在等待切换操作上。

总结一下，RS-232和RS-485的特性不太一样。RS-232由于传输和接收是独立分开的引脚，因此可以做到全双工的通信模式，但是由于电器特性的缘故，通信网络的总长度并不会太长，最快的传输速率在115.2kbps（特殊的芯片可以达到921.6kbps）。RS-232主要用于两个设备（DTE和DCE）之间。RS-485则属于总线的形式，因此多半以半双工模式进行通信，485网络上就可以连接多个设备进行数据交换。有些芯片的传输速率可以到达10Mbps。两个设备最长距离可以达到1200米。会不会有个疑问：有没有综合两种特性的通信方式呢？有的，即RS-422。不过因为接线成本比较高，应用上就不及RS-232和RS-485这么普及了。大家有机会还可以查阅相关的资料。

这里要介绍的是另一种通信模式，称为I2C。它的全名是Inter-Integrated Circuit，中文为内部集成电路。从名字就可以知道这种通信模式大多用在系统内芯片间的通信，而较少用在设备与设备之间。例如，计算机获取屏幕分辨率与参数的方式就是通过I2C，算是CPU跟显示器内部芯片的数据交换。

I2C只需要两条线路（见图3-34），分别是SCL（Serial Clock Line，串行时钟线）和SDA（Serial Data Line，串行数据线）。从字面上就可以看出I2C也是一种串行通信，与RS-232或RS-485不一样的是，两个设备通过I2C进行通信，并不需要特别设置相同的通信参数，因为在I2C的两条通信线中，SCL就是负责告诉对方通信速度的。因此I2C可以很方便地在整个通信网络上新增设备节点。

图3-34 I2C的接线方式

图3-35 Sparkfun的加速度计与陀螺仪模块使用I2C（图片来源：Sparkfun）

咦！不是说只有两条线吗？怎么还是有Vcc和GND呢？因为I2C多半是芯片间的通信，因此电源应该都是来自于同一组，所以这里只是要提醒I2C的两条通信线还会加上一个提升电阻确保未导通时能处于高电平的状态。数据读取的方式则是SCL由低电平升为高电平时，读SDA的数据。例如，传感模块（加速度计、陀螺仪，见图3-35）、显示模块（LCD、OLED）和时钟模组（RTC）都可选择使用I2C接口进行通信。至于通信的速率，标准I2C可以100kHz进行数据传输，而快速模式可达400kHz。

在物联网的架构中，有一个关键因素，那就是时间。因为整个物联网络架构散布的区域可能很广，距离也可能很长，从数据采集到的时刻到传送到最后的决策或是存储中心的时间并不能完全掌握，因为造成影响的因素太多了，所以大区域的物联网应用都希望能够除了采集数据之外，同时记录下采集的时间点，以利后续分析时能够清楚勾勒出随着时间变化的信号变动。

另外，在控制中很重要的就是调度，如何精准地知道当前时间并进行响应，例如建筑物的灯光控制、温室里的洒水系统等，都需要时间参数才能顺利控制输出的时间点与周期的长短。

所以我们期望系统内的每个设备都能够取得绝对时间，例如年、月、日、时、分、秒。而这样的功能我们会利用所谓的RTC（Real Time Clock，实时时钟）来实现，每台计算机内都有这样的芯片，这种芯片会持续计算当下的时间，只要系统电源持续工作，它就能够稳定地提供正确的时间。但是，系统电源失效时，芯片也就失去了作用。因此，这也是为什么很多计算机内都会有一颗钮扣电池的原因了。RTC的电源电路（见图3-36）会判断何时系统电源失效而转换成钮扣电池继续进行供电。

图3-36 RTC芯片DS1307与模块上的电池（图片来源：Adafruit）

RTC芯片就可以利用I2C来跟Arduino进行时间的设置与输出。要进行I2C通信前，需要先知道I2C之间通信的方式。I2C整体通信也是MASTER-SLAVE的架构，因此主站（MASTER）要先知道想要通信的从站的站号，每个从站会有一个ID号码。所有在从站的数据都会有一个固定的地址，因此我们只要能够知道每个站的ID和数据的地址，就可以轻松使用I2C进行数据交换。我们先从Arduino的范例来了解一下。

Arduino的I2C范例可从“文件\\textbackslash\{\}范例\\textbackslash\{\}Wire”里找到，第一个我们要看的是从站（slave\_sender），可以看到因为要使用I2C通信，所以必须引用Wire.h这个头文件，而在setup()里我们可以看到就像串行通信一样，必须先启动I2C，也就是Wire.begin()。这里要注意从站必须加入自己的ID号码，此处是2。接着我们设置一个触发事件：当主站来要数据时，直接回应6个二进制位。

在主站的部分，范例master\_reader也需要先启动I2C通信，唯一不同的是不需要先设置ID号码。在循环中，通过requestFrom()来设置想要通信的从站以及想要取得的数据长度。接着就像串行通信一样，利用事件来触发数据接收的动作以降低系统等待的负担：

回过头来看看我们要用的RTC模块。模块上使用的是DS1307（见图3-37）这个RTC芯片，从规格表内可以知道它的ID号码为1101000（二进制），也就是0x68。它的数据地址从0x00开始，分别是秒、分、小时、星期、日、月、年。

图3-37 DS1307的数据地址

而每个地址里又必须了解换算的方式，才可以将数据转换成时间，如图3-38所示。

图3-38 DS1307的数据格式

知道了这些，我们就可以轻松地从Arduino的I2C获取RTC的时间数据了。但是在Arduino的世界中，总会有更快速的方式可以让你完成项目，专心思考怎么样将其应用于物联网中。

在Arduino的官网上，也就是Arduino.cc，有很多第三方硬件的各种函数库与教学，链接为http://playground.arduino.cc/。在这里可以找到各种Arduino前辈们留下来的足迹，因为大家都热爱Arduino，所以把辛苦的研究成果都公开出来让其他人学习。这里先利用Time这个函数库教大家如何引用前人的成果，体会一下如何站在其他巨人的肩膀上。

请先从网页http://playground.arduino.cc/Code/Time下载Time及DS1307RTC两个压缩文件，下载完成后再把这两个文件复制到Arduino软件文件夹内的libraries中，解完压缩后重新启动Arduino软件，应该就可以看到这个新增添的函数（见图3-39）及范例了。

图3-39 新增外部函数库

或是直接在软件里面引用，也是另一种便捷的方式，如图3-40所示。

图3-40 直接新增函数库

大家可以直接运行范例测试看看是否能够读取到时间，范例为TimeRTC。接线的方式如图3-41所示。

图3-41 RTC电路接线

有时候可能买回来的RTC模块并没有电池或是电池已经没有电了，因此会无法正确显示时间（见图3-42），范例会要求你再运行另一个范例来设置RTC。设置完成后记得要持续保持RTC模块是有电源的状态或是先换上一颗新的电池后再进行设置。这样范例程序就应该可以正确显示出当前的时间了（见图3-43）。

图3-42 RTC尚未被设置时无法正确显示

图3-43 正确显示的RTC时间

回过头来看看细节部分。读者可以从DS1307RTC这个文件夹内的.CPP文件了解整个数据读取的过程，第一步先设置好RTC的ID并启动I2C通信：

数据读取的部分就是从00H的地址进行7个字符的收集与解析：

至于设置时间的部分，大家可以再找找程序代码在哪。它其实会先停止计时，再设置新的时间，之后才重新启动。

如果是网络架构的系统，因特网就已经有很成熟的时间机制了，例如NTP（Network Time Protocol）或是新的IEEE-1588。到后面谈到网络通信时再跟大家聊。

SPI（Serial Peripheral Interface，串行外设接口，见图3-44、图3-45）是一种高速、全双工的通信总线。从前一个章节的I2C到SPI，可以算是一种进化。目前SPI多半用于高速接口，例如EEPROM、FLASH等。在Arduino中，SD卡存储接口和部分网络通信模块都会采用。它是一个四线式的架构：SCK（Serial Clock）串行时钟信号；MOSI（Master Output, Slave Input）SPI主站输出，从站输入；MISO（Master Input, Slave Output）SPI主站输入，从站输出；以及SS（Selection signal）选择信号。

图3-44 两个设备SPI的连接方式

图3-45 SD模块上的SPI接口

Arduino针对SPI的部分都已经隐藏在不同的函数库里了，因此在SD卡的读写或是网络通信里都不会实际看到SPI的影子。别因为看不到就觉得不重要。例如，Arduino板子上右侧的六个引脚（见图3-46）就是SPI的接口应用，是通过外部刻录器刻录程序用的。

图3-46 Arduino ICSP引脚说明（SPI）

本节是我们有线通信中的最后一节，却也是承先启后相当重要的一个关节点，因为先有了以太网络（Ethernet），才成就了因特网（Internet）的时代。基于这些基础技术的演进，才有了我们今天在这里所谈的物联网。因此我们把网络通信分成两节来讨论：有线和无线。

因特网的应用之所以能够带给大家这么大的便利，主要是因为它的方便性及覆盖范围。你可以轻易地从家中的计算机通过浏览器浏览世界各地的网站，轻松地从网络上学习到各种知识。能有这样的方便性全是因为网络通信的架构充满弹性以及所具有的独特性。网络通信所需要的知识太多太复杂了，在不同的领域需要了解不同的特性。例如，架设一个购物网站或是利用网络进行影音串流（Video Streaming），背后都有相关知识需要学习。建议大家到网上或是从书籍中去了解这些知识，本书只针对几个特点以及范例所需要用到的部分来进行解说。

3-6-1 定义自己在网络中的地址

从前面的介绍可以知道，当设备越来越多时，我们会以独立的编号或是名称来定义通信网络上的所有设备，当信息发出时，我们就可以知道是由谁发出和由谁负责接收了。因特网也是这样，其中一个参数就是IP（Internet Protocol，因特网协议）地址。几年前这个IP地址还是以四个字节来表示，也就是32位长的二进制数。为了便于用户识别与使用，每个字节使用“点”作为间隔，例如：

192.168.1.1

用点隔开4个十进制的数字，每个数字只会介于0～255之间。这种地址分类方式称为IPv4，是第4版的因特网协议，可以提供超过42亿个地址给设备使用。不过，最近这个地址已经宣告枯竭，因此有了IPv6的出现，希望能为将来物联网的设备提供充足的地址空间。

IPv4的寻址方式，其实还有所谓专用网络和广播地址也包含在内，因此使用上不可以随便定义一个地址给设备使用，而需要先了解自己所处的网络才可以按规则进行设置。这4个十进制的数字其实表示一个网络和一个设备。根据使用的场景与需求，IPv4定义了不同层级的网络，以A、B、C来分类：

* 会减2的原因是一个地址用来代表整个网络，另一个则用来广播。

举例：

表示在192.168.10.0这个网络中，只有254个设备可以使用IP，地址从1到254。

子屏蔽在这里的用意就是区分出IPv4的地址中网络的地址和设备可用的地址。

如果大家自己在家中利用Arduino连上网络，通常会通过网络运营商提供的路由器连到因特网，这样的网络架构下，多半地址会以192.168开头。在学校计算机教室中也会有类似的特定网络会随每个学校有细微的不同，大家在使用前必须先了解整个网络的设备或是请教专家后再开始测试。

3-6-2 因特网通信的方式

图3-47 数据传送的过程

因特网能有这么大的规模主要依靠每一层架构之间的相互关系，这里说到的层就是通信七层（OSI），让我们可以将数据经过协议转换，再通过设备传送到整个网络上（见图3-47）。对方也可以再一层层解析还原为原来的数据。因此OSI模型上的七层在如此庞大的网络下缺一不可。

因特网在不同的应用中会使用不同的通信协议（见图3-48），例如HTTP、HTTPS、FTP等，还会根据不同的OSI层有不同的协议。如果要我们自己一个协议接一个协议慢慢地建立在Arduino中，我想就没有人会拿Arduino来实现网络的应用了，况且Arduino本身的微控制器并没有强大到能够直接处理网络通信。因此我们需要另一块扩展板。

图3-48 不同通信层的协定

Arduino原厂就有一块网络扩展模块Ethernet Shield（见图3-49），还有一块支持PoE（Power over Ethernet）的扩展板（见图3-50）。所谓PoE，就是利用以太网络的标准网线进行数据传输与电源的供应。

图3-49 Arduino Ethernet Shield（图片来源：Arduino.cc）

图3-50 Arduino Ethernet Shield with PoE（图片来源：Arduino.cc）

标准的网络接口类似RS-422，在RJ-45的8个引脚内共使用了4个引脚进行数据传输，剩下4个暂时没有使用。而这8条线必须是两两一对的对绞线，以颜色区分，1、2一对，3、6一对，4、5一对，7、8一对。这样能够提高线材抗噪声的能力，尤其是当传输距离达到最大（100米）时。线材也有等级的定义，比如CAT 5、CAT 6。CAT 6抗噪能力高于CAT 5。千兆网络（GLAN）或是工业现场就会建议使用CAT 6。

PoE（见图3-51）就是使用网线中没有使用到的另外4个引脚的其中两个来作为电源的接线，这样的好处是可以省去接线的麻烦，只需要一条标准的网线即可作为电源与数据的物理接口。尤其是物联网，设备较多，能省下电源的配线来降低成本。如果觉得Arduino的PoE模块太贵了也没有关系，大家可以去找找图中的转接线，好处是电压的基准位可以自己配置，但是也要注意随着长度的增加，电压有可能会因为阻抗而衰减。一般标准的PoE基于IEEE 802.3af，电压为36～57V，15.4W的功率。PoE在使用上还要注意除了接点的设置外，供电端与接收端一定要有相同的配置来避免设备损毁。

回到网络通信部分，Arduino标准的Ethernet扩展板采用W5100这个网路控制器，它支持标准TCP/IP的数据协议，包含TCP、UDP、IPv4、ICMP、ARP、IGMP和PPPoE，也集成了MAC和PHY。用户可以很简单地使用它来建立网络相关的应用，唯一美中不足的是，它只支持同一时间下的4个连接（Simultaneous Socket Connections）。当我们拿来做服务器时就会发生连接数量的限制。若有第三方公司使用W5200（见图3-52）则可以支持到8个连接。

图3-51 PoE转接线

图3-52 Seeedstudio推出的W5200网络扩展板（图片来源：Seeedstudio）

应该怎么使用呢？Arduino已经有内建好的函数库Ethernet library可以直接使用，当然这是以W5100为基础的函数库，若是W5200则需要额外引用自身的函数库。

W5100 Ethernet扩展板的特点如下。

支持TCP/IP Protocols TCP，UDP，ICMP，IPv4 ARP，IGMP，PPPoE，Ethernet。

支持Auto MDI/MDIX，Auto Negotiation。

支持4个独立的socket。

支持16KB高速缓存。

现在来使用DHT11温湿度模块建立我们的第一个网络服务器，这里使用的是Arduino的网络模块，也就是W5100（见图3-53）。范例程序中同时也有W5200的使用方式，先以注释避免使用，大家可用手边的模块进行切换。

图3-53 Arduino W5100网络通信扩展模块

DHT11（见图3-54）则是采用一线式通信的温湿度模块，大家可以拿到单个组件或是厂商集成好的模块。与Arduino连接的就是基本的三条线：电源（5V）、接地（GND）和信号线。这里我们利用Arduino微控制器的特点之一，A0～A5也是可以当作数字引脚的。若是从引脚编号来看的话，则从A0也就是第14个脚开始，一直到19。从范例程序可以看到，我们是直接使用A0这个变量，不过在这里指的是数字信号而非模拟信号。这个范例让大家知道了可以灵活运用模拟引脚。

图3-54 DHT11的接线方式

由于Arduino已经将网络函数库纳入基本的支持，因此我们只需要导入DHT11模块的函数库，并在程序前面将两者引用进来。此外，因为是通过SPI接口与W5100进行通信，所以也可以看到SPI.H的头文件：

在前面提到的网络通信中，有一个很重要的参数，即IP地址，通过它我们可以知道网络的规模，也方便定义信息的接收与发送端。对于IP地址，我们可以有所谓的私有IP和公共IP。所谓的私有IP，就是在局域网（LAN）内的设备所拥有的地址，只在局域网内有效，常以192.168开头。例如，家里的网络或是公司内网大多属于这种类型。而因为应用环境的关系，网络内的设备可能常常有变动，所以私有IP会随时间而改变。

公共IP则是独一无二的地址，它定义在整个因特网的范畴内，类似我们的身份证号码，它会有独立的机构核发，这个地址让我们可以从世界上任何一个地方连接上拥有这个公共IP的设备，因此这种类型的地址通常不会变动。

有了IP地址还是不够的，因为IP地址是可以自行调整的，网络设备还有一个参数即MAC地址（Media Access Control Address，介质访问控制地址）。它在OSI模型中与IP地址分属不同层。MAC地址共48个二进制位（6个字符），其中前面一半是由IEEE来指定设备生产厂商所拥有的地址，后面一半则由各厂商自行规划。

如果今天只是简单的网络通信测试，只要将Arduino和计算机连接起来通过网络来交换数据（IP地址可以自己设置），让两者同在一个网络即可。但是，如果将设备数量增多或是同时有很多设备要进行测试，就必须沟通好大家的设置，例如使用大家的班级和学号来规划。

在Arduino的网络模块中，可以自行设置IP和MAC地址，因此我们必须规划好每个设备的IP地址并确认MAC地址没有重复。MAC是十六进制数，因此我们可以用计算器来进行数值转换，如图3-55所示。

图3-55 计算器的模式转换

接下来直接输入你定义的参数，再调整十六进制即可，如图3-56所示。

图3-56 十六进制转换

这样就可以在Arduino中设置我们要的MAC地址和IP地址了：

接着我们要让计算机端的浏览器可以观察Arduino上的数据变化，必须让Arduino变身成一个网页服务器主机（Server）：

这里为什么看到一个80的设置参数呢？这其实就是所谓的端口（Port）。因为一台网络上的主机同一时间可能需要身兼数职，例如网页服务器、FTP文件主机等。很像公司内部的分机，对外只会有一个代表号，通过不同的分机转接，可以让你找到不同的部门。

将网络功能应该定义的参数定义完成后，就可以初始化相关的功能了。

就像串行通信一样，只需要一行程序begin就可以启动网络通信，里面的参数就是我们前面预设好的IP和MAC。如果你的应用需要GATEWAY和SUBMASK，也可以参考注释部分的设置方式。

至于主程序的部分，第一件事情就是先读取DHT11温湿度模块的数据：

接下来因为Arduino是服务器主机，所以只需要随时响应客户端的连接请求即可，就像串行通信的事件一样，也是使用available()函数：

确认客户端已经连接到Arduino后，Arduino必须先发送HTTP的回应标头，内容包含了内容类型及一些设置：

接下来才是网页内容的信息：

完成整个项目的编辑与上传后，我们就要设置计算机与Arduino连接显示的数据了。

先要确定计算机网络的设置。从控制面板中的网络和因特网里面的网络连接可以看到我们计算机的网络接口。在我们使用的那个接口上右键单击，选中“属性”命令，如图3-57所示。

图3-57 计算机网络接口

找到网际网络协议，再单击“属性”按钮，如图3-58所示。

图3-58 网络功能设置

用计算机直接跟Arduino的网络模块连线时，可以采用固定IP的做法（见图3-59）；但是使用用整个计算机教室的网络时，建议听从老师的指示。这样才可以顺利连上！

图3-59 网络IP设置

最后启动IE浏览器或是Google的Chrome浏览器，输入Arduino的IP地址，应该就可以看到如图3-60显示的数据了，而且网页的标题还是自己设置的呢！

图3-60 浏览器显示的温湿度数据

多数局域网使用动态的方式取得IP地址，也就是所谓的DHCP（Dynamic Host Configuration Protocol）。网络内会有一台服务器来分配可用的IP地址给连上网络的设备，比如Wi-Fi热点就是采用的这种方式。

Arduino也支持DHCP功能，当在Ethernet.begin()里只设置了MAC地址而没有设置IP地址时，Arduino会视为要使用DHCP的方式获取IP。可参考以下范例：

有线通信的好处是实体的接线让我们可以清楚地看到两个设备是否对接上了，不过这也是有线通信会受到限制的问题，因为实体的线路连接会有数据碰撞的可能性，网络通信也是一直通过技术的演进来降低数据碰撞造成的影响。网络通信能够有这么大数量的设备相互连接是因为有完善的协议架构，并且各层都有对应的硬件来协助，例如路由器（Router）和交换机（Switch）。但从实际应用的现场考虑，有线通信的可靠性还是受到肯定的，不像日常生活无线通信那么普及，在工业应用中，RS-485、网络都还是主流接口。下一章节将会介绍无线通信的部分，大家可以比较一下有线与无线的差异性。


\section{4-1　初入无线通信}

在物联网中，无所不在的通信占有大部分的版图，其中无线通信又被视为物联网设备的基本配备。所有感测（或传感）数据要能够不受限制地往上传送，靠的就是部署完善的通信网络，目前在大都市中，移动通信网络（Cellular communication）和Wi-Fi无线网络都是覆盖范围最广的，有许多的应用因此孕育而生。

本章就来介绍几种常见的与Arduino结合的无线通信方式以及应用。与有线通信相比较，双方各有优缺点，例如通信的弹性、部署的成本以及网络内设备的数量，都是我们实际在应用环境下必须考虑的。在小范围的应用中，无线化是一种趋势，比如有越来越多的家电直接支持无线网络，整个影音环境或是应用场景的掌控都可以通过无线网络来控制。而比较严苛的工业应用中，无线通信才算是萌芽初生的阶段，整个系统有部分重要性较低的已经开始尝试，但是要到全面展开还有一段路要走。由有线和无线通信架构的整个物联网如图4-1所示。

图4-1 有线和无线通信架构的整个物联网

无线通信有许多特点，例如：

节省布线与区域部署的成本。

弹性的网络配置。

拥有较佳的通信距离。

不过，稳定性与安全性是无线通信最容易让人产生疑虑的。任何事情都有好与坏的两面，只要学习如何适当地应用就能发挥它最大的价值。要能够驾驭无线通信来满足我们的应用需要前，必须能够认识无线通信的一些基础知识。

无线信号基本上是利用不同频段的电磁波来进行数据的传输，比如收音机、无线电视、蓝牙（Bluetooth）、移动电话和无线网络等。无线信号根据不同的频率会有不同的使用特性和应用场合。例如，民航机常用的VHF（Very High Frequency，高频）。

每个频段可使用的范围是受到限制且按分配使用的，就像水管的大小是有限的一样，为了能够传送更多的数据必须拥有更大的带宽。图4-2是一张频段使用的分隔图，被切割的程度已经无法分辨清楚。

图4-2 美国已使用的无线频段（数据源：U.S. Department of Commerce, 2003）

除了ISM频段外，其余的频段各个国家或地区的当地政府都可以收取一定的授权费用来发放使用执照，因此，同样的一个无线设备在不同国家或地区都必须再向当地发放授权的单位进行申请与认证。所谓的ISM指的是工业（Industrial）、科学（Scientific）和医疗（Medical），三种领域的应用是开放使用的，只需要遵守相关的规定即可。各国或者地区开放的频段多多少少有些差异，不过2.4GHz是全球共同的ISM频段，这也是为什么日常生活常用到的频段都在2.4GHz，例如无线网络（802.11 b/g）、蓝牙、Zigbee等。

无线技术虽然是利用电磁波来进行数据的传送，但是数据的内容实际上还是0101的数字信号，如何增加无线传输的可靠度，其调制技术（Modulation）便是关键的因素，这里只列举而不详加介绍，目的是让大家知道当前有哪些技术：

另一个比较重要的信息是窄频与展频通信。窄频的特色是高功率但必须精准，如果大家利用天线接收电台的信号，就会发现只要频率稍微偏移了一些，信号就会没那么清楚了，一个无线电台的发射台可以覆盖很大一个范围，唯一的缺点就是如果有人在同频段使用更大功率，就会影响和干扰原本的信号，也就是“盖台”。

展频通信一开始是由于军事上的需求而发展出来的，它可以将信号隐藏于自然界的噪声当中，使其不易被发现。展频，顾名思义就是将信号分散到一个区段内的频段，而不像窄频这么集中，因此相对来说展频的功率需求也比较小。目前主流的无线通信都是采用展频技术。因此系统所需要的功率不用太大，当频段相同时也不怕别人的信号盖过自己的。由于带宽广，因此同一时间范围内的用户不用担心没有频道可以使用。

天线选择

无线通信不只是使用的技术会影响数据传输的质与量，在系统规划中还有许多需要考虑的地方，例如信号强度、可视距离和多重路径等（见图4-3）。无线通信不像有线通信那样，只要两个设备彼此确定有实体线路相连接，就可以开始进行数据传送，对于无线设备我们必须考虑到发射和接收信号的强度，两者的范围必须要能重叠才能让彼此有机会进行数据交换。当强度确认没有问题后，信号最好的传输就是通过直线可视的路径（Line of Sight），就像弓箭手在射击时，弓箭飞行的路径就是从弓箭手眼睛到目标物的直线距离。这段距离必须没有任何遮蔽物才可以确保精准命中目标。刚才提到的发射强度，就像弓箭手的最大射程，神射手一定要先确定目标进入射程范围，再进行瞄准，才有机会命中红心。不然弓箭会随距离逐渐衰减直到坠地。

图4-3 无线通信的传输考虑

通常根据天线的选择，发射端有机会朝多个方向同时发送信号，例如全向天线。这时如果信号路径上有障碍物，就会造成部分信号的反射或是被阻挡，有可能造成多重路径的效应。多重路径因为信号历经的路程比较长，会有时间延迟的现象，在某些需要精准时间进行运算的技术就必须避免多重路径的影响，例如GPS。但是多重路径也提供了另外的路径选择，因此可以提高数据传送成功的百分比。

物联网的应用绝对脱离不了无线技术的使用，所以也就脱离不了天线的评估与选择。像是智能手机这么成熟的产品，也曾经发生过因为天线设计不良而造成用户不便的情况。

目前多数的无线通信模块都采用PCB的直接印刷电路天线或是陶瓷天线（见图4-4、图4-5）。这样的好处是直接与模块合而为一，体积小而且不用担心匹配的问题，但是陶瓷天线的效率并不高。这两种类型的天线在硬件设计上需要多加考虑，避免受到周围元件的影响而无法正确发挥作用。

图4-4 PCB印刷天线（图片来源：Seeedstudio，ESP8266 Wi-Fi模块）

图4-5 陶瓷天线（图片来源：Seeedstudio，RN-171 Wi-Fi模块）

另外，物联网的许多应用是以户外为场景，因此系统外一定会有外壳来保护电路及相关设备，若采用的是金属材质，则会完全遮蔽这种天线的感应，折中的办法是使用塑料外壳，但耐磨性就不如金属了。

所以建议在使用无线通信的模块时，选用有SMA接头（见图4-6）或是有U.FL接头的模块（见图4-7）可以大大提升在天线上的选择性和便利性。

图4-6 SMA天线接头

图4-7 U.FL天线接头

有了弹性的接口后，我们可以自己选择适当的天线。天线基本上分为全向型（Omni-directional）和定向型（Directional）。这样的分类是由信号覆盖范围的角度来区分的。

顾名思义，全向型就是将信号以360度发射出去（见图4-8）。如果电磁波可以用肉眼看见，它就会像一个甜甜圈一样围绕在天线四周，当然随着距离的增加信号的强度会逐渐降低。

图4-8 全向天线信号的示意图

在系统部署的时候，需要按照现场的信号分布来进行最适合的架设（见图4-9），天线尖端方向应该与信号需求方向垂直。

图4-9 水平信号发射时天线应该配置的方向

图4-10 定向型天线的信号示意图

定向型天线则是将信号集中往固定方向发出（见图4-10），避免不必要的信号浪费。这种类型的天线多半以平板或是碟状的样式出现。定向型天线的背后几乎没有信号的存在，使用上可以明确定义信号发射的方向。通常，定向型天线的另外一端也会是定向型天线，彼此通过固定的方向确保信号的质量，常见于户外长距离通信的使用，尤其是双方必须在可视方向上时，例如楼顶间的传输等。

在使用上，天线绝对没有所谓的越多越好及越大越强的概念。现在许多网络设备都拥有两到三支天线，可是实际上的使用方式还是必须从内部硬体的设计来看，既有可能是MIMO技术，也有可能是将传送跟接收分开处理，或是真的进行信号强化。天线的大小也一样，必须搭配上整个系统的设计，才会有最佳的通信质量。如果内部没有所谓的功率放大器PA（Power Amplifier），那么天线端再大也没有太好的效果。从系统的角度上来看，天线用于协助调整信号发射出来的范围，让信号能够集中在想要应用的地方。

在电子零件商店常常会看到许多应用专题的零件组合包，一定少不了RF无线电波。其中比较常见的是315MHz或是433MHz（见图4-11）的频率，这种模块大都为单向的传输，也就是里面有一对模块，一个负责传送，一个负责接收。这种应用常见于停车场的门禁控制或是一些简单的灯光控制上。这些应用都只需要单向的数据传输，闸门或是灯泡并不需要传送数据给使用者。因此这种类型的通信模块可以用于物联网架构的最终端，用于短距离的单向控制或是数据传输。

图4-11 433MHz RF通信模块（图片来源：seeedstudio）

这里我们使用这样的模块来进行继电器（Relay）的控制。继电器（见图4-12～图4-14）是一种机械结构的开关，原理是通过接收到的电压变化驱使内部的线圈激磁，进而带动结构的变化。建议使用厂商设计好的模块，避免Arduino直接连接继电器，原因是继电器会有所谓的反应电动势，继电器元件本身有可能会产生一个反向电压向Arduino灌去，造成Arduino的引脚损坏。厂商设计好的模块都会有二极管等元件确保电流方向来保护Arduino。

图4-12 继电器的外观（单轴双切型）

图4-13 继电器内部构造（激磁左边线圈带动右边开关方向）

图4-14 继电器模块（图片来源：seeedstudio）

仔细看一下继电器的规格，可以发现除了直流信号以外，还可以控制交流信号。例如，ORMON公司生产的G5LA-14-5VDC继电器就可以承受250VAC最大10A的信号。这样我们就可以进行家电自动化的应用了。

发射端的部分很简单，RF模块只有电源跟信号共三个引脚。当然还有天线的部分，如果有匹配的天线就会让整个实验效果提升许多。简易的天线设计是以1/4波长为天线长度，使用手边的铜线即可作为天线素材。铜线的长度是：315MHz约23厘米，434MHz约17厘米。当然，还有很多参数会影响通信质量的好坏，大家有兴趣的话可以再深入研究。

在一对模块中，短小的为发射端，长的为接收端。这种低成本的RF模块常常需要额外一组编译码芯片来协助提升数据的准确性，降低噪声的干扰。例如，HT-12E和HT-12D就是一组编码及译码芯片，要和RF模块的传送与接收端分别配置（见图4-15、图4-16）。它有8位的编码以及4位的数据引脚。从范例接线来看，我们可以利用这个编码IC输出Arduino四个引脚的变化，若分别代表一种状态，就可以有4种信号发送给接收端。若是以二进制来看，则会有23共8种信号。

图4-15 加入编码芯片于RF模块传送端

图4-16 加入译码芯片于RF模块接收端

可以看到编码及译码芯片都有指拨开关，两者必须设置相同的配置才可以正确接收到数据。这样的结构无法传送较为复杂的数据，但是应用于简单的设备控制是可以接受的。

当然我们希望化简硬件上的复杂度，让我们的系统能够轻易被复制并部署在整个物联网的网络中。因此，这里我们引用一个函数库：VirtualWire。它的好处是不需要编译码芯片，可以直接让Arduino连接RF模块，并且可以直接传送字符串。从这里可以了解到，整个系统的组成是需要硬件和软件（固件）相互搭配的，有些地方可以利用硬件的特性来加强，有些地方则可以通过程序的编辑而补强。碍于篇幅的限制，我们就不深入讨论VirtualWire这个函数库厉害的地方了，而是先学会使用它（见图4-17、图4-18）。Arduino的优点是可以得到许多前辈们的心血，让我们在学习的路途上省下很多不必要的力气，再加上源码开放，深入学习高人的思维，让自己吸收不同的养分。Arduino的开放与完整性造成有些人觉得是学习上的快捷方式，无法有扎实的基础功，但是在现代技术如此快速更迭的情况下，学会如何站在巨人的肩膀上，看得比巨人更远，才是学习的王道。

图4-17 使用VirtualWire的传送端接线

图4-18 使用VirtualWire的接收端接线

在继电器模块中，有NO（Normal Open）和NC（Normal Close）的引脚，指的是在平常尚未激磁的状态下，这个引脚的特性。NO指的就是断路（或开路），而NC指的是短路，也就是与C点接触在一起了。只要一给继电器信号，NO就会变成短路，NC就会变成开路。大家可以按照这个特性连接不同的设备或是线路。

程序的部分我们先从发射端看起。第一个当然是要引用VirtualWire这个函数库，别忘了先加入函数库到Arduino IDE中。接下来我们设置一个参数作为RF模块的信号引脚，这里是Pin 12。

在setup()当中，除了启动串行通信作为系统状态检查外，也将Arduino板上的LED作为信号发射确认。最后两行也就是RF模块的设置，分别是引脚及传输速率。接收端除了引脚要改成接收端的引脚外，其余设置相同。

在循环中，为了让范例能够清楚呈现，我们每五秒改变一次继电器的状态，分别传送“0ON”和“OFF”两个字符串。为什么ON前面要加个数字0呢？原因是为了判断方便，如果启动和停止的两个字符串长度不一样，在接收端的处理上就必须判断两次，以确保长度跟内容正确。因此，我们从发射端就先设计好相同的长度，让接收端只需要识别内容来做出响应即可。

来到接收端，前面设置的部分大同小异，只要改变RF模块的引脚设置即可。重点放在循环中。前半部分我们要处理从RF接收到的字符串，跟串行通信一样，可以用判断语句来降低系统的负担，只有当有信息传送进来时才开始处理。我们将接收到的字符串分别存储到字符数组中，并且在串行端口进行显示。

接收完毕后，程序就会进行字符串内容的判断，并对继电器进行控制。这样应该就可以听到模块每五秒切换的声音了。

实际应用一定不会是这样反复地让继电器重复开关，因为继电器是有寿命限制的，当超过特定切换次数后可能会有故障。可以加入前面学到的RTC进行定时控制，或是加入传感器（例如光线或是温度）来驱动家电的运行。

提到低成本的RF通信，就不能忘记nRF24L01这个模块，市场可以找到的基本款价格在20元人民币上下，几乎要比433/315MHz的RF模块还要便宜，而且工作频段还是2.4GHz。

nRF24L01（见图4-19）是Nordic公司所推出的一款低功耗的2.4GHz通信芯片，市面上最常看到的模块是按照公板设计而成的，大概规格整理如下：

使用2.4GHz ISM频段。

最高可达2Mbps的通信速率。

最多可支持与其他6个模块进行通信。

低功耗（11.3mA@0dBm TX，13.5mA@2Mbps RX）。

高度集成，无须太多周边电路。

SPI通信模式。

1.9V～3.6V工作电压。

输入信号的基准电压可达5V。

可使用频段为2.4GHz～2.525GHz，共126Ch@1Mbps。

* 以图4-20为例的引脚说明。

图4-19 nRF24L01无线模块

图4-20 nRF24L01引脚定义

图4-21 nRF24L01+PA

比较长一点的版本加上了功率放大器（PA）和SMA天线座，这样传输距离可以增加一些，如图4-21所示。

2.4GHz是全球通用ISM频段，因此这是最拥挤的一个频段，好在展频技术的演进，将各种无线通信通过不同方式切割成多个频道。例如，WLAN就有十几个频道让同一个空间中用户之间的相互干扰降到最低（见图4-22）。

图4-22 WLAN2.4GHz的频道分布（图片来源：https://en.wikipedia.org/wiki/List\_of\_WLAN\_channels）

nRF24L01可以支持一百多个频道供用户选择，用户可以自行设置。

因为模块采用的是SPI模式，所以使用上与Arduino有特定的引脚（见图4-23）。

图4-23 nRF24L01引脚说明

记住模块是3.3V的基准电压（见图4-24），必须要接到Arduino的3.3V。

图4-24 模块的电源为3.3V

至于函数库部分，Arduino playground也推荐了几款，笔者早期使用的是Mirf这个函数库，有些参数需要自行设置，使用上也不难，不过后来更新比较少。比较新的则可以使用RF24，最新版本在2014年，可以用于Arduino、ATTiny、Due和Raspberry Pi。

第一个范例我们就先来看看怎么建立一对一的通信模式，这里使用到的是maniac的RF24，记得先导入到我们的Arduino环境中。因为RF24有些输出用到printf.h这个函数库，所以也需要一并引用进来。

如同其他模块一般，因为nRF24L01采用的是SPI模式，所以只需要在初始变量中设置CE和CSN两个引脚即可，范例中使用了Arduino D7和D8两个引脚。另外，nRF24L01需要设置每个节点的地址，地址大小为5个字节，我们设置为“1Node”和“2Node”，因为RF24函数库会颠倒地址的顺序，所以我们把数字放在前面。

初始化相关功能：

这里模块提供了许多参数可以让用户自行调整，我们以功率大小的范例让大家了解，另外通信频道等也都可以自行设置：

nRF24L01通信很重要的是信道（pipe）的建立，这里识别的方式是设置的地址。以一对一的通信来说，一方的接听要和另一方的传送设置成相同的信道，既可以使用两个信道进行传输和接收，又可以都以同一个信道进行。这样设置的好处是我们可以有特别的信道进行参数设置或是私密的数据交换，而真正的数据传输采用的又是另一个信道，这样可以提高安全性和参数设置的可靠度。

最后默认开启应答模式以及显示出当前通信模块的相关参数（见图4-25）。

接着主循环中由Arduino D4的状态分辨是传送端还是接收端。传送端每秒会发送Hello World的字符串。如果要传送数值数据，在范例的注释中有如何传递模拟信号数值的示范。

另一个部分是接收端，比较特别的是在判断是否有数据时（radio.available），还要另外确认是从哪个节点传输过来的。因此除了数据之外，还显示出节点的号码（见图4-26）。

图4-25 通信模块的参数

图4-26 显示传送的数据节点与模拟信号的数值

大家有没有好奇，刚才的范例为什么要强调节点呢？nRF24L01有一个厉害的地方就是可以支持“一对六”的星形通信，从模块的规格书可以看到此架构为MultiCeiver（见图4-27）。

图4-27 MultiCeiver的架构

在程序中只要把节点的地址设置清楚，即可支持星形架构的通信。不过要注意，此架构还是一次跟一个传送节点（child node）通信，系统会按序跟每个节点进行通信。切记，一定要确保每个地址都是独立的。

图4-28 Funduino的水位传感器

这种星形通信应用可以使用在环境监控上，例如加上水位传感器，我们就可以监测区域环境内水位的高低，例如Funduino的水位传感器（见图4-28）可以轻易地将水位高低转换成模拟信号，再由nRF24L01的通信网络回传数值，我们就可以了解水面高低的变化，针对异常状况做出响应。

在2.4GHz频段的通信，当然还有很多会经常用到，蓝牙就是其中一个。它原本就是被定义在短距离（个人局域网，PAN）中设备之间低功耗、低成本的相互通信接口，尤其是在所谓的移动终端。最初的设计是希望解决RS-232的实体线路与数据同步的问题，由爱立信（Ericsson）公司所提出的一种解决方案。在电脑与手机的外围设备连接中被大量采用。

不过，在物联网的浪潮下，蓝牙一度几乎快被ZigBee等新一代的无线通信所取代，原因是蓝牙通信协议下所被限制的设备数量、支持的网络拓扑结构以及整体耗电并不适用于物联网的应用。好在2010年4.0版的推出重新让蓝牙回到物联网的战场上。

蓝牙4.0最重要的变革就是在电源效率的提升和网络内支持的节点数量，通过协议的演进可以支持到大量的蓝牙设备进行网络连接。这个部分称为Bluetooth Low Energy，简称BLE，号称可以省下近九成的电力消耗。另外还开发出单模和双模两种模式（Single Mode \& Dual Mode，见图4-29）。单模模式为设备提供了能通过简易的设备搜索和可靠的一对多数据传输来达到低成本、低功耗的传输目的。双模模式则是可以与不同蓝牙版本进行通信，适用于与各种类型的蓝牙设备进行数据交换。其标准协会也针对这两种模式推出了不同的标志，让大家可以清楚分辨它们。

图4-29 蓝牙单模与双模的标志［Bluetooth SMART READY（上）：双模、Bluetooth SMART（下）：单模］

在与Arduino的搭配上，比较常见的模块是HC-05和HC-06两款，其蓝牙符合V2.1+EDR的规范，并且支持SPP（Serial Port Profile）的蓝牙模块，让用户从计算机或是手机上连接时可以视为串行端口的设备。

HC-05属于主从（Host/Slave）一体的模块，简单来说就是功能比较多，可以设置为主端或是从端，一般来说出厂设置为从端。若是选购其他厂商的蓝牙模块也需要注意主从端的设置，以及是否可以调整。以HC-05（见图4-30）来说，它多了一个Key（有些模块可能是EN）的引脚，当输入高电平时用来启动AT命令模式，让我们可以通过一些ASCII的字符串来改变模块的参数设置。不过要注意有些模块为了省空间可能将此功能删除了，选购上要特别注意。

图4-30 HC-05模块示意图

HC-06直接被设置为从站模式，引脚上只有电源与传输共4个引脚，如图4-31所示。

图4-31 HC-06模块示意图

我们可以先从计算机端来测试蓝牙模块的AT命令。这时候与Arduino的连接只是将Arduino当作USB转TTL RS-232的转换接口，因此要将蓝牙模块的RX与Arduino的RX（D0）对接，蓝牙模块的TX与Arduino的TX（D1）对接，如图4-32所示。另外，因为这时候不需要使用到Arduino上的微控制器，我们将Arduino板子上的reset引脚和GND短路，让微控制器持续处于重置状态。

注：HC-05默认速率为38400bps，HC-06默认为9600bps。

图4-32 计算机端通过Arduino连接到蓝牙模块

记得要将HC-05的Key引脚也一并接到5V的信号，让蓝牙模块进入设置模式，这时候模块上的LED灯号应该是每两秒一次亮暗变化。打开串口监视器窗口，先调整速率为38400bps以及结尾带NL \& CR，如图4-33所示。

图4-33 计算机端的通信设置

利用输入“AT”来确认是否正确和模块通信，如果输入的字符串错误，模块会返回ERROR，若正确，则会显示“OK”，如图4-34所示。

图4-34 蓝牙模块回应的信息

我们也可以查询模块的相关数据，例如固件版本、名称，分别使用AT+VERSION和AT+NAME来获取，如图4-35所示。

图4-35 模块的信息

想要修改成自己专用的模块名称，只需要使用“AT+NAME=”即可。AT命令输入成功后，会显示OK。这时候再确认一次名称应该就可以发现已经调整为自己刚刚输入的名称了。这个名称同时也是HOST端在搜索时会显示出来的！

一般的计算机或是手机又该怎么连接到模块呢？首先打开计算机的蓝牙界面，它会自动搜索周围的蓝牙设备（见图4-36），这时如果有一个以上的蓝牙模块，建议连接前先修改名称或是先关闭尚未连接的模块。

图4-36 计算机搜索到蓝牙模块

单击后会要求输入配对码，默认密码为1234或是0000，如图4-37所示。

图4-37 输入默认配对码

等到整个驱动流程完成后，应该就可以在设备管理器中看到两个由模块产生出来的COM PORT（见图4-38），在移动设备的通信上，若能采用蓝牙模块就可以避免USB线所造成的牵绊，甚至可以直接进行数据的传输和程序的更新。

图4-38 蓝牙模块的串行端口

手机端的部分，大家除了可以制作符合自己需求的APP外，也有许多玩家完成的APP让我们可以直接下载使用，例如BT Terminal就可以读取蓝牙发送过来的信息。自己也可以写个APP来读取蓝牙传过来的信息。

这里给大家推荐一个很好的APP，不过目前只有Android的手机可以使用，名称为RoboRemo（见图4-39）。免费版的功能就足够好了，有兴趣的人也可以安装付费版，多了图片的功能。

图4-39 RoboRemo APP

RoboRemo支持完全定制化的图形组件设计（见图4-40），大家可以按照自己的应用完成需要的用户界面，通信的部分支持蓝牙、Wi-Fi，因此Arduino可以轻松地通过此APP来与手机进行控制与数据读取。

图4-40 RoboRemo的图形组件

先别急着进行APP的编辑，而是把Arduino这里的系统设计完成。我们要建立一个场景灯光控制系统。这两年有些厂商把灯泡智能化，可以按照心情需求来进行调整，让你可以随时调整环境灯光的颜色。

要能够让颜色被控制，单色LED绝对做不到，这里需要要用RGB三色LED。不同于单色LED，RGB LED（见图4-41）共有4个引脚：最长的是共阳或是共阴的引脚，这在购买时可以选择，会影响的是接线与控制的信号。剩下3个按序是R、G、B三原色的控制。RGB LED的光会随R、G、B这3个引脚电压信号的大小而改变，与调色盘的原理一样。

图4-41 RGB LED

在Arduino的引脚选择上，我们要选择能够支持脉冲宽度调制（Pulse-Width Modulation, PWM），大多简称为PWM引脚。简单来说，它是利用数字输出的引脚来仿真模拟信号的输出。它还算是一种数字信号，是一个一个的方波，不过这个方波的高电平与低电平时间是可以被调整的，如图4-42所示。

图4-42 PWM信号原理

Arduino家族中支持PWM的引脚（见图4-43）数量并不一样，以Arduino UNO来说，全部共有6个，也就是：3，5，6，9，10，11。在Arduino上看到引脚数字旁边有个小蚯蚓图案的就是了。Arduino的PWM一共可以分成256等份，信号输入以0～255作为区分。

图4-43 Arduino UNO PWM引脚

接线就按标准的LED接法：每个信号引脚需要一个限流电阻，如图4-44所示。蓝牙的部分我们按模拟串行端口来进行连接。

图4-44 系统接线

程序的部分，只需要声明仿真串行端口并指定蓝牙模块使用的D2和D3为RX，TX即可。

由于笔者使用的RGB LED为共阳型，因此除了设置3个PWM引脚为输出外，同时也设置高电平为初始值，表示LED熄灭。

主循环的部分，持续等待蓝牙端的数据传输，RoboRemo的默认结尾字符为'\\textbackslash\{\}n'。所以以此为命令接收是否完整的判断。数据收进来之后，我们另外编写了exeCmd()函数来解析并且控制输出。

在execmd()中，要先判断命令字符串的第一个字符是否为r、g、b三者之一，第二个为空格符。程序必须先判断确认命令正确后，再读取后面的数值，这样就可以控制RGB LED的灯光变化了。

接下来是重头戏，即RoboRemo的开发！安装完程序后启动应该是完全空白的界面、只有左上角有Menu的按钮。按下后会调用列表，我们先选择第二的edit ui（编辑用户界面，如图4-45所示）。

图4-45 RoboRemo - edit ui界面

单击后，会发现整个界面变成灰底，这时候再轻触一下灰底的部分会看到所有可以使用的组件（见图4-46）。这里要用的是slider（滑杆）。

图4-46 RoboRemo - item界面

新增的组件可以直接放大、缩小来调整，单击它可以进行参数的设置。这里我们需要设置两个部分：set id和send when moved（见图4-47）。

set id：就是刚才程序中的第一个字符，按序设置为r、g、b。

send when moved：表示当滑杆改变位置时就发出命令字符串。

图4-47 RoboRemo –设置组件

这里的set min、set max默认值是0和255，刚好就是我们需要的范围，因此不用调整。

全部编辑完后，再单击一次menu（见图4-48），选择don't edit ui离开编辑界面，这时候大家可以试着转动手机，你的界面也会随之变化。

图4-48 RoboRemo编辑完成界面

图4-49 连接方式的选择

图4-50 询问是否开启蓝牙

图4-51 选择蓝牙设备

要进行连接，可单击menu中的第一个选项：connect。之后就可以选择蓝牙或网络，如图4-49所示。

这里先选择蓝牙，如果你的蓝牙默认是关闭时，RoboRemo会提示你是否要打开，如图4-50所示。

选择蓝牙设备，如图4-51所示。

接下来会询问要选择哪一个port，这里请选择第一个。到此即完成了所有的设置，试着滑动滑杆就可以看到RGB LED的颜色也跟着变化了！

在初期Arduino受到玩家注意而开始进行应用时，最常搭配的无线模块就是Digi公司所推出的XBee。Digi（见图4-52）是一家提供无线解决方案产品的公司，除了硬件以外，顺应物联网的发展，该家公司也开始有自己的上层管理软件，让客户可以从底层设备无缝连接到上层的管理软件层。从首页的图片可以看到，这家公司已经有30年Machine to Machine（M2M）的经验，通过他们设备的连接可以将数据上传并实时进行分析和对异常发出警报。

图4-52 Digi首页（图片来源：http://www.digi.com/）

这里要谈的XBee其实是Digi公司的嵌入式无线方案的模块，用于为终端节点提供使用无线连接到其他设备或通信网关（Gateway）。因此，实际上Digi公司在XBee模块提供了2.4GHz RF、Wi-Fi和ZigBee/802.15.4这3种方案，如图4-53所示。

图4-53 Digi的3种嵌入式无线模块方案

在七八年前，由于方案还没有那么完整，因此大家都是使用ZigBee/802.15.4这款模块和Arduino整合成无线传输方案。那时候很多人只把它作为一对一的传输架构，实在是太大才小用了，尤其是XBee模块单价并不低。所谓的ZigBee/802.15.4是一种无线传感器网络（Wireless Sensor Network, WSN）架构，它作为物联网的新兴架构也越来越受重视。下面我们先简单介绍一下WSN。

无线传感器网络——Wireless Sensor Network

在电影情节当中，常常会有一个剧情是利用外星人的科技从中取得新的技术，借此发展出更强大的防御，最后用此技术打败敌人。无线传感器网络最开始是来自于战场上的传感器需求，提出了一个智慧灰尘（smart dust）的方案。概念是借助低成本、低功耗的微型节点，其身上带有传感器能感应周围的状态，还能将数据传送至周围的节点，整个微型节点的网络数量可达千万以上，数据能够以最佳路径进行传输，网络的拓扑结构也会随状态而变化，新的节点不需要注册机制，只需要设置成相同区域即可加入运行。因此慢慢地IEEE 802.15.4的标准就这样成型了，不同于无线网络（wireless local area network, WLAN），其标准为LR-WPAN（low rate – wireless personal area network），低速率的无线个人局域网。而ZigBee就是这个标准下其中一个热门的协议，后续像是6LoWPAN（见图4-54）、HomeRF、Zware和ANT+等都是基于此标准发展出来的协议，各协议按照应用场合的不同，其协议架构有细微的差异。

图4-54 TI（德州仪器）的6LoWPAN架构范例（图片来源：http://www.ti.com/lsds/ti/wireless\_connectivity/6lowpan/overview.page）

就芯片大厂来说，TI公司推出了CC25XX系列来满足不同协议的需要（在本书后面的章节中，会使用TI模块进行ZigBee连接）。

WSN（见图4-55、图4-56）的特点如下。

低成本。

低传输量：约250kbps。

通信距离短：约100米以内，有些会增加功率放大器来增长距离。

低功耗：以“年”作为使用的时间单位。

节点数量多：64bit寻址方式。

支持多种网络架构：对等形（Peer to Peer）、星形（Star）、簇树形（Cluster-tree）和网形（Mesh）。

网络内的节点分成三种角色：主控端（Coordinator）、路由节点（Router）和终端节点（End device）。由于角色定位不同，功能上也会有所取舍，大致可分为：RFD（Reduced Function Device）和FFD（Full Function Device）。

图4-55 WSN的簇树形拓扑（Cluster-Tree）

图4-56 WSN架构与节点角色

Digi XBee

回到XBee，我们要使用的是XBee ZigBee/802.15.4的系列模块，到现在XBee已经算是到了第三代了，几个演进版本如下。

XBee Series 1：第一代的XBee模块。称之为第一代其实只是为了区分推出的时间，要注意所有不同代次的XBee都不可以相互沟通，若要架设多个节点的网络，则必须采用相通代次的模块，无论两个模块放得多近，都不要花时间去尝试使用不相通的模块。第一代的配置比较简单，适合初学者的应用，但相对功能比较少。

XBee Series 2：第二代的XBee模块，强化了网络拓扑的能力，还提供了API模式让玩家可以掌握更多模块通信的信息。不过，更多的弹性意味着更难使用，需要花更多时间来了解每个参数的特性。与第一代相同，第二代的模块只能跟第二代的模块建立网络。

目前Digi还持续推出XBee模块的更新一代的产品，大体上还是不同代次的模块无法相互沟通，但第二代后的功能远远超过第一代的功能。大家在购买前要认清楚自己买到的模块是否正确。

每种XBee都有不同的天线种类可以选择，大家在购买前要想清楚自己的需求。如同前面提到的，实际应用还是建议选用u.FL和SMA两种，因为可以自己再搭配馈线增加距离，以符合系统外观的设计。

Digi公司专为XBee推出了一套测试与配置设置软件：XCTU（见图4-57）。新版的界面相当“清爽”，因此我们以新版界面来介绍。

图4-57 XCTU的起始界面

在安装过程中，会一并将当前有的固件版本都下载下来，需要花一点时间。安装完启动程序后可以看到界面分为左、右两个部分，左边是当前有的模块列表，右边则是细部配置设置和测试的界面，如图4-58所示。

图4-58 XCTU软件界面

按下左上方的按钮可以针对当前连接到的XBee（见图4-59）进行搜索，注意这里需要的是通过COM PORT，因此可能需要转接板。搜索到的设备会将其支持的协议和当前的角色以图案方式显示出来，另外也会有基本的模块信息。

图4-59 XBee模块信息

右边的部分则可以进行固件的更新，XBee有一个好处，即不同的WSN节点定义可以利用固件更新（见图4-60）来实现，不用担心有型号不同的问题。

图4-60 XBee固件更新列表

一代XBee的设置

一代XBee的功能比较简单，设置上的选择相对比较简洁。使用前要设置模块功能为XBEE 802.15.4，如图4-61所示。

图4-61 一代XBee的固件选择清单

若是要进行对等式（一对一）的通信，除了确定两个模块的ID（PAN ID）相同之外，只需要DH和DL填入对方的地址即可。地址在每个模块上也有标示，且是唯一的地址。

若要进行星形通信，则每个节点的目标地址要填入主控端。唯一不同的是在主控端的地址要设置成广播模式，CE（Coordinator Enalbe）要设置为启用。

广播地址设置

设置为主控端

二代XBee

想要拥有比较复杂的网络拓扑时，最好的选择就是二代XBee之后的版本，如图4-62所示。原因是固件针对WSN的网络拓扑进行了优化，每个节点的角色定义也更清楚，还支持API模式。通信协议上除了Digi自己的ZNet之外，也支持了标准的ZigBee。固件下载完毕后在菜单上也会标示出当前支持的协议是ZN或ZB。

图4-62 二代XBee的固件选择清单

对等式一对一通信的方式跟第一代一样，要设置对方的地址。不过，星形通信时在这里有比较大的区别，主控端要下载的固件为ZNet 2.5 Coordinator AT。终端节点要下载的固件为ZNet 2.5 Router/End Device AT。这里唯一要特别注意的是，终端节点下载完毕后，要将JV（Channel Verification）开启，确保整个网络的节点使用的是同一个频道，不然很有可能会发生找不到其他模块的问题。

这样设置完毕后，将所有设备重新加电，我们应该可以从主控端看到所有连上的节点（见图4-63）。

图4-63 当前网络上的所有节点（单击红色箭头所指的按钮进行搜索）

如果没有将所有模块找出，除了相关设置外，还要注意模块之间的距离或是否有遮蔽物阻挡。

接着我们将窗口改为通信传输，可以发送信息看看其他节点是否能收到。这里自己发送的字符串会以蓝色显示，接收到的字符串会以红色显示（见图4-64）。

图4-64 节点间的信息交换

这样的形式就是我们常见的串行通信，唯一的问题是数据的字符串必须自己含有节点信息，否则主控端无法识别数据是从哪个节点传输过来的。

如果是高级玩家，建议选择API的固件，所有设置与AT模式一样，分别下载完毕后，可以得到更多更详细的信息，包含模块地址、信号强度等，如图4-65所示。

图4-65 高级显示界面

API模式必须按照对应格式完成整个传输字符串，基本的架构如图4-66所示。

图4-66 API传输格式

在Frame Data里包含了Cmd ID和CmdData，CmdData会根据CmdID的不同而有所变化。大家可以在Digi的说明手册中找到更多详细的资料。例如：

这些命令包含了设置、状态确认、数据传输等，我们最常会看到的应该是ZigBee Receive Packet的数据分组（见图4-67），这里要注意0x90是XBee二代的数值。

图4-67 XBee Series 2的ZigBee Receive Packet数据分组

如果是一代的，就是0x80，以64-bit地址为寻址方式（见图4-68）。

图4-68 XBee的RX(Receive)Packet数据分组

大家也可以从这个XBee API模式中学习一个严谨的数据传送会包含哪些东西，例如起始码（Start Delimiter，有些可能会以2个或4个字节的长度来表示）、数据长度（去掉标头和最后校验码的长度）、数据内容和最后的校验码。“玩”多了各种通信后就可以发现这样的架构是一个标准的方式。在使用这些大厂推出的模块时，不仅仅只是赞叹好用，还要仔细挖掘其价值所在。

第3章后面介绍了Arduino的网络应用，让我们可以轻松将数据以浏览器的方式显示出来，基本上Wi-Fi也是同样的概念，不过这里会发现Wi-Fi模块的价格大多偏高，原因是Arduino本身所搭配的微处理器性能并不高，要同时处理逻辑控制和网络数据分组，负担太大。因此Arduino加上网络通信的部分都是用另一个通信芯片或是模块来进行处理。在市面上就可以看到搭配不同厂家的Wi-Fi扩展模块（见图4-69、图4-70）。

图4-69 Wi-Fi扩展板（核心：Microchip RN171）

图4-70 Wi-Fi扩展板（核心：WIZnet FI250）

Ethernet扩展板的规格可以从第3章找到，在网络通信上可以支持不同的协议。无线部分的种类更多，下面以RN171为例，介绍一些相关内容。

RN171规格

支持协议：DHCP client，DNS client，ARP，ICMP ping，FTP，TELNET，HTTP，UDP，TCP。

支持安全性：WEP-128，WPA-PSK（TKIP），WPA2-PSK（AES）。

这里最重要的就是安全性的部分，因为没有加密的保护，通信数据很容易被人截获。这在物联网的应用中是不能被接受的。谁也不希望自己家里的无线网络被别人随便登录后还可以存取重要的数据。

大部分网络模块与Arduino可以通过SPI或是串行端口进行数据交换，不同的接口会影响通信的速度，以RN171为例，SPI模式可以支持2Mbps，但是串行只能支持1Mbps。SPI模式大致与Ethernet扩展板类似，因此我们这里并不多做介绍。关于无线网络模块的整合，这里要介绍一个性价比非常高的模块：ESP-8266系列（见图4-71）。到2015上半年，就已经有超过10种不同类型的模块可以选择。

图4-71 ESP-8266系列产品（图片来源：www.esp8266.com）

这种模块只需要简单的几个AT-command就可以轻松操控，让你的系统拥有无线通信的能力，更妙的是它还支持3种工作模式：STA（Station）、AP和STA+AP。STA指的是一般的设备，比如笔记本电脑，需要连上一个AP才能和其他设备或因特网交换数据。AP则可以直接与设备建立连接，当连接建立完毕后两者就可以直接交换数据了。ESP模块虽然不起眼，但是直接支持多种模式，便于我们在不同的应用中使用，价格也更便宜，一个模块不到10美元。

图4-72 ESP-01引脚说明

这里我们使用ESP-01（见图4-72）来做功能的介绍。

ESP-01整体外观跟nRF24L01非常相近，不过是使用TX和RX进行通信，另外电源是3.3V的基准电压。由于模块的CHPD在使用时也必须输入高电平，因此唯一的缺点是不好与Arduino直接整合，因为Arduino只有一组3.3V的输出。另外，若是希望模块能够有比较长的使用寿命，则建议在RX端使用一个分压电路（EX: 220ohm+470ohm），确保加载到ESP模块的基准电压为3.3V。TX端可以省略是因为Arduino可以识别3.3V的电压为高电平。至于范例接线，为求简单就直接对接了（见图4-73）。

图4-73 ESP-01接线范例

这里我们使用一个计算机端软件SSCOM（见图4-74）来进行测试，网络上的com port测试软件很多，选择这个软件的原因是因为它可以列出多个AT命令便于我们测试。

图4-74 SSCOM软件界面

ESP-01还算是新出的模块，因此固件版本可能会因为购买的时间点而有所不同，建议使用之前先确认一下。支持的波特率可能是9600、38400或是115200等。笔者这里使用的模块是115200bps。模块启动时显示一些乱码是正常的，不用太担心。开启电源后等待约10秒就可以尝试输入“AT”，若回应“OK”（见图4-75）则表示串行端口设置正确，表示模块开机完成了。

图4-75 输入AT后模块回应OK

接着我们可以输入下面的命令查询当前的工作模式：

我们可以使用ESP模块建立一个AP搜索器，只需要一个命令就可以将当前周围的无线网络名称及信号强度搜索出来，当然这要在SAT模式下使用。

图4-76 AT+CWLAP所列出的AP信息（隐私问题，所以将MAC地址从图中隐去）

如果是STA模式，则需要选择想要加入的无线网络，之后才可以与同在一个网络的设备交换数据：

反过来，ESP模块是AP模式时，我们就可以设置自己的SSID名称和密码等项了。

无论是STA还是AP模式，选择SSID并连接后，还需要设置通信协议才能够传送数据，在AT+CWJAP后进行以下操作。

（1）设置连接数量：设置多个连接。

（2）设置欲通信的目标与端口号。

注：因为是多个连接才多了ID的设置，单个连接并不需要。

（3）准备发送。

到此完成一个信息的发送。有时因为连接状态不稳，发送前还是要确认连接是否还存在。或是采用比较保险的方式，每一次发送完信息后便关闭TCP连接，直到下一次数据传输时再重新建立一次连接。

若是ESP-01作为SERVER端，则要记得开启SERVER的服务：

ESP-8266系列为无线通信的模块，电力的消耗有时候难以掌握，Arduino板子的整体负载有限，若发现你的系统运行不太正常，网络通信时有时无，则建议额外提供3.3V的电源给无线模块使用，只要确认系统的GND都接在一起即可。

本章在最开始的时候就提到了无线通信的优势，加上物联网的兴起，让无线技术开始扎根于我们的日常生活中。蓝牙耳机、智能手环、智能跑鞋，再加上一台智能手机，串起一个个人传感器网络。这个网络还可以通过Wi-Fi或是移动通信将数据上传至云端，无论是个人记录还是和朋友分享，完全可以在不知不觉中完成。

在无线通信中，信号强度（Received Signal Strength Indicator, RSSI）和服务品质（Quality of Service, QoS）是一个被量化的数值，可以协助我们在整体无线网络架设时达到一个最好的状态。有些模块内建有支持此参数的计算，直接读取即可，例如XBee。让我们在虽然看不到数据传送的情况下，却可以掌握数据的稳定度。在实际系统部署时，这是一组相当重要的参考指标。

无线通信还是会被诟病安全性、稳定性不足的问题。功率越强，可以提供的覆盖范围越大，但同时也意味着需要思考如何持续供电。本章介绍了各样通信模块，希望能够结合到你的系统当中。每个技术都有优缺点，如何扩大优势、避免劣势是我们这些“玩家”需要一起努力的目标。


\section{5-1　事前准备}

本章以3种无线技术为引子，分别引入不同的应用到家庭自动化的开发中，通过前面学习的传感与控制方式，实现一个完整的解决方案。

在家庭自动化中，能够感测温度和照度，就能适当启动家电或是照明来维持居住环境的质量。更高级点，还可以针对湿度、有害气体、PM2.5等进行长期居住环境的监测，这对于家中的小孩或大人都是很有帮助的，因为若能得到居住环境的长时间数据，就可以了解可能造成身体不舒服的原因，说不定还可以因此避免过敏源。此外，家庭安全也是很重要的一环，门窗的监控与门禁的管理都是现在技术可以很轻易实现的。而Arduino的能力可以轻松担当起整个家庭监控的中央控制器，再搭配无线通信的技术，例如ZigBee和蓝牙等，就可以和家中家电成员直接进行数据的传送与命令的下达了。

大家在本章进行实践时，可以自己搭配选择的模块和通信接口，或是手边已经有的模块也可以直接拿来使用。这里为了配线简单，使用Appsduino公司所推出的套件，其扩展板上有内建的温度传感器、光敏电阻（照度）和蓝牙接口等，方便我们直接使用或是扩展。另外，通信部分采用ZigBee。Appsduino所使用的ZigBee模块是TI（德州仪器）公司所推出的无线通信芯片，也是市面上常见的通信芯片之一，称为iArduino-ZB。在此处使用并介绍这种芯片，主要是想让大家可以从书中多了解一些模块的应用。

通过RFID Tag来进行身份识别，当刷卡开门时，可将信息传至手机／平板电脑，并以语音方式将名字自动说出，并根据光线明暗自动开灯，也可用手机控制／查看室内所有电器的开关、实时显示不同空间内的温湿度、光线照度、一氧化碳（CO）浓度、窗户开关状态。

传感终端与RFID终端系统组合列表如下：

下面分别介绍一下各个模块。

这里使用了Appsduino所推出的UNO R3修改版（见图5-1），主要新增了两个功能。

Buzzer：由Jumper连接至D8，可以产生声音旋律（请参考Arduino官方范例）及警示告知，出厂时Jumper预设为短路，若想使用D8进行其他控制，则将Jumper开路或拔除。

电池电量的检测：当Jumper短路时，会将Vin的1/2分压连接至A0，使用Analog IO A0监测电池的电压，所测量的电压值为1/2 Vin，即真正的电压值为A0读取的数值÷1024×5V×2，因此最高可测量10V的电压（1024÷1024×5V×2）。

图5-1 Appsduino的Arduino UNO R3

Appsduino所推出的Shield V2.1扩展板（见图5-2）

图5-2 Appsduino扩展板

Appsduino Shield V2.1扩展板增加了一些常用元件，利用杜邦线连接至适当的IO Pins，便可轻松学习许多实验，详述如下。

（1）蓝牙接口：将蓝牙模块6 Pin排针插入接口（元件面向内侧），即可与手机或平板电脑通信，进而连上因特网实现网络相关应用。

（2）绿、红、蓝LED：绿色（Green）LED已连接至D13，可直接使用。红、蓝LED可通过J17的两个排针用杜邦线连接至适当的Pin引脚。

（3）数字温度计（DS18B20）：将J19的Vdd引脚连接至5V，DQ连接至适当的Digital I/O引脚，即可测量环境的温度（-559℃～+125℃）。

（4）光敏电阻（CDS）：当光敏电阻受光时，电阻值变小，若用手指遮挡光敏电阻（暗），则电阻值变大，可利用此特性来监测环境受光的变化，将J10的CDS引脚连接至适当的Analog I/O引脚（A0～A5），即可测量环境光线的变化。

（5）可变电阻VR（10KΩ）：内建10KΩ的可变电阻，其三支脚分别对应VR/VC/VL引脚，可利用这些引脚旋转旋钮以获得所需的阻值。

（6）电源滑动开关：黑色开关（向右on／向左off），可打开或关闭从外部电源输入接口送至UNO控制板的电源（VIN）。

（7）电源输入引脚：将红黑电源线接头插入此电源母座（红色为正极/+，黑色为负极/-），这里提供的是排针方式的电源输入，不同于Arduino主板上的电源接头，大多使用变压器。

（8）测试按键（Key）：若将J14 Jumper B/C短路，则Key 1(S3)按键自动连接至A1 Pin，无须接线，可将A1设置为Digital I/O或使用Analog I/O (A/D)来检测Key 1按键的状态。Key 2(S4)按键则需使用杜邦线将J14 Jumper A连接至适当的数字或模拟引脚。

（9）I2C LCD插槽：若有I2C LCD模块，则可将所附的4根杜邦线一端接到I2C控制板，另一端直接插入此插槽。

（10）5V/GND引脚：扩展板底部增加5组5V与5组GND引脚，以便5V传感器使用。

AppsBee Arduino扩展板（ZigBee Shield）

AppsBee扩展板是一个专为Arduino量身打造的ZigBee扩展板（见图5-3），可将其直接插入Arduino的插槽内，无须任何转接板。此扩展板是基于TI的2.4GHz射频收发芯片CC2530及大功率低噪声射频前端芯片CC2591（ZAHP only）而开发的串行端口传输通信模块，将以往复杂的ZigBee Protocol Stack开发过程简化为UART与简单的I/O控制，让用户能够充分掌控网络性能，实现低功耗、远距离、大规模ZigBee无线传感器组网的能力。

图5-3 ZigBee CO/RO扩展板

注：AppsBee扩展板的详细用法与设置可参考在线下载文件“AppsBee扩展板使用手册”。

由于此AppsBee扩展板使用串行端口（TX/RX）与Arduino单片机通信，有两个Jumper可用于选择是使用Arduino的硬件UART D0/D1引脚（1200～115，200bps）还是软件串行端口的D5/D4引脚（1200～57600bps），而AppsBee扩展板使用的Arduino I/O控制引脚如下。

■ D9：Reset Pin。

■ 当D9 = LOW：Reset（重置）AppsBee模块。

■ D6：模式选择／Mode Select。

■ 0：BroadCast（广播）mode。

■ 1：Unicast/Setting（点对点／设置）mode。

■ D0/D5：TX（AppsBee的数据传送）连接UNO的数据接收D0（HW）或D5（Software Serial）。

■ D1/D4：RX（AppsBee的数据接收）连接UNO的数据传送D1（HW）或D4（Software Serial）

AppsBee模块Baud Rate：默认为9600bps。

使用前请先设置RO的地址，其有效地址：1，2，…，2047（11 bits）。其设置方式可参考范例：AppsBee\_RO\_ID\_Setting.ino。

扩展板上有连接指示灯LED，当正在搜索连接时LED闪烁，已连接时LED恒亮。

I2C温湿度传感模块（HTU21D）

HTU21D超小体积的I2C温湿度数字输出模块，是基于法国Humirel公司高性能的温湿度传感器元件HTU21D设计而成的。HTU21D温湿度传感器的尺寸仅为长宽3×3mm（L×W），高度1.1mm，提供了标准的I2C数字输出格式，工作电压范围广，功耗极低，并且具有很好的温湿度精度范围。因此HTU21D温湿度数字输出模块是具有良好的质量、响应速度快、抗干扰能力强且性能优良的产品。

HTU21D同时可以和瑞士的SHT20、SHT21实现完全兼容，即硬件引脚上可以实现Pin to Pin完全兼容，无须修改电路板。软件程序方面也和瑞士的SHT20、SHT21相同，可以实现兼容替换，无须做任何修改。

图5-4 HTU21D温湿度模块

传感器重要参数如下。

供电电压：1.5V～3.6V

湿度测量范围：0～100\%RH

温度测量范围：-40℃～+125℃

温度精度范围（5℃～60℃）:±0.3℃

最大消耗功率：2.7Uw

通信方式：I2C

湿度精度范围（10\%RH to 95\%RH）：±2\%RH

湿度迟滞：±1\%RH

测量时间：50ms

年漂移量：-0.5\%RH/year

响应时间：5s

HTU21D模块的I2C的地址（SLAVE ADDRESS）为0x40。

HTU21D模块每个I2C地址都相同，且为0x40。因此在同一条总线上只能连接一个HTU21D传感器，传感器只有在收到起始信号且与本身I2C地址相同时才会响应。

程序的部分相当简单，和前面章节的DHT模块类似，只需要设置相关的结构变量，就可以使用不同的API直接读取温湿度的数据。

声音传感模块（见图5-5）

此声音传感器可检测声音大小，内含放大电路（LM386）并可调整增益（Gain），当数值变化很小时可用螺丝刀调整增益／放大倍数，因为模块输出为模拟信号，所以可接至Arduino模拟引脚（A0～A5），使用analogRead指令读取音量大小，并送至LCD Display或计算机的串行端口监视器（Serial Monitor）显示。

图5-5 声音传感模块

特性

■ 电压：+5V。

■ 模拟电压信号输出，信号幅度为VCC/2。

■ 内置放大电路，增益可调。

■ 可通过A/D转换获得声音强度的电压信号。

CO传感模块（见图5-6）

Q-7气体传感器所使用的气敏材料是在空气中电导率较低的二氧化锡（SnO2）。采用高低温循环检测方式低温（1.5V加热）检测一氧化碳，传感器的电导率随空气中一氧化碳气体浓度增加而增大，高温（5.0V加热）清洗低温时吸附的杂散气体。使用简单的电路即可将电导率的变化转换为与该气体浓度相对应的输出信号。

图5-6 气体传感模块

特性

■ 输入电压：DC 5V。

■ 功耗（电流）：～150mA。

■ DO输出：0和1（TTL Level）。

■ AO输出：0.1-0.3V（相对无污染），最高浓度电压在4V左右。

传感器通电后，需要预热20s左右，测量的数据才稳定，传感器发热属于正常现象，因为内部有电热丝。

板子上方的是PWR-LED红色电源指示灯，下方有DO-LED，当CO太浓就会亮起，DO输出0V。反之，CO浓度较淡时，则DO-LED熄灭，DO输出5V。

AO（Analog Output）：将当前CO浓度的大小以电压高低的方式输出，可用Analog Pin来判断浓度的高低（数值越高表示浓度越高）。

板上的可变电阻用来设置D0的阈值，测试结果若是逆时针转到底，阈值设置得很大（1023）→不灵敏。若顺时针转到底，阈值设置得很小（0）→灵敏。

RFID模块（见图5-7）

RFID-RC522模块采用NXP MF RC522芯片设计读卡电路，使用方便，适用于设备开发、读卡器开发等应用的用户，以及需要进行射频卡终端设计／生产的用户。模块采用的电压为3.3V，通过SPI接口，可以直接与任何具备SPI接口的CPU主板连接并通信。

图5-7 RFID模块

MF RC522是应用于13.56MHz非接触式通信中高集成的读写卡芯片，是NXP公司推出的一款低电压、体积小的非接触式读写卡芯片，是智能仪表和可携式手持设备研发的理想选择。MF RC522利用了先进的调制和解调概念，集成了在13.56MHz下所有类型的被动非接触式通信方式和协议，支持14443A兼容应答器信号。数字部分处理ISO14443A帧（Frame）和错误检测。此外，还支持快速CRYPTO1加密算法。MFRC522支持MIFARE系列更高速的非接触式通信，双向数据传输速率高达424kbps。作为13.56MHz高集成度读写卡系列芯片家族的成员，MF RC522与MF RC500和MF RC530有不少相似之处，同时也具备许多特点和差异。它与主机间的通信采用SPI模式，有利于减少连接、缩小PCB板体积、降低成本。

读写器（Reader）向RFID Tag（M1卡）发一组固定频率的电磁波，卡片内有一个LC串联谐振电路，其频率与读写器发射的频率相同，在电磁波的激励下，LC谐振电路产生共振，从而使电容内有了电荷，在这个电容的另一端，接有一个单向导通的二极管（Diode），将电容内的电荷送到另一个电容内存储，当所积累的电荷达到一定电压（～2V）时，此电容可作为MF1S50 IC控制单元的电源，并根据相应区的有效存取位（access bits）来控制将卡内数据发射出去或读取读写器的数据，如图5-8所示。

图5-8 RFID工作原理

模块参数简介

工作电流：13～26mA／直流3.3V

空闲电流：10～13mA／直流3.3V

休眠电流：小于80uA

峰值电流：小于30mA

工作频率：13.56MHz

支持的卡类型：mifare1 S50、mifare1 S70、mifare UltraLight、mifare Pro、mifare Desfire

产品物理特性：尺寸为40mm×60mm

环境工作温度：-20℃～80℃

环境存储温度：-40℃～85℃

环境相对湿度：相对湿度5\%～95\%

数据传输速率：最大10Mbps

一张mifare的卡片其实可以存储相当多的数据，有1024×8 bit，里面分成16个区段，每个区段有4个区块，而且都可以有独自的密码（Key）保护（见图5-9）。

图5-9 mifare卡片的存储容量

第一个区段中的第一个区块是制造商信息（Manufacturer Block），包含了卡片的序号与制造商信息，如图5-10所示。

图5-10 RFID内部的卡片信息

如果卡片是刚出厂的，那么所有区段的默认密码（6B）都为：0xFF 0xFF 0xFF 0xFF 0xFF 0xFF。

先用一个很简单的范例来看一下RFID的读取。我们先做序号读取的部分，因为序号不会重复，所以我们可以按照序号来判断持有卡片的人是否正确。

首先会用到相关的函数库，因此先引用RFID.h。因为使用的RFID模块是通过SPI和Arduino沟通，所以我们只需要额外设置SS和RESET的引脚即可。

在循环中，程序会持续扫描是否读取到卡片rfid.isCard()，如果有，就进入序号读取的部分rfid.readCardSerial()。这部分范例程序会先做一个判断，确认本次读取到的序号和前一次是否相同，如果确认是不同的卡片，就显示出序号的十进制数和十六进制数；如果相同，就只显示出一个点来表示，如图5-11所示。

图5-11 读取到的结果

程序的最后有一个rfid.halt()，是要让卡片进入休眠状态。

至于数据区块的存取流程（见图5-12），必须有机制进行处理，以避免多卡同时存取和确保数据的安全性。

图5-12 RFID的工作流程图

流程大致分为：

请求应答（Answer to Request）

RFID Tag的通信协议和通信波特率是定义好的，当有卡片进入读写器的操作范围时，读写器会以特定的协议与它通信，从而确定该卡是否为兼容的卡，即验证卡片的类型。而卡片也会按请求代码发送回应ATQA信号。

防冲突循环（Anticollision Loop）

当有多张卡进入读写器操作范围时，防冲突机制会从其中选择一张进行操作，未选中的则处于准备模式等待下一次选卡，该过程会返回被选卡的序号。

选择卡片（Select Tag）

读写器使用选择卡命令，选择其中一张卡的序号进行确认和内存的相关操作，此时卡片回传ATS码（Answer To Select =08h），读写器通过ATS可以确定被选中卡的类型，并同时返回卡的容量代码。

三次互相授权认证机制（3 Pass Authentication）

选定要处理的卡片之后，读写器就会确定要存取的区块号码（Block\#），并对该区块密码进行密码校验，在三次相互认证之后就可以通过加密进行通信。

区块（Block）的操作方式

在执行任何区块操作之前，卡必须先要被选择并经过码验证机制。

内存区块（Block）有以下3种形态。

（1）读、写区块：一般的数据保存，可以进行读、写操作。

（2）数值区块：用作数据值（4B），可以进行加值、减值、读值操作，例如电子钱包的应用。

（3）控制区块：每个扇区的区块3为控制区块，包括密码A（6字节）、访问控制（4字节）、密码B（6字节）。

每个扇区（Sector）的密码和访问控制都是独立的，可以根据实际需要设置各自的密码及访问控制。访问控制为4个字节，共32位，区段中的每个区块（包括数据区块和控制区块）的存取条件是由密码和访问控制共同决定的，在访问控制中每个区块都有对应的3个控制位，其结构与对应的操作权限如下所示。

数据区块（0、1、2）的访问控制如下：

注：KeyA|B表示密码A或密码B，Never表示任何条件下都不能实现。

从中可以看出：

C1C2C3=000（出厂默认值）时最宽松，验证密码A或密码B后可以进行任何操作。

C1C2C3=111无论验证哪个密码都不能进行任何操作，相当于把对应的区块冻结了。

C1C2C3=010和C1C2C3=101都是只读，如果对应的数据区块写入的是只能读取（read only）的信息，可设为这两种模式。

C1C2C3=001时只能读和减值。电子钱包一般设为这种模式，比如公交车与地铁用的公交卡或一卡通，用户只能查询或扣钱，不能私下加值，加值的时候需要通过储值设备，先改变控制位使卡片可以充值，充完值后会再改回来。

二路5V继电器模块（见图5-13）

可用微控制器的5V I/O引脚去控制AC 110/240V的电器设备，此模块具有2CH输出控制能力，采用光电隔离方式，抗干扰能力强，且备有二极管保护，让继电器不会伤害到Arduino的引脚。

图5-13 二路5V继电器模块

模块的上方有直接的图示方便我们确认继电器的NO和NC引脚，以此模块为例，左边引脚为NC，右边引脚为NO，中间则是COM点。当我们输入高电平给某一个继电器时，会让右边引脚和COM点短路。

整个应用设计分成两个系统，一个是ZigBee的主控端（Coordinator）和ZigBee的终端（Router），系统组成如下：

我们可以将整个系统细分为四大部分：主控端（CO）、传感端（RO）、RFID管理端（RO）以及手持移动设备APP监控界面，如图5-14所示。传感端（RO）配置有温湿度、照度、CO浓度、声音、开窗等传感器，以及可从远程控制灯光的开关。其上的传感器和开关的最新状况都会实时通过ZigBee无线模块送回到主控端（CO），另一个RFID管理端（RO）则配置RFID Reader，作为门禁进出的管理，并将进出信息传给主机。主控端获得信息后，除了将其显示在LCD屏幕外，信息还会通过蓝牙（Bluetooth）无线模块转送给Android手持设备内建的APP监测程序，因此用户可在无线的场景下通过手持设备查看当前实时的温湿度、光线照度、声音、一氧化碳（CO）浓度，并从远程控制开关启动（或关闭），也可设置警戒值，若超过则可发送警告信息。

图5-14 系统示意图

5-2-1 系统组装

第一步我们先组装传感终端（RO），把需要的传感器固定在亚克力板上，连同Arduino一起以六角脚柱部署完毕（见图5-15）。

图5-15 各传感器固定示意图

因为Arduino控制板的部分有通信模块和扩展模块，所以请按下面的顺序堆叠。

■ 最上层：Appsduino扩展实验板＋面包板。

■ 中间层：AppsBee（RO）扩展板。

■ 最下层：Appsduino UNO控制板。

另外，还在为每个传感器进行配线（见图5-16），让Arduino与其通信。

O端的温湿度传感器

继电器模块

照度传感器（光敏电阻）

一氧化碳（CO）传感器

声音传感器

磁簧开关

LCD显示模块

第二步则是RFID（见图5-17）。

Arduino控制板的部分也是按照相同顺序堆叠的。

■ 最上层：Appsduino扩展实验板＋面包板。

■ 中间层：AppsBee（RO）扩展板。

■ 最下层：Appsduino UNO控制板。

RFID读写模块

LCD显示模块

图5-16 传感终端实际配置

图5-17 RFID终端实际配置

最后我们要来完成主控端（CO）。

Arduino控制板部分唯一的不同是ZigBee的模块要选择主控端（CO）的配置，而不是之前的传感端（RO）。

■ 最上层：Appsduino扩展实验板＋面包板。

■ 中间层：AppsBee（CO）扩展板。

■ 最下层：Appsduino UNO控制板。

蓝牙模块

若使用Appsduino Shield，则上面有一个蓝牙接口的杜邦接头，如图5-18所示。

图5-18 蓝牙模块的安装

LCD显示模块

图5-19 主控端实际配置

主控端的实际配置如图5-19所示。

5-2-2 系统启动

整个系统要能够开始执行，除了编写程序外，接口设备的设置也是很重要的。首先我们来看看蓝牙的部分（见图5-20）。

首先接上主控端CO模块的电源，同时会看到蓝牙模块上的红色小灯闪烁，代表等待配对连接。接着单击Android设备的“设置→蓝牙→开启蓝牙功能→选择蓝牙→搜索设备”来完成蓝牙设置。不同Android版本操作界面可能不太相同，但是都大同小异，请自行参考Android设备的原厂说明书完成设置。下面以Android 4.3版本的显示界面为例进行说明。单击“搜索”按钮，过一会应该可以看到Android系统找到的Appsduino（见图5-21）蓝牙设备，请选择Appsduino。（这里的名称Appsduino是预先设置的名称，读者也可以自行修改，以免和他别人重复。）

图5-20 Android手机启动蓝牙的用户界面

图5-21 搜索到自己的蓝牙模块

接着出现配对要求输入密码的界面，请输入密码0000，再单击“确定”按钮（见图5-22），就会看到配对成功，蓝牙模块已经加入到Andorid的已配对设备列表之中（见图5-23）。

图5-22 输入配对密码

图5-23 蓝牙模块配对成功

可使用如下的“Config\_BT\_Name.ino”程序更改蓝牙ID，以便于识别。只要更改AT+NAME后面的名称即可：

（这里设置的范例名称为Appsduino）

图5-24 从Google Play下载IoTWSN互动软件APP

手机端的应用程序请从Google Play下载“IoTWSN互动软件”后安装（见图5-24），或从本书提供的范例程序文件夹中找到Apps\_IoTWSN.apk软件，并将其复制到手机存储器中，然后在手机中执行安装即可。之后执行该APP并单击“蓝牙设备”、选择想要连接的蓝牙设备。回到程序主界面，可以看到选定的Appsduino蓝牙模块的名称，再单击“连接”按钮即可完成连接。

5-2-3 终端程序

当所有硬件连接完毕后，就可以将程序载入了。第一个部分我们先完成终端节点（RO）的程序。因为整个系统的通信是以ZigBee为接口，所以使用前必须设置RO的ZigBee节点地址，这里使用AppsBee\_RO\_ID\_Setting范例来完成。

AppsBee并非直接使用Arduino原来的串行端口（D0，D1），因此我们需要SoftwareSerial.h来产生另一组通信端口让AppsBee来使用，这里D5为TX、D4为RX。同时我们也要让模块知道自己的角色定义，这里是RO。

接着只需要在SettingMode中改变第二个参数的值即可，这里设置为除了1以外的参数。若是小组一起实验，则大家可以讨论一个规则让每个终端都有自己的ID号码。

RO端的整个范例名称为IoT\_WSN\_RO，因为整个程序集结了许多程序，所以我们只采集精华部分，就不在这里细谈了。若遇到模块间通信或是数据正确性的问题，建议先以单个模块的范例逐个进行测试，以分割的方式找出问题所在。

整个系统包含了许多传感器，从实际应用来看，每个传感器都有自己的权重。这里的权重指的是数据更新的速率快慢，以室温来说，正常环境中不太可能在一秒内发生大幅的变化，因此可以每1秒读取甚至每10秒再进行测量与更新温度即可。不过声音传感的部分常常发生在短时内，因此我们要以较快的速度进行声音的监控。范例中使用了Time.h这个函数库来协助我们设置不同的时间权重，大家也可以按照自己的想法与实验结果找出最适合的系统安排。

前面的章节提到在物联网系统设计中，电源在终端节点中是一个关键的因素，所以范例中我们也加入了系统电源的监控与警示。因为锂电池都有一段可使用范围，所以我们先设置系统可接受的电压区间：

这里battWarningLevel的单位是百分比，也就是当电池仅存容量低于多少百分比后要发出警报，范例以蜂鸣器作为提醒工具。

当然作为家庭自动化系统时，除了监视整个环境参数与控制家电设备外，异常情况的反应才是我们最重要的事情，比如磁簧开关负责检测的是门窗被意外打开、有毒气体浓度是否超过警戒值。这些参数都可以事先定义极限数值，也许是上限或下限，也许是开或关。

通过设计为整个终端节点分别设置任务后，可以从循环中看到只需要处理两件事情：按照时间权重分别进行任务、确认ZigBee端是否有数据需要处理。

程序运行后，主控端每秒都会接收到RO更新的信息。若有超过警戒值的部分，则会通过GPRS向管理者发送。发送机制在MonitorSensorData()的AZbee.SendString（GPRS\_ID,warningMsg）中。

另外一块是RFID的节点。如同RO传感端一样，先设置ZigBee RO（路由）不同的地址。其有效地址为1，2，…，2047（11 bits）。打开AppsBee RO地址设置程序AppsBee\_RO\_ID\_Setting，更改要设置的地址，并将程序上传，即可设置新的RO地址。

接着选择RO端RFID程序IoT\_RFID\_RO.ino，将程序写入Arduino控制板内。写入成功后系统会自动重新启动，接着LCD上就会显示“Wait”或检测到的RFID Tag名称。

比较特别的是，我们必须先定义好手边有的RFID标签，这里采用序号来识别。另外，针对每个序号我们给它对应一个用户来显示。在实际操作中要先确保程序内的序号与手边RFID Tag相同。

在实际的应用中，这部分会有一个后台的数据库负责管理。这里我们为了方便大家实现，就以手动编辑的方式生成人员对应表格。

因为没有传感器的加入，所以其他部分的程序只需要专注在RFID标签的读取上。从程序中可以看到，我们每50毫秒就进行一次RFID标签的搜索。

最后是重头戏，即主控端的程序。不同于RO端需先设置不同的地址，CO/主机端的地址固定为0。接着打开CO端程序IoT\_WSN\_CO.ino，将程序写入Arduino控制板内。写入成功后系统会自动重新启动，接着LCD上就会显示从RO端（传感与RFID）传来的温湿度值及其他的数据（顺序为温度、湿度、照度、CO、声音、磁簧、两个灯的开（1）与关（0））。

程序内容相对于RO端来说比较简单，就是持续接收数据并进行显示，还有通过蓝牙端与手机APP进行通信。

除了可以使用RFID作为门禁进出管理之外，也可以通过NFC Tag来进行身份识别。当刷卡开门时，一样可以将信息传至手机／平板电脑，并以语音方式自动说出名字。

将此NFC无线传感应用模块设置ID后，即可自动加入物联网无线传感应用开发系统，让此系统也具备NFC读写功能，并据此开发与扩展许多NFC相对应的功能。当模块读取到NFC Tag的信息时，都会实时通过ZigBee无线模块将信息送到主控端（CO），主控端获得信息后，除了将其显示在LCD屏幕外，还可以通过蓝牙（Bluetooth）无线模块转送给Android手持设备内建的APP监控程序。

NFC终端系统组合列表如下。

这里我们使用了不同的无线识别技术：NFC。下面我们针对这个模块做一个简单的介绍。

NFC模块

NFC读写开发模块基于PN532芯片，用于13.56MHz的近场通信。该模块配备了板载天线，因此没有外部天线的线圈。它支持SPI/IIC/UART通信接口与MCU，便于进行双向通信。随着NFC Library支持Arduino，使得要开发具有NFC功能的产品变得更加容易。

PN532（见图5-25）是NXP针对NFC推出的一个高度集成的非接触读写芯片，内含80C51微控制器，提供在13.56MHz下的各种主动／被动式非接触通信方法和协议。

图5-25 PN532 NFC读取模块

模块参数简介

电源（V）：3.3V～5.5V

最大电源电流：150mA

工作电流（待机模式）：100mA

工作电流（写入模式）：120mA

工作电流（读取模式）：120mA

工作频率：13.56MHz

PN532传输支持以下6种不同的工作模式。

读写器模式，支持ISO/IEC 14443A/MIFARE机制。

读写器模式，支持FeliCa机制。

读写器模式，支持ISO/IEC 14443B机制。

卡操作模式，支持ISO 14443A/MIFARE机制。

卡操作模式，FeliCa机制。

ISO/IEC18092，ECM340点对点。

这里再加一个以NFC为通信接口的终端节点系统，其组成如下。

整个家庭自动化物联网系统新增一个节点（见图5-26）。

图5-26 系统示意图

5-3-1 系统组装

基本上就是新增一个NFC模块（见图5-27），虽然有多种通信接口可以使用，但是这里我们选择SPI模式。

NFC模块

图5-27 NFC终端硬件配置

5-3-2 系统启动

因为是新增的节点，所以要先进行ZigBee网络节点的设置。打开范例设置程序AppsBee\_RO\_ID\_Setting，更改要设置的地址，并将程序上传即可设置新的RO地址。

设置RO地址后再打开RO端程序IoT\_NFC\_RO.ino，将程序上传到Arduino控制板内，写入成功后系统会自动重新启动，接着LCD上就会显示“Wait”或检测到的NFC Tag名称（见图5-28）。

图5-28 NFC启动后的待命状态

硬件都配置完成后，就可以将范例程序IoT\_NFC\_RO.ino下载到系统上。与RFID的差异主要是函数库的使用以及参数设置。定义NFC的结构变量也只需设置chip select引脚即可。如果NFC没有顺利通信，那么除了SPI的引脚外，这里的设置也要注意一下。

除了检测系统电源外，主循环部分还要读取NFC标签的数据并回传到主控端。

前面我们已经完成了传感终端（RO）的建立，负责检测室内的温湿度、光线照度、一氧化碳（CO）浓度、窗户开关状态以及可控制的灯光开关，除了可通过手机APP控制室内的灯光开关、实时显示环境内的各项参数外，有时为了安全起见，也会监控一氧化碳浓度或门窗状态，当有异常发生时能实时以短信（SMS）／其他消息通知相关的人员，这时此GPRS/SMS监控与信息模块即可扮演关键角色。

将此GPRS监控与信息模块设置ID后，即可自动加入物联网无线传感应用开发系统，让此系统具备安全监控与异常时发信息告知的功能，用户可设置警示基准值，当超过此设置值时，即会通知预先指定的人员，也可在远方通过GPRS控制传感器端的灯光或电器，这样即使此时无法连上因特网也无妨。从系统的架构来看，这样的配置也可以提供另外一条信息传送的通道，发挥ZigBee的弹性优势，让用户不只是可以通过蓝牙获取信息，还可以利用GPRS来了解情况。

GPRS终端系统组合列表：

最后一个无线技术是移动通信中的GPRS，它是第2.5代（2.5G）移动通信技术。下面我们使用SIM900的GPRS模块来进行远距通信的扩展。

Arduino四频GPRS Shield／扩展板（SIM900）

这个四频（850/900/1800/1900Mhz）GPRS扩展板内建一个SIM900 GPRS模块，并能直接插入Arduino主板的接口，无须任何的接线或转接板，具有即插即用的便利性。该GPRS扩展板可让你使用现有的GSM网络传送SMS、MMS、GPRS Packet以及实现语音通话的目的，所有这些功能都能通过UART Tx/Rx传送AT commands（GSM 07.07,07.05与SIMCOM强化的AT commands）来完成。

注：完整的AT Commands Set，请查阅本书提供下载的参考电子文件。

SIM900算是较常使用在扩展板上的通信模块，许多公司都推出了基于SIM900的扩展板，当然不能忘记Arduino.cc也有自己的官方模块（见图5-29），使用的核心是QUECTEL M10。

图5-29 Arduino.cc的GSM模块

来看一下SIM900的功能：

Quad-Band 850/900/1800/1900 MHz——全球通用（通过GSM网络）

GPRS multi-slot class 10/8

GPRS mobile station class B

Compliant to GSM phase 2/2+

Class 4 (2 W @ 850/900 MHz)

Class 1 (1 W @ 1800/1900MHz)

Control via AT commands—Standard Commands: GSM 07.07 \& 07.05 | Enhanced Commands: SIMCOM AT Commands.

Short Message Service—可传送短（SMS）

Embedded TCP/UDP stack—可上传数据至server

RTC supported

整个GPRS终端的组成：

整个家庭自动化物联网系统又新增一个节点，如图5-30所示。

图5-30 系统示意图

5-4-1 系统组装

这里的系统只有扩展板的连接，不过还是要注意几件事情。首先建议还是按照以下顺序安装扩展板，以便于后续若要接其他模块时还可以使用面包板的部分。

■ 最上层：Appsduino扩展实验板＋面包板

■ 中上层：GPRS扩展板

■ 中间层：AppsBee（RO）扩展板

■ 最下层：Appsduino UNO控制板

另外，因为GPRS也是使用串行通信，一般的GPRS模块都会有一组JUMPER，用来设置要使用原生的Arduino串行端口还是仿真的串行端口（见图5-31、图5-32）。大家不管使用哪家的模块都需要在使用前确认。

图5-31 模块和Arduino的接口设置

图5-32 模块和Arduino的接口配置示意图（图片来源：Seeeduino）

因此，如果这时候使用Appsduino UNO，记得把蜂鸣器的JUMPER先移除，避免在通信时造成蜂鸣器发出蜂鸣。GPRS终端完成的硬件配置如图5-33所示。

图5-33 GPRS终端完成的硬件配置

5-4-2 系统启动

设置完与Arduino的接口后，还要确认SIM卡和天线是否也已经安装上去。GPRS模块有个比较特别的地方，并不是系统电源开启后模块也会跟着开启，而是必须再按下另一个开关约2秒后才会启动模块，大家可以观察LED来确认模块的情况。

模块有三个LED灯号：Power、Status和Net。

接着我们就可以用范例程序来测试各种功能了，请找到范例GPRS\_SMS\_Dial\_Example.ino，可以进行短信的发送与语音拨号。

程序会用到仿真的串行通信，硬件是D7和D8两只引脚，范例需要引用SoftwareSertial.h来启动这个功能。另外还要设置电话号码，这里大家按照想要传送的对象来设置，这里范例包含了国家码或地区码（中国：+86），加上后去掉号码的第一个0。

在主程序中只有串行通信的处理，在程序启动后，可以输入t或是d来选择发送短信或是拨打电话。另外，所有在仿真通信端口的数据也会传送到计算机来显示。

再从发送短信的部分详细看一下GPRS模块是怎么工作的。所有GPRS模块的功能都是从Arduino发送AT command来启动。以发送短信为例，需要以下步骤。

（1）设置短信为文本模式：AT+CMGF=1。

（2）设置要发送的对象：AT+CMGS="+86123456789"。

（3）若前面设置正确，SIM900模块则会开始等待要传送的字符串。这时就可以输入想要传送的字符串。

（4）确定输入完成后，需要输入Ctrl+Z进行传送，Ctrl+Z的ASCII码为26。

以上四个步骤就可以完成一个短信的传送。我们将其整体完善到程序中：

对了！这是一个新的终端节点，别忘了还要设置ZigBee的ID号码来加入整个网络！

整个完整的范例程序请参考IoT\_GPRS\_RO.ino。将程序上传到Arduino控制板内，上传成功后系统会自动重新启动，接着LCD上就会显示传感器的数值，如图5-34所示。

图5-34 利用短信进行控制和警报显示

到此我们完成了整个家庭自动化的物联网系统，不仅有传感器的实时检测和异常警报，还有门禁管理，最后再加上移动通信的远距连接。同样的系统架构我们可以扩大运用于户外，例如农业养殖、灾害预防。也可以缩小到设备监控与预防检测。只要调整终端传感器的种类，或是改变整个系统的通信架构，便可以适用于不同的场景，当然还是有很多小细节需要处理的，比如说户外的防水、防高温等系统的耐候性、线材的固定与电力的来源，甚至是整个系统是否有后援或是重启的机制，这些都是我们在实际应用中应该考虑的因素。

完成这样的系统，大家可能会发现一件事情：模块化的重要性。无论是传感器的连接还是通信的整合，在实际的系统应用中都会变得复杂且相互影响。这也就是为什么我们看到某些厂商会推出一系列的模块（见图5-35、图5-36）都有相同的接口，Arduino的扩展板设计理念也是一样的，只是往上堆叠还是有极限的。

图5-35 Seeedstudio所推出的Grove系列（http://www.seeedstudio.com/）

图5-36 Fayalab所推出的leaf系列（http://www.fayalab.com/）

在实际应用中，工业界的RS-485、车内的电子设备采用的CANBUS等也都是这样的道理，借助同一通信总线接口的整合，模块的新增或是移除都可以非常快速地满足不同的需求。


\section{6-1　通往云计算的道路}

物联网的最后一千米，数据的整合与应用，才是发挥物联网价值的所在。为山九仞岂能功亏一篑。

在物联网中，在终端节点的系统设计和网络规划时要考虑让信息不受限制地流动在整个网络中，为其他节点提供运行所必要的信息。在物联网概念中，节点的数量是以千万计的，因此如何有效地管理所有节点并且让网络性能得到优化，分层的概念一定要建立，这里最重要的角色非网关（Gateway）莫属了。网关一词非常贴近物联网中使用的场景。整个网络会按照某种特性分成不同的区域，每个区域会有一个网关作为与其他子网的通信桥梁，或是守卫。这个网关的功能也许是通信接口的转换，例如蓝牙转成Wi-Fi无线网络，或是ZigBee转成移动通信，也有可能是有线接口的转换。同时也需要进行数据的过滤与处理，将不必要的数据先丢弃，再将有用的信息压缩传送。更多的功能与运算能力会被赋予在网关上，因此网关的系统等级会比终端节点高，例如有人就使用树莓派（Raspberry Pi）来作为网关的应用。英特尔公司也将自己的产品定位于面向网关的应用（见图6-1），毕竟不可能所有设备或物品都替换来支持物联网，因此如何连接既有物品来支持物联网的新时代是当前最大的商机。

图6-1 英特尔（Intel）与研华（Advantech）所推出的网关方案（图片来源：www.advantech.com）

除了整个网络的硬件架构外，数据的传输更是占有无比重要的决定地位，没有数据、没有大数据，就没有物联网存在的意义。以前我们所定义的各种通信协议可能都不适用于物联网的设备与网络架构中，许多人也开始研究新的通信协议和方式来应用在物联网的应用中。

在网络上搜索一下，大概有几种最常被提及可以实现物联网新时代网络传输的协议。

CoAP（Constrained Application Protocol）

由于物联网的设备针对网络协议的处理可能没有强大的运算单元，例如Arduino就必须外加网络模块来解析网络数据分组，为了让小型设备也能顺利接上因特网，CoAP就是设计出来解决此问题的。CoAP是一个应用层的协议，基于UDP，架构非常精巧，可以让这些微型设备轻松与网络连接。

XMPP（Extensible Messaging and Presence Protocol）

XMPP是一种以XML为基础的开放式实时协议。Google Talk使用的就是此协议。XMPP网络是基于服务器的，也就是两端设备并不直接连接。不过目前版本的协议架构还是过于庞大，进而影响带宽。新的版本正在研究以降低网络负载。

MQTT（MQ Telemetry Transport）

MQTT是1999年由IBM公司所发明的，针对物联网的应用，通信协议预期用于无线和低带宽网络。后面我们有一小节会专门讨论它。

REST（Representational State Transfer）

REST是一种Web服务的软件架构，并不是一种协议标准，而是一种风格规范，通常基于HTTP、URI、XML以及HTML这些现有的协议和标准。满足REST原则的架构就称为RESTful，因此有时候会看到RESTful的名称。后面也会有一小节介绍RESTful。

下面用表格比较一下这4种协议的通信方式。

以上4种通信方式都是一个个非常深入的学问与领域，碍于笔者能力有限和本书篇幅的限制，在这里希望给大家一个提示和入门，有兴趣的人可以再分别深入研究每一种的优缺点和实现方式。本书只简单利用前辈们的范例与成果，用Arduino实现其过程，让大家有个基本的认识。

RESTful是网页技术下的一个技术演进，在此领域不是笔者的专长，有兴趣的人可以在网络上自行查阅相关知识。那你一定会问，这又和物联网有什么关系呢？

其实，物联网串起的不只是一个个冰冷的设备，更是自动化与信息化两大领域的融合。以往自动化领域的人玩的是传感器、逻辑控制等，让设备能够自主运行且将数据往上传送至中控系统的数据库。信息化的人则是从数据库的数据转换成分析、网页显示、决策等。这两大领域的人各司其职，也比较不会深入到对方的专业领域中。不过物联网的兴起打破了这个界线，上层的信息系统希望能够直接取得底层传感器感测的数据，但是问题是低层的数据都是数字和模拟的方式，上层系统的开发者无法理解这样的数据，因此就希望以REST的方式来进行数据的交换。REST是一个架构，让网页可以像软件一般进行通信与数据交换。

大家可能还是有点模糊，该怎么把REST应用于物联网中？这里列举几个例子。

Arduino所读取到的所有传感器全部都是有意义的，例如温度、湿度、灯光、门窗等。我们可以将一个Arduino定义成一组资源且有名称：

小明家就是一组资源的整合，包含了家里的温度、湿度等信息，利用这样直观的方式，就算不懂传感领域的开发者也可以轻松将系统从上往下连成一气。

网络上有一份REST的Arduino的函数库（见图6-2），由marcoschwartz所维护，大家可以到网站去下载，支持Arduino的Serial、Ethernet、Wi-Fi等，另外也支持ESP8266、树莓派。

网站：http://arest.io/

图6-2 aREST介绍网站

下载完毕后，按照相同的方式可以在Arduino里看到许多范例程序（见图6-3）。

图6-3 aREST的范例程序集

从网站上的介绍，我们看到在Serial的范例中可以用以下的指令来设置引脚的功能。

将第13个引脚设置为输出功能：

/mode/13/o

将第13个引脚设置输出为1：

/digital/13/1

这里我们使用Ethernet的范例来做更进一步的了解，为了简单为主，只需要调整符合使用环境的网络设置与MAC地址：

下载程序完毕后，我们就可以通过浏览器下达相关的指令，如图6-4所示。

图6-4 在Arduino加上Ethernet Shield实现REST指令

成功的话，在下方应该会有一串字符串显示出来，这是JSON（JavaScript Object Notation）的格式。说到JSON，它是一种轻量的数据交换语言，以文字为基础让人可以轻易解读。如果大家想要更清楚地了解这个字符串所表示的意义，可以到以下网址查看：

http://www.jsoneditoronline.org/

在左边粘贴上这个字符串后，按下往右的箭头即可转换出整个数据架构，如图6-5、图6-6所示。

图6-5 JSON字符串转换

图6-6 转换完成后的架构与数值

大家可以按照这样的测试再深入了解REST在Arduino实现的架构与相关规则。

MQTT（Message Queuing Telemetry Transport）是一个Machine-to-Machine（M2M）的发布（Publish）／订阅（Subscribe）信息的传输协议，是IBM和Eurotech共同制定出来的协议，有兴趣的人可以看一下官网的介绍：

MQTT is a machine-to-machine（M2M）/"Internet of Things" connectivity protocol. It was designed as an extremely lightweight publish/subscribe messaging transport. It is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium.

MQTT的规格版本为V3.1（2015/07），全文内容比起其他的协议不算多，因此可以让有兴趣的人自己完成，也因为如此，MQTT可以轻松地跨平台和不同种类的控制器进行整合。当初的设计是希望此协议简单、开放、数据长度短，能适用于带宽不足、联网质量不确定的网络环境下，也可以轻松整合嵌入式设备。Facebook的Messenger使用的就是MQTT（见图6-7）。在发布与订阅中，还需要一个中间桥梁，即Borker或Topic。

图6-7 MQTT架构（图片来源：EUROTECH）

MQTT适合在不稳定的情况下，例如带宽受限，通信稳定度不高或是设备解析能力有限。其特点为：

提供一对多的信息交换机制，使用发布／订阅的模式

以TCP/IP连接

提供不同等级的数据传输

话不多说，我们赶紧使用Arduino来实现MQTT的连接，大家先在网络上搜索“Arduino MQTT”，应该可以找到knolleary.net的Arduino Client for MQTT，目前最新版本是V1.9（2015/07）。下载并导入到Arduino的函数库中后，可以看到几个范例，这里我们要把PubSubClient\\textbackslash\{\}mqtt\_basic这个范例稍做修改。

喔～对了，这里我们都是使用Arduino加上Ethernet扩展板来进行，若是Wi-Fi的扩展板则会在网络连接这里有修改，其他大致不变。程序一开始引用必需的函数库，比较重要的是我们需要一个MQTT的Broker，大家可以在网络找到一些免费的Broker，范例使用的是test.mosquitto.org，它的IP地址是85.119.83.194。另外，针对自己使用的网络环境也可以先默认一个IP地址，避免当DHCP失效时，还可以有IP地址的设置，范例的网段只是参考，不是唯一的。

要让Arduino能够使用MQTT，需要靠arduinoClient这个结构变量，里面必须声明要连接的Broker，还有MQTT默认的端口号：1883。这里我们不处理接收的信息，因此看到callback函数里并没有任何程序。

setup()里当然要先建立网络通信的部分，在范例中使用DHCP的方式来取得IP。接着要和MQTT Broker进行连接，连接成功后会在串行端口监视器窗口内显示：Connected to MQTT Server。若无法正常连接，则检查硬件和网络是否都正常，可以使用ping的方式确认Arduino的运行状态。

最后在主程序中可以往Server发布Hello World的信息，这里的Topic是outTopic：

至于要如何确认Arduino的MQTT是否正常运行，这里使用IBM所提供的一个免费MQTT软件，称为WMQTT（ia92，见图6-8）。大家可以到网络搜索ia92下载。它是在Java环境下运行的软件，下载完成后，在文件夹内的J2SE里有一个wmqttSample.jar，单击之后应该就可以执行了。若无法顺利执行，则要确认Java的环境。

图6-8 WMQTT测试软件

最上面的Broker TCP/IP address就是我们要连接的Broker，这里输入85.119.83.194后单击Connect按钮，当左边灯号变成绿色时表示连接成功。接着在中间Subscribe To Topics中输入Topic的名称：outTopic，再单击Subscribe按钮。这时应该就可以看到窗口内出现HelloWorld的信息，即Arduino通过MQTT所传过来的信息，如图6-9所示。

图6-9 Arduino发布的信息

学会了MQTT可以做些什么事情呢？下一节将让大家看看更厉害的。

物联网的数据最终绝对和云计算脱不了关系，因此这里让大家看一下IBM所示范的如何通过MQTT将数据传送至云端。这里的范例是从IBM的网站上下载的，大家可以到https://internetofthings.ibmcloud.com/\#/下载，如图6-10所示。

图6-10 ibmcloud.com

单击网页最上方的Quickstart，进入页面后可以看到，IBM已经提供了许多硬件的范例流程，包含Arduino、树莓派、ARM mbed等，大家可以从Arduino里获取范例，如图6-11所示。

图6-11 IBM提供的各种硬件范例

注意，这里的范例除了前面MQTT的函数库外，还需要额外下载Paho mqtt library才可以顺利编译，这个范例的特别之处是使用到了Arduino UNO的ATMEGA328P里内建的温度传感。有兴趣的人可以到http://playground.arduino.cc/Main/InternalTemperatureSensor了解，细节就不再多做说明。

程序下载后，请确认网络状态一切顺利，接着回到网页的最上方，有一个地方可以输入Device ID（见图6-12），这里的ID指的就是范例程序中的MAC，大家可以稍微修改成不同的MAC。

图6-12 输入设备ID

若看到下方出现Device connected就表示Arduino已经顺利连上IBM的Cloud（云），如图6-13所示。

图6-13 设备连接成功

在网页下方可以看到一个曲线持续在变化，表示大功告成，如图6-14所示。

图6-14 Arduino上传的温度信息

如果这时候开启了监控器窗口，就可以看到上传的格式是JSON，如图6-15所示。

图6-15 上传的格式

是不是很简单呀！我们已经可以让数据从Arduino的微控制器中直接上传到IBM的云端实时显示。这就是物联网！看起来很简单，里面却包含了各式各样的技术与知识，也许过一阵子又会有新的技术让我们更方便地完成这样的操作。大家千万要抓紧物联网的趋势，这在未来10年会引领我们的发展并且极大地改变我们的生活。


\section{APPENDIX A　如何破坏Arduino}

网络上有一篇由RUGGEO CIRCUITS所提出的文章，文章名为“10种摧毁Arduino的方式”（10-ways-to-destroy-an-arduino），网址为http://www.ruggedcircuits.com/10-ways-to-destroy-an-arduino。有兴趣的读者可以自己到网络上搜索。当然他们针对此方式进行了加强并且推出了Ruggeduino（见图A-1），因为笔者自己没有用过，所以没有办法分享心得。不过因为它是以Arduino早期的版本（微控制器是ATMEGA8）为基础的，有些可能和现在的版本不符了，但是应该还是有其参考价值的。

图A-1 Ruggeduino

想深入了解的读者可以到网站上了解详情，其中包含了电路图的原理说明，会对大家进一步认识Arduino有不小的帮助。本书就只列举几个常见的错误，避免大家因为误接而损失一块Arduino。

外部电源供应不要高于12V

虽然Arduino UNO R3的稳压IC可以接受最大20V的输入，但是根据官网上的数据，建议大家还是以12V以下为主。

Arduino UNO每个引脚输入不要高于5V

Arduino UNO的工作电压是5V，当引脚设置为输入（INPUT）时，不要输入高于5V的信号。若一定有需要，则可以在引脚前再接一个稳压IC，确保信号可以转为5V。有些Arduino是3.3V的版本，则不可以超过3.3V。

Arduino电源端的引脚不要接到GND

Arduino UNO为了使用方便，在板子上提供了两组5V和一组3.3V的电源输出（见图A-2），这部分要小心，不要接到旁边的GND以免造成短路的现象，导致元件烧毁。同时，也不要将高于其规格的电压输入到这几个引脚。

图A-2 Arduino UNO的供电部分

不要高于引脚的负载

Arduino每一个引脚可以接受的负载为20mA，如要接到更大的功耗就使用晶体管或是有反向电动势保护的继电器模块。

不要将Arduino直接置于金属表面

Arduino背面焊点都没有额外保护，若直接接触金属表面则会造成某些引脚短路。建议使用六角脚柱垫高Arduino，避免与其他金属物体接触。


\section{APPENDIX B　如何进行除错}

在物联网系统中，除单个节点的功能运行很重要之外，整个通信网络更是核心，就像我们人体一样，除了手、脚、器官外，整个串联身体的神经系统负担起反应与感觉的传递。以前独立的Arduino系统，我们可以通过在程序区段中使用Serial.print显示出不同的信息来逐步确认程序问题的所在，但是当系统加上通信的部分时，如果我们连Serial.print都看不到信息时，那该怎么办呢？下面列举了几个实际常遇到的情况，并且提出检查的方式，协助大家在最短的时间内找到问题的所在。

当然，工欲善其事必先利其器。基本硬件的质量会是整体运行稳定的关键要素，尤其是Arduino或周边模块生产的厂商不止一家，大家务必确定购买的质量与稳定性能够符合自己的需要，笔者无法推荐哪家是最好的，建议初期小批量的测试绝对是必要的。另外，线材也是一个重要的因素，量产的产品建议大家还是重新规划硬件，将所有元件集中在同一块PCB电路板上会比较好，若非要使用线材，则多芯线是唯一选择。单芯线在面包板上的使用非常方便，如果内部铜线因为长久弯曲或是使用而断裂的话，外观上是看不出来的。现在可以看到有许多头尾加了杜邦端子的连接线，因为使用标准的引脚尺寸也是测试时建议的线材之一。

下面我们看看有哪些实践中会看到的现象。

不通

图B-1 Arduino的电源指示灯

通信通常指的是两个以上的设备，因此发生不通的情况几乎都是通信有问题，第一个要检查的一定是“电源”，这也是为什么不管小型设备或是大型系统都会配有电源指示灯（见图B-1），一个稳定的电源供应系统才能够确保其他功能的顺利运行，因此若发生不通的情况，请记得确认Arduino以及通信模块的电源。当我们系统乘载了许多传感器与驱动模块时，整体电源功耗是否超出供电器的极限，建议先大致估算一下。

另外，Arduino的外部电源输入最高电压限制在12V。千万别使用高于此电压的供应器或是电池。不然除非换一块Arduino，否则系统永远不会通了。

再来看看通信的部分，有线通信的不通可以轻易地通过检查通信线材的连接来确认问题点，至于无线通信的部分就必须先以最近可通信距离的方式确保两个设备不会因为距离的关系而失去连接，这样可以同时确认不通及下一个不稳的问题。网络的部分还可以通过Ping的方式确认，粗略得到通信的状态。

不稳

不稳通常指的是数据断断续续地传送，如果是在需要长时间连续记录的应用下就很糟糕，因为无法以固定间隔获取数据。数据断断续续的比较容易发生在无线通信的情况下，以前笔者有个实际的应用，将两个无线节点置于马路的左右两边，运行一阵子就发生通信断断续续的情况，结果发现当大型车辆经过时，截断在中间就发生不稳的情况，最后只好再将天线往上架高，避开大型车辆的影响。

不对

不对指的是两个设备间没有设置好相同的参数就进行通信，例如波特率的选择或是数据位的设置，都会影响接收方的数据处理，就像是在大街上遇到外国人，明明他向你说了很多话，你却一个字也没听懂。或是明明是两个人在对话，还多了一个不相关的第三者滔滔不绝，害得两个人无法顺利听清对方的话。这样通信发生“不对”的情况几乎只有串行通信才会发生，尤其是RS-232。因为其他通信机制都有固定的格式方便通信的建立，网络通信更会彼此确认设备可以接受的通信速度和连接，并实时调整。

没有功能

没有功能的问题大多来自于电源，就像前面所说系统电源的设计就是一门很重要的学问，如何让你设计的物联网系统运行的时间能像当初规划的那样长久，事前的实验与模拟以及例外情况的预防都能让系统持续运行。如果在户外也要记得避雷措施的保护，以防下次看到你的设备时只剩一块焦黑的电路板。

以上这些都是实际设计系统及运行时可能会遇到的问题，我们总希望在系统正式运行前发现一切可能会出错的地方再给予加强，但是就像墨菲定律（Murphy's Law）所说的：凡是可能出错的事必定会出错。因此，怎么在最短的时间内将问题找出并且解决就是我们这个章节要讨论的。

Arduino已经为我们提供了很方便的一个串行通信监视器窗口，只有在早期Windows XP的操作系统中才有所谓的“超级终端”可以做到类似的事情。Windows VISTA以后的版本就没有内置这个应用程序了，因此前面章节我们才会使用SSCOM（见图B-2）这个软件来协助，好处是可以将需要的AT Command整理成表，方便我们测试时重复使用。

图B-2 SSCOM的界面

这里我们则要介绍另一个软件，即AccessPort（见图B-3），目前版本为1.37。大家只需要上网搜索一下就可以找到了。AccessPort不需要安装，解完压缩后就可以使用。

图B-3 AccessPort软件的显示界面

它的接口可以轻松转换成十六进制的数据，方便我们在确认通信协议时可以轻松地看到每一个字符，确定整个协议是否完整。另外，它还可以设置非常规的速率（见图B-4），不过这需要硬件搭配才行。

图B-4 设置非常规的速率

AccessPort还有另一个厉害的地方，就是可以监控计算机和设备间的通信，这里我们用Arduino的ASCII Table范例来示范一下。

首先当然还是要记得设置好通信参数及使用的通信端口（串口），如图B-5所示。

图B-5 参数设置

设置完成后先不要开启通信端口，如果软件自行开启的话请先将它关闭。接着转到Monitor的分页，如图B-6所示。

图B-6 Monitor分页

选择要监看的通信端口再单击“开始监控”，完成便可回到Terminal视窗，正式开启通信端口进行数据传送，如图B-7所示。

图B-7 Arduino传输过来的ASCII Table

在数据传输的过程中，我们可以切到Monitor分页去观察串行端口通信的情况，其中包含了传输的时间长度（Duration）、当前执行的请求操作（Request）以及数据（Data）。以范例来说，你会发现Arduino每次传输的长度并不一定是计算机端每次接收的长度，计算机因为操作系统的关系，可能会分批处理传进来的数据，但是实际显示却看不到这样的变化。

可是有时候我们的设备另外一端不一定是计算机，可能是两个Arduino互传，或是一个Arduino向RFID的读取器去取得数据，这时候该怎么取得中间的通信呢？建议大家到电子器材市场买一捆彩虹线，加上压线式的DB-9接头（见图B-8），大家可以各买几个公口母口的接头后压到彩虹线（因为是RS-232的接线，所以全部共有9条线）上，这样就有一条可以监听两个设备串行通信的监听线了。

图B-8 压线式DB-9接头（图片来源：http://china.makepolo.com/product-detail/100435556807.html）

监听的设备可以找有两个串行端口的计算机（见图B-9），这样就可以分别传送和接收数据了。

图B-9 串行端口监听的方式

图B-10 Wireshark启动屏幕

网络通信的部分，则要介绍一个开源的网络数据分组分析软件（网络分析器）：Wireshark（见图B-10）。在以前要采集网络上的数据分组并且进行分析是一件不容易且代价不低的事情，但是Wireshark的出现让数据分组的分析变得非常简单，只需要下载这个软件并安装后，就可以得到网络通信上的数据分组，并借此学习到网络通信的架构以及使用到的协议。这套软件只能旁观网络通信数据分组的交换，并无法修改数据分组或是提出异常的警告，也不会自己发出数据分组，因此作为一个旁观者的角色非常适合。

安装完毕，启动这个软件后，会出现如图B-11所示的窗口。我们先要选择想要监听的接口，因为计算机可能有多条网线，另外还可能有无线的部分，因此必须选择想要监听的部分，如图B-12所示。

图B-11 Wireshark

图B-12 选择想要监听的网络接口

在接口列表中单击Options后，还可以进入高级菜单。有时候为了长时间记录，又不想因为意外情况造成文件损毁时，我们可以使用这里的多次存盘，可以选择是要根据文件大小还是时间间隔进行数据存储（见图B-13）。

图B-13 存盘方式选择

都设置完毕后，单击Start按钮就可以开始进行数据分组的采集（见图B-14）。这时窗口应该会跳到另外一个地方分成三个段落，第一段会一直看到很多不同颜色的分组。第二段则是被选择到的单个分组内的细节。最后则是单个分组内的十六进制数据。

图B-14 采集中的屏幕显示界面

我们来看看第一个区段的各个字段，可以清楚地知道每一个分组的来源（Source）和目标（Destination）、分组采用的协议（Protocol）和其中的数据内容等，如图B-15所示。如果我们要仔细研究一个协议内的详细信息，可以在窗口第二个区段看到完整的解析，Wireshark支持非常多的网络协议，包含MQTT也可以解析得出来，因此是学习高级网络知识的好帮手。

图B-15 TCP分组的部分细节数据

和串行通信一样，如果是两个设备直接使用网络进行通信，并没有经过计算机，又该怎么样采集到分组呢？这时候我们需要集线器（Hub）的帮忙。纯粹的集线器目前在市面上几乎见不到了（已经不正式生产和销售了）。这里说的是集线器（Hub），而不是网络交换机（Switch）。两者的差别（见图B-16）是集线器并不会处理任何数据，当一个通信端口有数据进来时，集线器只会将这个数据转发至其他所有通信端口。交换机则会根据每个通信端口的IP和MAC的信息来进行转发，其他通信端口不会收到跟自己没有关系的数据。

图B-16 集线器与交换机的差异

有没有发现秘密？如果在原本的两台网络设备之间加上一个集线器，就可以多出一个通信端口来连接计算机，因为负责监听的计算机并没有任何应用程序来针对收到的信息进行响应，因此便可以完整监听到分组而不造成通信的影响，如图B-17所示。

图B-17 监听计算机的部署

有兴趣进一步了解的人，可以参考基峰信息公司出版的《实战分组分析——使用Wireshark》（由Chris Sanders编著，里面有许多更详细的资料可以参考）。


\section{APPENDIX C　ASCII字元码}


\section{APPENDIX D　物联网套件组合包}

书中所有通信模块与传感器可使用标准元件如下列表格中所示，需要的读者可以按照不同的应用需求进行采购。至于无线通信的部分，由于各个国家或地区的监管部门有法令的限制，如果有成品量产和销售的需求，则需要再进行相关的产品审批等流程。

如果想直接使用本书的完整套件，可参考厂商艾思迪诺（Appsduino）的物联网套件“IoTWSN物联网无线传感应用开发系统（用Arduino全面打造物联网组合包）”。

* 以上也可使用艾思迪诺（Appsduino）组合包中的传感端套件进行实践。

* 以上也可使用艾思迪诺（Appsduino）组合包中的传感端套件，加上MAX485通信、RTC、W5100网络模块和DHT11模块进行实践。

* 以上也可使用艾思迪诺（Appsduino）组合包中的传感端套件，加上蓝牙通信、XBee、nRF24L01无线模块等进行实践。

* 以上也可使用艾思迪（Appsduino）上述组合进行操作。

* 以上也可使用艾思迪诺（Appsduino）组合包中的传感端套件，加上蓝牙通信、XBee、nRF24L01无线模块等进行实践。

艾思迪诺（Appsduino）的物联网套件“IoTWSN物联网无线传感应用开发系统（用Arduino全面打造物联网组合包）”内容如下所示：

主控端（CO）

O传感端（RO）

RFID管理端（RO）

本套件物联网无线传感应用开发系统可分为主控端（CO）、传感端（RO）、RFID管理端（RO）以及手持移动设备APP监控界面。传感端（RO）配置有温湿度、照度、一氧化碳（CO）浓度、声音、开窗等传感器，以及可从远端控制的灯光开关，而其上的传感器及开关的最新情况，都会即时通过ZigBee无线模块送回到主控端（CO），另一个RFID管理端（RO）则配置了RFID Reader，作为门禁进出管理，并将进出信息传给主机。主控端获得信息后，除了将其显示在LCD屏幕外，信息再通过蓝牙（Bluetooth）无线模块，转送给Android手持设备内建的APP监测程序，因此用户可在无线的场景下，由手持设备查看当前即时的温湿度、照度、声音、一氧化碳浓度，并从远程控制开关启动（或关闭）。而IoTWSN APP可从Google Play载。

■ Arduino UNO R3兼容板（含电压检测与Buzzer）x3

■ iArduino-ZB（CO）＋蓝牙（BT）

■ iArduino-ZB（RO）x2

■ RFID读写模块与RFID Tag

■ 温湿度、照度、一氧化碳浓度、声音、磁簧开关、Relay

■ Sanyo锂电池（2600mAh@7.4V）×3

■ 锂电池充电器×3

■ 学习手册

■ USB Cable

■ 杜邦线

■ Arduino ZigBee程序范例

■ ZigBee Library（AppsBee）与使用说明

■ Android互动APP

■ ■固定底座×3

■ Android互APP

■ 固定底座×3

IoTWSN-NFC物联网NFC无线传感应用模块

NFC管理端（RO）

■ Arduino UNO R3兼容板（含电压检测与Buzzer）

■ iArduino-ZB（RO）

■ NFC读写模块与NFC Tag

■ Sanyo锂电池（2600mAh@7.4V）

■ 锂电池充电器

■ 学习手册

■ USB Cable

■ 杜邦线

■ Arduino ZigBee程序范例

■ ZigBee Library（AppsBee）与使用说明

■ NFC程序范例

■ Android互动APP

■ 固定底座

IoTWSN-GPRS物联网GPRS/SMS监控与信息模块

GPRS/SMS信息管理端（RO）

■ iArduino-ZB（RO）

■ 四频（850/900/1800/1900Mhz）GPRS通信模块

■ Sanyo锂电池（2600mAh@7.4V）

■ 锂电池充电器

■ 学习手册

■ USB Cable

■ 杜邦线

■ Arduino ZigBee程序范例

■ ZigBee Library（AppsBee）与使用说明

■ GPRS/SMS程序范例

■ Android互动APP

■ 固定底座

其他零件

MAX485 IC通信兼容模块、DS1307 RTC模块、W5100网络通信模块、DHT11温度测量模块、433Hz or 315Hz RF发射与接收模块、nRF24L01 RF无线模块、XBee模块、ESP-01 WiFi无线模块、W5100网络通信模块。

组合包购买信息


\end{document}
