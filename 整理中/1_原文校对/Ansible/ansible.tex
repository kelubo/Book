% 中文书籍LaTeX模板
% 使用xelatex编译

\documentclass[12pt,a4paper,twoside]{ctexbook}

% 页面设置
\input{../../../common/page}

% 字体设置
\usepackage{xeCJK}
\usepackage{fontspec}
\usepackage{microtype}

% 设置中文字体
\setCJKmainfont{SimSun}[  % 正文宋体
    BoldFont=SimHei,        % 粗体黑体
    ItalicFont=KaiTi        % 斜体楷体
]
\setCJKsansfont{SimHei}    % 无衬线字体黑体
\setCJKmonofont{SimSun}    % 等宽字体宋体
\setCJKfamilyfont{kai}[    % 楷体
    BoldFont=KaiTi
]{KaiTi}
\setCJKfamilyfont{fs}[     % 仿宋
    BoldFont=FangSong
]{FangSong}

% 常用字体命令
\newcommand{\song}{\CJKfamily{zhsong}}
\newcommand{\hei}{\CJKfamily{zhhei}}
\newcommand{\kai}{\CJKfamily{kai}}
\newcommand{\fs}{\CJKfamily{fs}}

% 标题格式设置
\ctexset{
    part/name={第,卷},
    part/number={\chinese{part}},
    chapter/name={第,章},
    chapter/number={\chinese{chapter}},
    section/name={第,节},
    section/number={\arabic{section}},
    subsection/number={\arabic{section}.\arabic{subsection}},
    chapter/format={\centering\hei\zihao{2}},
    section/format={\hei\zihao{4}},
    subsection/format={\hei\zihao{5}}
}

% 目录设置
\usepackage{titletoc}
\titlecontents{chapter}[0pt]{\vspace{10pt}\bfseries\zihao{-4}}{\contentspush{\thecontentslabel\hspace{1em}}}{}{\titlerule*[8pt]{.}\contentspage}
\titlecontents{section}[2.5em]{\vspace{5pt}\zihao{5}}{\contentspush{\thecontentslabel\hspace{1em}}}{}{\titlerule*[8pt]{.}\contentspage}
\titlecontents{subsection}[5em]{\vspace{3pt}\zihao{5}}{\contentspush{\thecontentslabel\hspace{1em}}}{}{\titlerule*[8pt]{.}\contentspage}

% 页眉页脚设置
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{\zihao{5}\thepage}
\fancyhead[LO]{\zihao{5}\leftmark}
\fancyhead[RE]{\zihao{5}\rightmark}
\renewcommand{\chaptermark}[1]{\markboth{\chaptername\ \thechapter\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyfoot[C]{\zihao{5} \thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

% 插图设置
\usepackage{graphicx}
\usepackage{float}
\usepackage{subfigure}
\graphicspath{{Images/}}
\floatstyle{plaintop}
\restylefloat{figure}

% 表格设置
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{longtable}

% 数学公式设置
\usepackage{amsmath, amssymb, amsthm}
\usepackage{mathrsfs}

% 定理环境
\newtheorem{theorem}{定理}[chapter]
\newtheorem{definition}{定义}[chapter]
\newtheorem{lemma}{引理}[chapter]
\newtheorem{corollary}{推论}[chapter]
\newtheorem{example}{例}[chapter]

% 目录、摘要等设置
\usepackage{makeidx}
\makeindex

% 摘要设置
\newenvironment{abstract}{
    \cleardoublepage
    \thispagestyle{empty}
    \begin{center}
        \textbf{\zihao{1} 摘要}
    \end{center}
    \vspace{1cm}
    \itshape
}{
    \normalfont
}

% 关键词设置
\newcommand{\keywords}[1]{
    \vspace{1cm}
    \noindent\textbf{关键词：} #1
}

% 引用设置
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue,
    pdftitle={Ansible},
    pdfauthor={},
    pdfsubject={Ansible 自动化},
    pdfkeywords={Ansible \quad 自动化 \quad 学习路线图}
}

% 目录深度
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

% 标题页设置
\usepackage{titling}

% 封面信息
\title{\hei\zihao{0} Ansible}
\author{\song\zihao{2}}
\date{\song\zihao{4} \today}

\begin{document}

% 封面
\begin{titlepage}
    \begin{center}
        \vspace*{6cm}
        \hei\zihao{0} Ansible
        \vspace*{3cm}
        \song\zihao{2}
        \vspace*{3cm}
        \song\zihao{4} \today
    \end{center}
\end{titlepage}

% 版权页
\newpage
\thispagestyle{empty}
\begin{center}
    \vspace*{8cm}
    \song\zihao{5} 版权所有 \textcopyright\ 2026
    \vspace*{1cm}
    \song\zihao{5}
\end{center}

% 摘要
\begin{abstract}
    本书旨在提供一个全面的 Ansible 学习指南，从基础概念到高级应用，帮助读者系统性地掌握 Ansible 自动化技术。涵盖了 Ansible 的核心组件、安装配置、Playbooks 编写、Roles 管理、高级特性以及实际应用场景等内容。
    
    \keywords{Ansible \quad 自动化 \quad Playbooks}
\end{abstract}

% 目录
\newpage
\tableofcontents

% 正文开始
\mainmatter

% 第一章 Ansible 简介
\chapter{Ansible 简介}
\section{Ansible 的定义与价值}
Ansible 提供开源自动化，降低复杂性并可在任何地方运行。使用 Ansible，您几乎可以自动化任何任务。以下是 Ansible 的一些常见用例：\par
- 消除重复工作并简化工作流程\par
- 管理和维护系统配置\par
- 持续部署复杂软件\par
- 执行零停机滚动更新\par

Ansible 使用称为 Playbooks 的简单、人类可读的脚本自动执行您的任务。您在 Playbook 中声明本地或远程系统的期望状态。Ansible 确保系统保持在该状态。\par

作为自动化技术，Ansible 的设计围绕以下原则：\par
**无代理架构**\par
通过避免在 IT 基础设施中安装额外软件来降低维护开销。\par

**简单性**\par
自动化 Playbooks 使用简单明了的 YAML 语法，代码读起来像文档。Ansible 也是去中心化的，使用 SSH 和现有操作系统凭据访问远程机器。\par

**可扩展性和灵活性**\par
通过模块化设计轻松快速地扩展您自动化的系统，支持各种操作系统、云平台和网络设备。\par

**幂等性和可预测性**\par
当系统处于您的 Playbook 描述的状态时，即使 Playbook 运行多次，Ansible 也不会更改任何内容。\par

Ansible 是一种开源的自动化工具，用于配置管理、应用部署、任务执行和编排。它由 Michael DeHaan 创建，后来被 Red Hat 收购，成为 Red Hat 自动化套件的核心组件。\par

Ansible 自动化远程系统的管理并控制它们的期望状态。\par

Ansible 的核心价值在于其简单性和强大性的结合：\par
- **无代理架构**：不需要在被管理节点上安装额外的软件，通过 SSH 协议进行通信\par
- **声明式语法**：使用 YAML 编写 Playbooks，易于阅读和维护\par
- **幂等性**：多次执行相同的 Playbook 会产生相同的结果，避免意外更改\par
- **模块化设计**：丰富的内置模块，支持各种任务场景\par
- **扩展性**：支持自定义模块和插件，满足特定需求\par
- **跨平台**：支持 Linux、Windows、网络设备等多种平台

\section{Ansible 与其他自动化工具的对比}
与其他自动化工具相比，Ansible 具有以下优势：\par

\begin{table}[H]
    \centering
    \caption{自动化工具对比}
    \label{tab:automation-tools}
    \begin{tabular}{cccc}
        \toprule
        工具 & 架构 & 配置语言 & 优势 \\
        \midrule
        Ansible & 无代理 & YAML & 简单易用，无依赖 \\
        Puppet & 客户端-服务器 & Ruby DSL & 强大的状态管理 \\
        Chef & 客户端-服务器 & Ruby & 灵活，适合复杂场景 \\
        SaltStack & 混合架构 & YAML/Python & 高性能，适合大规模部署 \\
        \bottomrule
    \end{tabular}
\end{table}

Ansible 的无代理架构使其在部署和维护方面更加简单，而 YAML 语法则降低了学习曲线，适合团队协作。

\section{Ansible 的应用场景}
Ansible 适用于多种自动化场景：\par

1. **配置管理**：标准化服务器配置，确保环境一致性\par
2. **应用部署**：自动化应用的安装、配置和部署过程\par
3. **持续集成/持续部署**：与 CI/CD 工具集成，实现自动化测试和部署\par
4. **云资源管理**：管理 AWS、Azure、GCP 等云平台资源\par
5. **网络自动化**：配置和管理网络设备，如路由器、交换机\par
6. **安全合规**：自动化安全检查和合规性验证\par
7. **基础设施即代码**：将基础设施配置以代码形式管理\par
8. **多环境管理**：同时管理开发、测试、生产等多个环境

Ansible 的灵活性使其能够适应从小型应用到大型企业级部署的各种场景。

% 第二章 基础概念与安装
\chapter{基础概念与安装}
\section{Ansible 核心概念}
这些概念适用于 Ansible 的所有使用场景。在使用 Ansible 或阅读文档之前，应该理解它们。\par

- 控制节点\par
- 被管理节点\par
- 清单\par
- Playbooks\par
\quad - Plays\par
\quad \quad - Roles\par
\quad \quad - Tasks\par
\quad \quad - Handlers\par
- 模块\par
- 插件\par
- 集合\par

\subsection{控制节点}
您运行 Ansible CLI 工具（ansible-playbook、ansible、ansible-vault 等）的机器。您可以使用任何满足软件要求的计算机作为控制节点 - 笔记本电脑、共享桌面和服务器都可以运行 Ansible。您还可以在称为执行环境的容器中运行 Ansible。\par

\textbf{控制节点要求：}\par
对于控制节点（运行 Ansible 的机器），您可以使用几乎任何安装了 Python 的类 UNIX 机器。这包括 Red Hat、Debian、Ubuntu、macOS、BSD 以及 Windows Subsystem for Linux (WSL) 发行版下的 Windows。没有 WSL 的 Windows 本身不支持作为控制节点。\par

可以使用多个控制节点，但 Ansible 本身不会在它们之间进行协调。\par

\subsubsection{执行环境简介}
Ansible 执行环境旨在解决复杂性问题并提供容器化带来的所有好处。\par

\paragraph{降低复杂性}
执行环境可以在三个主要方面降低复杂性：\par
- 软件依赖项\par
- 可移植性\par
- 内容分离\par

\paragraph{依赖项}
软件应用程序通常有依赖项，Ansible 也不例外。这些依赖项可以包括软件库、配置文件或其他服务等。\par

传统上，管理员使用 RPM 或 Python-pip 等包管理工具在操作系统上安装应用程序依赖项。这种方法的主要缺点是应用程序可能需要与默认提供的不同版本的依赖项。对于 Ansible，典型的安装包括 ansible-core 和一组 Ansible 集合。其中许多集合对它们提供的插件、模块、角色和 playbooks 有依赖项。\par

Ansible 集合可能依赖于以下软件及其版本：\par
- ansible-core\par
- Python\par
- Python 包\par
- 系统包\par
- 其他 Ansible 集合\par

这些依赖项必须安装，有时可能会相互冲突。\par

部分解决依赖项问题的一种方法是在 Ansible 控制节点上使用 Python 虚拟环境。然而，应用于 Ansible 的虚拟环境有缺点和自然限制。\par

\paragraph{可移植性}
Ansible 用户在本地为 Ansible 编写内容，并希望利用容器技术使其自动化运行时可移植、可共享且易于部署到测试和生产环境。\par

\paragraph{内容分离}
在有多个用户使用 Ansible 控制节点或 Ansible AWX/Controller 等工具的情况下，他们可能希望分离其内容以避免配置和依赖项冲突。\par

\paragraph{执行环境的 Ansible 工具}
Ansible 生态系统中的项目还提供了几个可以与执行环境一起使用的工具，例如：\par
- Ansible Builder\par
- Ansible Navigator\par
- Ansible AWX\par
- Ansible Runner\par
- VS Code Ansible\par
- Dev Containers 扩展\par

\subsubsection{设置环境}
完成以下步骤，为您的第一个执行环境设置本地环境：\par

1. 确保系统上安装了以下包：\par
- podman 或 docker\par
- python3\par
- python3-pip\par

如果使用 DNF 包管理器，按以下方式安装这些先决条件：\par
\begin{verbatim}
sudo dnf install -y podman python3 python3-pip
\end{verbatim}

2. 安装 ansible-navigator：\par
\begin{verbatim}
pip3 install ansible-navigator
\end{verbatim}

安装 ansible-navigator 可以让您在命令行上运行 EE。它包含 ansible-builder 包来构建 EE。\par

如果您想构建 EE 而不测试，只需安装 ansible-builder：\par
\begin{verbatim}
pip3 install ansible-builder
\end{verbatim}

3. 使用以下命令验证您的环境：\par
\begin{verbatim}
ansible-navigator --version
ansible-builder --version
\end{verbatim}

准备好通过几个简单的步骤构建 EE 了吗？继续阅读构建您的第一个执行环境。\par

\subsubsection{构建您的第一个执行环境}
我们将构建一个 EE，它代表一个 Ansible 控制节点，包含标准包（如 ansible-core 和 Python）以及 Ansible 集合（community.postgresql）及其依赖项（psycopg2-binary Python 连接器）。\par

要构建您的第一个 EE：\par

1. 在文件系统上创建一个项目文件夹。\par
\begin{verbatim}
mkdir my_first_ee && cd my_first_ee
\end{verbatim}

2. 创建一个 execution-environment.yml 文件，指定要包含在镜像中的依赖项。\par
\begin{verbatim}
version: 3

images:
  base_image:
    name: registry.fedoraproject.org/fedora:42

dependencies:
  python_interpreter:
    package_system: python3
  ansible_core:
    package_pip: ansible-core
  ansible_runner:
    package_pip: ansible-runner
  system:
  - openssh-clients
  - sshpass
  galaxy:
    collections:
    - name: community.postgresql
\end{verbatim}

\textbf{注意：}psycopg2-binary Python 包包含在集合的 requirements.txt 文件中。对于不包含 requirements.txt 文件的集合，您需要显式指定 Python 依赖项。\par

3. 构建一个名为 postgresql_ee 的 EE 容器镜像。\par

如果使用 docker，请添加 --container-runtime docker 参数。\par
\begin{verbatim}
ansible-builder build --tag postgresql_ee
\end{verbatim}

4. 列出容器镜像以验证构建成功。\par
\begin{verbatim}
podman image list

localhost/postgresql_ee          latest      2e866777269b  6 minutes ago  1.11 GB
\end{verbatim}

您可以通过查看上下文目录中的 Containerfile 或 Dockerfile 来验证您创建的镜像，以查看其配置。\par
\begin{verbatim}
less context/Containerfile
\end{verbatim}

您还可以使用 Ansible Navigator 查看有关镜像的详细信息。\par

运行 ansible-navigator 命令，在 TUI 中输入 :images，然后选择 postgresql_ee。\par

继续阅读运行您的 EE 并测试您刚刚构建的 EE。\par

\subsubsection{运行您的执行环境}
您可以使用 ansible-navigator 在命令行上针对 localhost 或远程目标运行您的 EE。\par

\textbf{注意：}除了 ansible-navigator 之外，还有其他工具可以运行 EE。\par

\paragraph{针对 localhost 运行}
1. 创建一个 test_localhost.yml playbook。\par
\begin{verbatim}
- name: Gather and print local facts
  hosts: localhost
  become: true
  gather_facts: true
  tasks:

    - name: Print facts
      ansible.builtin.debug:
        var: ansible_facts
\end{verbatim}

2. 在 postgresql_ee EE 中运行 playbook。\par
\begin{verbatim}
ansible-navigator run test_localhost.yml --execution-environment-image postgresql_ee --mode stdout --pull-policy missing --container-options='--user=0'
\end{verbatim}

您可能会注意到收集的事实是关于容器的，而不是开发机器的。这是因为 ansible playbook 是在容器内部运行的。\par

\paragraph{针对远程目标运行}
在开始之前，确保您有以下内容：\par
- 至少一个远程目标的 IP 地址或可解析的主机名。\par
- 远程主机的有效凭据。\par
- 在远程主机上具有 sudo 权限的用户。\par

在 postgresql_ee EE 中针对远程主机执行 playbook，如下例所示：\par

1. 为清单文件创建一个目录。\par
\begin{verbatim}
mkdir inventory
\end{verbatim}

2. 在 inventory 目录中创建 hosts.yml 清单文件。\par
\begin{verbatim}
all:
  hosts:
    192.168.0.2  # Replace with the IP of your target host
\end{verbatim}

3. 创建一个 test_remote.yml playbook。\par
\begin{verbatim}
- name: Gather and print facts
  hosts: all
  become: true
  gather_facts: true
  tasks:

    - name: Print facts
      ansible.builtin.debug:
        var: ansible_facts
\end{verbatim}

4. 在 postgresql_ee EE 中运行 playbook。\par

将 student 替换为适当的用户名。根据目标主机的身份验证方法，命令中的某些参数可能是可选的。\par
\begin{verbatim}
ansible-navigator run test_remote.yml -i inventory --execution-environment-image postgresql_ee:latest --mode stdout --pull-policy missing --enable-prompts -u student -k -K
\end{verbatim}

\subsubsection{使用社区 EE 镜像运行 Ansible}
您可以使用社区镜像运行 Ansible，而无需构建自定义 EE。\par

使用仅包含 ansible-core 的 community-ee-minimal 镜像或还包含几个基础集合的 community-ee-base 镜像。运行以下命令查看 community-ee-base 镜像中包含的集合：\par
\begin{verbatim}
ansible-navigator collections --execution-environment-image ghcr.io/ansible-community/community-ee-base:latest
\end{verbatim}

在 community-ee-minimal 容器中针对 localhost 运行以下 Ansible 临时命令：\par
\begin{verbatim}
ansible-navigator exec "ansible localhost -m setup" --execution-environment-image ghcr.io/ansible-community/community-ee-minimal:latest --mode stdout
\end{verbatim}

现在，创建一个简单的测试 playbook 并在容器中针对 localhost 运行它：\par
\begin{verbatim}
- name: Gather and print local facts
  hosts: localhost
  become: true
  gather_facts: true
  tasks:

    - name: Print facts
      ansible.builtin.debug:
        var: ansible_facts
\end{verbatim}
\begin{verbatim}
ansible-navigator run test_localhost.yml --execution-environment-image ghcr.io/ansible-community/community-ee-minimal:latest --mode stdout
\end{verbatim}

\subsubsection{在容器中安装 Ansible}
您可以简单地构建一个执行环境容器镜像或使用可用的社区镜像作为控制节点，而不是手动安装 Ansible 内容。\par

\subsubsection{执行环境入门}
您可以像运行任何其他现代软件应用程序一样，在容器中运行 Ansible 自动化。Ansible 使用称为执行环境（Execution Environment，EE）的容器镜像作为控制节点。执行环境消除了复杂性，以扩展自动化项目并使部署操作等事情更加简单明了。\par

执行环境镜像标准包含以下包：\par
- ansible-core\par
- ansible-runner\par
- Python\par
- Ansible 内容依赖项\par

除了标准包外，执行环境还可以包含：\par
- 一个或多个 Ansible 集合及其依赖项\par
- 其他自定义组件\par

本入门指南向您展示如何构建和测试简单的执行环境。生成的容器镜像代表一个 Ansible 控制节点，包含：\par
- 标准执行环境包\par
- community.postgresql 集合\par
- psycopg2-binary Python 包\par

\subsection{被管理节点}
也称为“主机”，这些是您旨在使用 Ansible 管理的目标设备（服务器、网络设备或任何计算机）。\par

\textbf{被管理节点要求：}\par
被管理节点（Ansible 正在管理的机器）不需要安装 Ansible，但需要 Python 来运行 Ansible 生成的 Python 代码。被管理节点还需要一个用户账户，该账户可以通过 SSH 连接到节点并具有交互式 POSIX shell。\par

\textbf{注意：}\par
模块要求可能有例外。例如，网络模块不需要在被管理设备上安装 Python。请参阅您使用的模块的文档。\par

Ansible 通常不会安装在被管理节点上，除非您使用 ansible-pull，但这很少见且不是推荐的设置。\par

\subsection{清单}
由一个或多个“清单源”提供的被管理节点列表。您的清单可以指定每个节点的特定信息，如 IP 地址。它还用于分配组，既允许在 Play 中选择节点，也允许批量变量分配。\par

有时清单源文件也称为“主机文件”。\par

\subsubsection{在清单中添加变量}
您可以在清单中定义与特定主机或组相关的变量。开始的简单方法是直接在 YAML 或 INI 格式的清单源中为主机和组添加变量。\par

本指南为简单起见，记录了如何在清单源中添加变量。但是，您也可以使用 Vars 插件从许多其他来源添加变量。默认情况下，Ansible 附带 host_group_vars 插件，该插件允许您在单独的主机和组变量文件中定义变量。\par

与在清单源中定义变量相比，使用单独的文件来描述系统策略是一种更可靠的方法。有关如何在 'host_vars' 和 'group_vars' 目录中的各个文件中存储变量值的指南，请参阅组织主机和组变量。\par

\subsubsection{为单个主机分配变量：主机变量}
您可以轻松地为单个主机分配变量，然后在后续的 Playbooks 中使用该变量。您可以直接在清单文件中执行此操作。\par

在 INI 格式中：\par
\begin{verbatim}
[atlanta]
 host1 http_port=80 maxRequestsPerChild=808
 host2 http_port=303 maxRequestsPerChild=909
\end{verbatim}
\par

在 YAML 格式中：\par
\begin{verbatim}
atlanta:
  hosts:
    host1:
      http_port: 80
      maxRequestsPerChild: 808
    host2:
      http_port: 303
      maxRequestsPerChild: 909
\end{verbatim}
\par

像非标准 SSH 端口这样的唯一值非常适合作为主机变量。您可以通过在主机名后添加冒号和端口号来将它们添加到 Ansible 清单中：\par
\begin{verbatim}
badwolf.example.com:5309
\end{verbatim}
\par

您可以使用主机变量定义“连接变量”。连接变量配置连接、shell 和 become 插件，以启用在主机上执行任务。例如：\par
\begin{verbatim}
[targets]

localhost              ansible_connection=local
other1.example.com     ansible_connection=ssh        ansible_user=myuser
other2.example.com     ansible_connection=ssh        ansible_user=myotheruser
\end{verbatim}
\par

\subsubsection{清单别名}
inventory_hostname 是 Ansible 中主机的唯一标识符。此标识符可以是 IP 地址或主机名，但也可以只是主机的“别名”或短名称。\par

在 INI 格式中：\par
\begin{verbatim}
jumper ansible_port=5555 ansible_host=192.0.2.50
\end{verbatim}
\par

在 YAML 格式中：\par
\begin{verbatim}
# ...
  hosts:
    jumper:
      ansible_port: 5555
      ansible_host: 192.0.2.50
\end{verbatim}
\par

在此示例中，针对主机别名“jumper”运行 Ansible 会连接到端口 5555 上的 192.0.2.50。有关进一步自定义与主机的连接，请参阅行为清单参数。\par

此功能对于多次定位同一主机也很有用，但请记住任务可以并行运行：\par

在 INI 格式中：\par
\begin{verbatim}
jumper1 ansible_port=5555 ansible_host=192.0.2.50
jumper2 ansible_port=5555 ansible_host=192.0.2.50
\end{verbatim}
\par

在 YAML 格式中：\par
\begin{verbatim}
# ...
  hosts:
    jumper1:
      ansible_port: 5555
      ansible_host: 192.0.2.50
    jumper2:
      ansible_port: 5555
      ansible_host: 192.0.2.50
\end{verbatim}\par

\subsubsection{在 INI 格式中定义变量}
Ansible 根据您在何处声明值，会以不同方式解释使用 key=value 语法在 INI 格式中传递的值：\par

• 当您在主机行内联声明值时，Ansible 将 INI 值解释为 Python 字面结构（例如，字符串、数字、元组、列表、字典、布尔值或 None）。主机行每行接受多个 key=value 参数。因此，您需要一种方法来指示空格是值的一部分，而不是分隔符。您可以用引号（单引号或双引号）括起包含空格的值。有关详细信息，请参阅 Python shlex 解析规则。\par

• 当您在 :vars 部分中声明值时，Ansible 将 INI 值解释为字符串。例如，var=FALSE 创建一个值为 'FALSE' 的字符串。与主机行不同，:vars 部分每行只接受一个条目，因此等号后的所有内容都成为条目的值。\par

如果您需要来自 INI 清单的变量具有特定类型（例如，字符串或布尔值），请始终在任务中使用过滤器指定类型。在使用变量时，不要依赖于在 INI 清单中设置的类型。\par

考虑使用 YAML 格式作为清单源，以避免对变量实际类型的混淆。YAML 清单插件始终一致且正确地处理变量值。\par

\subsubsection{为多个主机分配变量：组变量}
如果一个组中的所有主机都共享一个变量值，您可以一次将该变量应用到整个组。\par

在 INI 格式中：\par
\begin{verbatim}
[atlanta]
 host1
 host2

[atlanta:vars]
 ntp_server=ntp.atlanta.example.com
 proxy=proxy.atlanta.example.com
\end{verbatim}
\par

在 YAML 格式中：\par
\begin{verbatim}
atlanta:
  hosts:
    host1:
    host2:
  vars:
    ntp_server: ntp.atlanta.example.com
    proxy: proxy.atlanta.example.com
\end{verbatim}
\par

组变量是一种方便的方法，可以一次将变量应用到多个主机。但是，在执行之前，Ansible 总是将变量（包括清单变量）扁平化为主机级别。如果主机是多个组的成员，Ansible 会从所有这些组中读取变量值。如果您在不同的组中为同一个变量分配不同的值，Ansible 会根据内部合并规则选择使用哪个值。\par

\subsubsection{继承变量值：组的组的组变量}
您可以将变量应用到父组（嵌套组或组的组）以及子组。语法相同：INI 格式使用 :vars，YAML 格式使用 vars: \par

在 INI 格式中：\par
\begin{verbatim}
[atlanta]
 host1
 host2

[raleigh]
 host2
 host3

[southeast:children]
 atlanta
 raleigh

[southeast:vars]
 some_server=foo.southeast.example.com
 halon_system_timeout=30
 self_destruct_countdown=60
 escape_pods=2

[usa:children]
 southeast
 northeast
 southwest
 northwest
\end{verbatim}
\par

在 YAML 格式中：\par
\begin{verbatim}
usa:
  children:
    southeast:
      children:
        atlanta:
          hosts:
            host1:
            host2:
        raleigh:
          hosts:
            host2:
            host3:
      vars:
        some_server: foo.southeast.example.com
        halon_system_timeout: 30
        self_destruct_countdown: 60
        escape_pods: 2
    northeast:
    northwest:
    southwest:
\end{verbatim}
\par

子组的变量具有更高的优先级（它们会覆盖）父组的变量。\par

\subsubsection{组织主机和组变量}
虽然您可以在清单源中定义变量，但也可以使用 Vars 插件定义变量的替代来源。\par

Ansible 附带的默认 vars 插件 host_group_vars 允许您使用单独的主机和组变量文件。这种方法可以帮助您更轻松地组织变量值。您还可以在这些文件中使用列表和哈希数据，这在主清单文件中是无法实现的。\par

对于 host_group_vars 插件，您的主机和组变量文件必须使用 YAML 语法。有效的文件扩展名是 '.yml'、'.yaml'、'.json' 或无文件扩展名。如果您不熟悉 YAML，请参阅 YAML 语法。\par

host_group_vars 插件通过搜索相对于清单源或 playbook 文件的路径来加载主机和组变量文件。如果您在 /etc/ansible/hosts 的清单文件中包含一个名为 'foosball' 的主机，该主机属于 raleigh 和 webservers 组，那么该主机将使用以下位置的 YAML 文件中的变量：\par
\begin{verbatim}
/etc/ansible/group_vars/raleigh # 可以选择以 '.yml'、'.yaml' 或 '.json' 结尾
/etc/ansible/group_vars/webservers
/etc/ansible/host_vars/foosball
\end{verbatim}
\par

例如，如果您在清单中按数据中心对主机进行分组，并且每个数据中心使用自己的 NTP 服务器和数据库服务器，您可以创建一个名为 /etc/ansible/group_vars/raleigh 的文件来存储 raleigh 组的变量：\par
\begin{verbatim}
---
ntp_server: acme.example.org
database_server: storage.example.org
\end{verbatim}
\par

您还可以创建以组名或主机名命名的目录。Ansible 按字典顺序读取这些目录中的所有文件。以下是 'raleigh' 组的示例：\par
\begin{verbatim}
/etc/ansible/group_vars/raleigh/db_settings
/etc/ansible/group_vars/raleigh/cluster_settings
\end{verbatim}
\par

'raleigh' 组中的所有主机都可以使用您在这些文件中定义的变量。当单个文件变得太大，或者您想在某些组变量上使用 Ansible Vault 时，这种方法对于保持变量的组织非常有用。\par

当您使用 ansible-playbook 时，Ansible 的 host_group_vars vars 插件还可以向您的 playbook 目录添加 group_vars/ 和 host_vars/ 目录。但是，并非所有 Ansible 命令都有 playbook（例如，ansible 或 ansible-console）。对于这些命令，您可以使用 --playbook-dir 选项在命令行上提供目录。如果您同时拥有相对于 playbook 目录和清单目录的 vars 插件源，Ansible 相对于 playbook 源的变量会覆盖相对于清单源的变量。\par

要跟踪对清单和变量定义的更改，请将清单源及其相关的变量目录和文件保存在 Git 仓库或其他版本控制系统中。\par

\subsubsection{变量如何合并}
\begin{notice}[note]
Ansible 根据一组规则合并来自不同来源的变量，并对某些变量应用优先级高于其他变量。例如，在清单中较高位置出现的变量可以覆盖清单中较低位置出现的变量。有关更多信息，请参阅变量优先级：我应该将变量放在哪里？
\end{notice}

在运行 play 之前，Ansible 会将变量合并并扁平化为特定主机的变量。此过程使 Ansible 专注于主机和任务，因此组不会在清单和主机匹配之外存在。默认情况下，Ansible 会覆盖变量，包括您为组或主机定义的变量（请参阅 DEFAULT_HASH_BEHAVIOUR）。\par

清单实体的顺序/优先级（从低到高）如下：\par

• all 组（因为它是所有其他组的“父”组）\par
• 父组\par
• 子组\par
• 主机\par

默认情况下，Ansible 按字母顺序合并同一父/子级别的组。Ansible 加载的最后一个组中的变量会覆盖之前组中的变量。例如，Ansible 合并 a_group 和 b_group，b_group 中的匹配变量会覆盖 a_group 中的变量。\par

您可以通过设置组变量 ansible_group_priority 来微调此合并行为。此变量会覆盖同一级别组的合并顺序的字母排序（在 Ansible 解析父/子顺序之后）。数字越大，Ansible 合并组的时间越晚，优先级越高。如果您不设置此变量，它默认为 1。例如：\par
\begin{verbatim}
a_group:
  vars:
    testvar: a
    ansible_group_priority: 10
b_group:
  vars:
    testvar: b
\end{verbatim}
\par

在此示例中，如果两个组具有相同的优先级，结果通常是 testvar == b。但是，因为我们给 a_group 更高的优先级，所以结果是 testvar == a。\par

您只能在清单源中设置 ansible_group_priority，不能在 group_vars/ 中设置。Ansible 在加载 group_vars/ 目录时使用此变量。\par

\subsubsection{管理清单变量加载顺序}
本节描述如何通过管理清单源的加载顺序来控制变量优先级。您可以在命令行中按特定顺序传递源，或在目录中使用源文件名的前缀。\par

当使用多个清单源时，请记住 Ansible 会根据变量如何合并和变量优先级：我应该将变量放在哪里？中描述的规则解决任何变量冲突。您可以控制清单源中变量的合并顺序，以获得所需的变量值。\par

当您在命令行中传递多个清单源时，Ansible 会按传递这些参数的顺序合并变量。如果 staging 清单中的 [all:vars] 部分定义了 myvar = 1，而 production 清单定义了 myvar = 2，那么以下结果是正确的：\par

• 如果您传递 -i staging -i production，Ansible 会以 myvar = 2 运行 playbook。\par
• 如果您传递 -i production -i staging，Ansible 会以 myvar = 1 运行 playbook。\par

当您将多个清单源放在目录中时，Ansible 会按文件名的字母顺序合并源。您可以通过在文件中添加前缀来控制加载顺序：\par
\begin{verbatim}
inventory/
  01-openstack.yml          # 配置清单插件以从 Openstack 云获取主机
  02-dynamic-inventory.py   # 使用动态清单脚本添加其他主机
  03-static-inventory       # 添加静态主机
  group_vars/
    all.yml                 # 为所有主机分配变量
\end{verbatim}
\par

如果 01-openstack.yml 为 all 组定义了 myvar = 1，02-dynamic-inventory.py 定义了 myvar = 2，而 03-static-inventory 定义了 myvar = 3，那么 Ansible 会以 myvar = 3 运行 playbook。\par

有关清单插件和动态清单脚本的更多详细信息，请参阅清单插件和使用动态清单。\par

\subsubsection{连接到主机：行为清单参数}
如上所述，您可以设置以下变量来控制 Ansible 如何与远程主机交互。\par

\textbf{主机连接：}\par
\begin{notice}[note]
当使用 ssh 连接插件（默认）时，Ansible 不会公开通道以允许用户和 ssh 进程之间的通信，以手动接受密码来解密 ssh 密钥。强烈建议使用 ssh-agent。
\end{notice}

\textbf{ansible\_connection}\par
指定到主机的连接类型。这可以是任何 Ansible 连接插件的名称。SSH 协议类型是 ssh 或 paramiko。默认是 ssh。\par

\textbf{所有连接通用：}\par

\textbf{ansible\_host}\par
指定要连接的主机的可解析名称或 IP（如果与您希望赋予它的别名不同）。永远不要将其设置为依赖于 inventory\_hostname。如果您确实需要类似的东西，请使用 inventory\_hostname\_short 以便它可以与委派一起使用。\par

\textbf{ansible\_port}\par
连接端口号（如果不是默认值，ssh 默认为 22）。\par

\textbf{ansible\_user}\par
连接（登录）到主机时使用的用户名。\par

\textbf{ansible\_password}\par
用于向主机进行身份验证的密码。（永远不要以明文形式存储此变量。始终使用保险库。请参阅安全地显示保险库变量。）\par

\textbf{特定于 SSH 连接插件：}\par

\textbf{ansible\_ssh\_private\_key\_file}\par
SSH 使用的私钥文件。如果您使用多个密钥并且不想使用 SSH 代理，这很有用。\par

\textbf{ansible\_ssh\_common\_args}\par
Ansible 始终将此设置附加到 sftp、scp 和 ssh 的默认命令行。这对于为特定主机或组配置 ProxyCommand 很有用。\par

\textbf{ansible\_sftp\_extra\_args}\par
Ansible 始终将此设置附加到默认的 sftp 命令行。\par

\textbf{ansible\_scp\_extra\_args}\par
Ansible 始终将此设置附加到默认的 scp 命令行。\par

\textbf{ansible\_ssh\_extra\_args}\par
Ansible 始终将此设置附加到默认的 ssh 命令行。\par

\textbf{ansible\_ssh\_pipelining}\par
指定是否使用 SSH 管道。这可以覆盖 ansible.cfg 中的管道设置。\par

\textbf{ansible\_ssh\_executable}（在版本 2.2 中添加）\par
此设置覆盖使用系统 ssh 的默认行为。它可以覆盖 ansible.cfg 的 ssh\_connection 部分中的 ssh\_executable 设置。\par

\textbf{权限提升}（有关更多详细信息，请参阅 Ansible 权限提升）：\par

\textbf{ansible\_become}\par
等同于 ansible\_sudo 或 ansible\_su；允许您强制权限提升。\par

\textbf{ansible\_become\_method}\par
允许您将权限提升方法设置为匹配的 become 插件。\par

\textbf{ansible\_become\_user}\par
等同于 ansible\_sudo\_user 或 ansible\_su\_user；允许您设置通过权限提升成为的用户。\par

\textbf{ansible\_become\_password}\par
等同于 ansible\_sudo\_password 或 ansible\_su\_password；允许您设置权限提升密码。（永远不要以明文形式存储此变量。始终使用保险库。请参阅安全地显示保险库变量。）\par

\textbf{ansible\_become\_exe}\par
等同于 ansible\_sudo\_exe 或 ansible\_su\_exe；允许您设置为所选提升方法的可执行文件。\par

\textbf{ansible\_become\_flags}\par
等同于 ansible\_sudo\_flags 或 ansible\_su\_flags；允许您设置传递给所选提升方法的标志。您还可以在 ansible.cfg 的 privilege\_escalation 下的 become\_flags 选项中全局设置此值。\par

\textbf{远程主机环境参数：}\par

\textbf{ansible\_shell\_type}\par
指定目标系统的 shell 类型。除非您将 ansible\_shell\_executable 设置为非 Bourne (sh) 兼容的 shell，否则不应使用此设置。默认情况下，Ansible 使用 sh 风格的语法格式化命令。如果您将其设置为 csh 或 fish，Ansible 在目标系统上执行的命令将遵循这些 shell 的语法。\par

\textbf{ansible\_python\_interpreter}\par
指定目标主机 Python 路径。这对于有多个 Python 的系统或 Python 不在 /usr/bin/python 的系统（如 *BSD）或 /usr/bin/python 不是 2.X 系列 Python 的系统很有用。我们不使用 /usr/bin/env 机制，因为这需要远程用户的路径设置正确，并且还假设 python 可执行文件名为 python，而可执行文件可能名为 python2.6 之类的名称。\par

\textbf{ansible\_*\_interpreter}\par
适用于任何语言，如 Ruby 或 Perl，并且工作方式与 ansible\_python\_interpreter 相同。此变量替换将在该主机上运行的模块的 shebang。\par

版本 2.1 中的新功能。\par

\textbf{ansible\_shell\_executable}\par
此设置设置 Ansible 控制节点将在目标机器上使用的 shell。它覆盖 ansible.cfg 中的 executable，默认为 /bin/sh。只有在无法使用 /bin/sh（换句话说，如果 /bin/sh 未安装在目标机器上或无法通过 sudo 运行）时，才应更改此值。\par

来自 Ansible-INI 主机文件的示例：\par
\begin{verbatim}
some_host         ansible_port=2222     ansible_user=manager
aws_host          ansible_ssh_private_key_file=/home/example/.ssh/aws.pem
freebsd_host      ansible_python_interpreter=/usr/local/bin/python
ruby_module_host  ansible_ruby_interpreter=/usr/bin/ruby.1.9.3
\end{verbatim}
\par

\textbf{非 SSH 连接类型}\par
如前一节所述，Ansible 默认通过 SSH 执行 playbook，但不限于这种连接类型。您可以使用主机特定参数 ansible_connection=<connection plugin name> 更改连接类型。有关可用插件和示例的完整列表，请参阅插件列表。\par

\subsubsection{清单设置示例}
另请参阅示例 Ansible 设置，其中显示了清单以及 playbook 和其他 Ansible 构件。\par

\textbf{示例：每个环境一个清单}\par
如果您需要管理多个环境，请考虑在每个清单中仅定义单个环境的主机。这样，例如，当您想要更新某些“staging”服务器时，就很难意外更改“test”环境中的节点状态。\par

对于上面提到的示例，您可以有一个 inventory_test 文件：\par
\begin{verbatim}
[dbservers]
db01.test.example.com
db02.test.example.com

[appservers]
app01.test.example.com
app02.test.example.com
app03.test.example.com
\end{verbatim}
\par

该文件仅包含属于“test”环境的主机。您可以在另一个名为 inventory_staging 的文件中定义“staging”机器：\par
\begin{verbatim}
[dbservers]
db01.staging.example.com
db02.staging.example.com

[appservers]
app01.staging.example.com
app02.staging.example.com
app03.staging.example.com
\end{verbatim}
\par

要将名为 site.yml 的 playbook 应用到测试环境中的所有应用服务器，请使用以下命令：\par
\begin{verbatim}
ansible-playbook -i inventory_test -l appservers site.yml
\end{verbatim}
\par

\textbf{示例：按功能分组}\par
在上一节中，您已经看到了使用组来集群具有相同功能的主机的示例。这种方法允许您，例如，在仅影响数据库服务器的 playbook 或角色中定义防火墙规则：\par
\begin{verbatim}
- hosts: dbservers
  tasks:
  - name: Allow access from 10.0.0.1
    ansible.builtin.iptables:
      chain: INPUT
      jump: ACCEPT
      source: 10.0.0.1
\end{verbatim}
\par

\textbf{示例：按位置分组}\par
其他任务可能会关注特定主机的位置。假设 db01.test.example.com 和 app01.test.example.com 位于 DC1，而 db02.test.example.com 位于 DC2：\par
\begin{verbatim}
[dc1]
db01.test.example.com
app01.test.example.com

[dc2]
db02.test.example.com
\end{verbatim}
\par

在实践中，您可能最终会混合使用所有这些设置。例如，您可能需要在某一天更新特定数据中心中的所有节点，而在另一天，您可能需要更新所有应用服务器，无论它们的位置如何。\par

\subsubsection{使用动态清单}
• 清单脚本示例：Cobbler\par
• 其他清单脚本\par
• 使用清单目录和多个清单源\par
• 动态组的静态组\par

如果您的 Ansible 清单随时间波动，主机根据业务需求启动和关闭，那么在如何构建清单中描述的静态清单解决方案将无法满足您的需求。您可能需要从多个来源跟踪主机：云提供商、LDAP、Cobbler 和/或企业 CMDB 系统。\par

Ansible 通过动态外部清单系统集成了所有这些选项。Ansible 支持两种连接外部清单的方式：清单插件和清单脚本。\par

清单插件利用了 Ansible Core 代码的最新更新。对于动态清单，我们推荐使用插件而不是脚本。您可以编写自己的插件来连接到其他动态清单源。\par

如果您选择，仍然可以使用清单脚本。当我们实现清单插件时，我们通过脚本清单插件确保了向后兼容性。下面的示例说明了如何使用清单脚本。\par

如果您更喜欢使用 GUI 来处理动态清单，AWX 或 Red Hat Ansible Automation Platform 上的清单数据库会与您的所有动态清单源同步，提供对结果的 Web 和 REST 访问，并提供图形化清单编辑器。通过所有主机的数据库记录，您可以关联过去的事件历史记录，并查看哪些主机在最后一次 playbook 运行中失败。\par

\textbf{清单脚本示例：Cobbler}\par
Ansible 与 Cobbler 无缝集成，Cobbler 是一个 Linux 安装服务器，最初由 Michael DeHaan 编写，现在由 James Cammarata 领导，他为 Ansible 工作。\par

虽然主要用于启动操作系统安装和管理 DHCP 和 DNS，但 Cobbler 有一个通用层，可以表示多个配置管理系统的数据（甚至同时）并作为“轻量级 CMDB”。\par

要将您的 Ansible 清单绑定到 Cobbler，请将此脚本复制到 /etc/ansible 并对文件执行 chmod +x。每次使用 Ansible 时运行 cobblerd，并使用 -i 命令行选项（例如，-i /etc/ansible/cobbler.py）通过 Cobbler 的 XMLRPC API 与 Cobbler 通信。\par

在 /etc/ansible 中添加 cobbler.ini 文件，以便 Ansible 知道 Cobbler 服务器在哪里，并且可以使用一些缓存改进。例如：\par
\begin{verbatim}
[cobbler]

# Set Cobbler's hostname or IP address
host = http://127.0.0.1/cobbler_api

# API calls to Cobbler can be slow. For this reason, we cache the results of an API
# call. Set this to the path you want cache files to be written to. Two files
# will be written to this directory:
#   - ansible-cobbler.cache
#   - ansible-cobbler.index

cache_path = /tmp

# The number of seconds a cache file is considered valid. After this many
# seconds, a new API call will be made, and the cache file will be updated.

cache_max_age = 900
\end{verbatim}
\par

首先通过直接运行 /etc/ansible/cobbler.py 来测试脚本。您应该看到一些 JSON 数据输出，但可能还没有任何内容。\par

让我们探索这是如何工作的。在 Cobbler 中，假设一个类似以下的场景：\par
\begin{verbatim}
cobbler profile add --name=webserver --distro=CentOS6-x86_64
cobbler profile edit --name=webserver --mgmt-classes="webserver" --ksmeta="a=2 b=3"
cobbler system edit --name=foo --dns-name="foo.example.com" --mgmt-classes="atlanta" --ksmeta="c=4"
cobbler system edit --name=bar --dns-name="bar.example.com" --mgmt-classes="atlanta" --ksmeta="c=5"
\end{verbatim}
\par

在上面的示例中，系统 'foo.example.com' 可以直接通过 ansible 寻址，但也可以在使用组名 'webserver' 或 'atlanta' 时寻址。由于 Ansible 使用 SSH，它仅通过 'foo.example.com' 联系系统 foo，而从不只是 'foo'。同样，如果您尝试 "ansible foo"，它不会找到系统... 但 "ansible 'foo*'" 会找到，因为系统 DNS 名称以 'foo' 开头。\par

该脚本提供的不仅仅是主机和组信息。此外，当运行 'setup' 模块时（使用 playbook 时会自动发生），变量 'a'、'b' 和 'c' 都会在模板中自动填充：\par
\begin{verbatim}
# file: /srv/motd.j2
Welcome, I am templated with a value of a={{ a }}, b={{ b }}, and c={{ c }}
\end{verbatim}
\par

可以这样执行：\par
\begin{verbatim}
ansible webserver -m setup
ansible webserver -m template -a "src=/tmp/motd.j2 dest=/etc/motd"
\end{verbatim}
\par

\begin{notice}[note]
名称 'webserver' 来自 Cobbler，配置文件的变量也是如此。您仍然可以像在 Ansible 中正常那样传递自己的变量，但来自外部清单脚本的变量会覆盖任何具有相同名称的变量。
\end{notice}

因此，使用上面的模板（motd.j2），这会导致以下数据被写入系统 'foo' 的 /etc/motd：\par
\begin{verbatim}
Welcome, I am templated with a value of a=2, b=3, and c=4
\end{verbatim}
\par

在系统 'bar'（bar.example.com）上：\par
\begin{verbatim}
Welcome, I am templated with a value of a=2, b=3, and c=5
\end{verbatim}
\par

从技术上讲，尽管没有什么好理由这样做，但这也有效：\par
\begin{verbatim}
ansible webserver -m ansible.builtin.shell -a "echo {{ a }}"
\end{verbatim}
\par

因此，换句话说，您也可以在参数/操作中使用这些变量。\par

\textbf{其他清单脚本}\par
在 Ansible 2.10 及更高版本中，清单脚本移至其关联的集合中。许多现在位于 ansible-community/contrib-scripts 存储库中。我们建议您改用清单插件。\par

\textbf{使用清单目录和多个清单源}\par
如果在 Ansible 中给 -i 的位置是目录（或在 ansible.cfg 中如此配置），Ansible 可以同时使用多个清单源。这样，就可以在同一个 ansible 运行中混合使用动态和静态管理的清单源。即时混合云！\par

在清单目录中，可执行文件被视为动态清单源，大多数其他文件被视为静态源。以下列任何内容结尾的文件会被忽略：\par
\begin{verbatim}
~, .orig, .bak, .ini, .cfg, .retry, .pyc, .pyo
\end{verbatim}
\par

您可以通过在 ansible.cfg 中配置 inventory_ignore_extensions 列表，或设置 ANSIBLE_INVENTORY_IGNORE 环境变量来替换此列表。在这两种情况下，值都必须是逗号分隔的模式列表，如上所示。\par

清单目录中的任何 group_vars 和 host_vars 子目录都按预期解释，使清单目录成为组织不同配置集的强大方式。有关更多信息，请参阅传递多个清单源。\par

\textbf{动态组的静态组}\par
在静态清单文件中定义组的组时，子组也必须在静态清单文件中定义，否则 ansible 会返回错误。如果要定义动态子组的静态组，请在静态清单文件中将动态组定义为空。例如：\par
\begin{verbatim}
[tag_Name_staging_foo]

[tag_Name_staging_bar]

[staging:children]
tag_Name_staging_foo
tag_Name_staging_bar
\end{verbatim}

\subsubsection{模式：定位主机和组}\n当您通过临时命令或运行 playbook 执行 Ansible 时，必须选择要执行的被管理节点或组。模式允许您在清单中针对特定主机和/或组运行命令和 playbook。Ansible 模式可以引用单个主机、IP 地址、清单组、一组组或清单中的所有主机。模式非常灵活 - 您可以排除或要求主机的子集，使用通配符或正则表达式等。Ansible 在模式中包含的所有清单主机上执行。\par

• 使用模式\par
• 常见模式\par
• 模式的限制\par
• 模式处理顺序\par
• 高级模式选项\par
  ◦ 在模式中使用变量\par
  ◦ 在模式中使用组位置\par
    ▪ 在特定项目处切片\par
    ▪ 使用起点和终点切片\par
  ◦ 在模式中使用正则表达式\par
• 模式和临时命令\par
• 模式和 ansible-playbook 标志\par

\textbf{使用模式}\par
几乎在执行临时命令或 playbook 的任何时候，您都会使用模式。模式是临时命令中唯一没有标志的元素。它通常是第二个元素：\par
\begin{verbatim}
ansible <pattern> -m <module_name> -a "<module options>"
\end{verbatim}
\par

例如：\par
\begin{verbatim}
ansible webservers -m service -a "name=httpd state=restarted"
\end{verbatim}
\par

在 playbook 中，模式是每个 play 的 hosts: 行的内容：\par
\begin{verbatim}
- name: <play_name>
  hosts: <pattern>
\end{verbatim}
\par

例如：\par
\begin{verbatim}
- name: restart webservers
  hosts: webservers
\end{verbatim}
\par

由于您经常希望一次对多个主机运行命令或 playbook，模式通常引用清单组。上面的临时命令和 playbook 都将在 webservers 组中的所有机器上执行。\par

\textbf{常见模式}\par
此表列出了用于定位清单主机和组的常见模式。\par

\begin{tabular}{|l|l|l|}
\hline
描述 & 模式 & 目标 \\ \hline
所有主机 & all (或 *) & 所有主机 \\ \hline
一个主机 & host1 & 单个主机 \\ \hline
多个主机 & host1:host2 (或 host1,host2) & 多个主机 \\ \hline
一个组 & webservers & 组中的所有主机 \\ \hline
多个组 & webservers:dbservers & webservers 中的所有主机加上 dbservers 中的所有主机 \\ \hline
排除组 & webservers:!atlanta & webservers 中的所有主机，除了 atlanta 中的主机 \\ \hline
组的交集 & webservers:&staging & 同时在 webservers 和 staging 中的任何主机 \\ \hline
\end{tabular}\par

\begin{notice}[note]
您可以使用逗号 (,) 或冒号 (:) 来分隔主机列表。在处理范围和 IPv6 地址时，逗号是首选。
\end{notice}

一旦您知道基本模式，就可以组合它们。这个例子：\par
\begin{verbatim}
webservers:dbservers:&staging:!phoenix
\end{verbatim}
\par

针对同时在 'webservers' 和 'dbservers' 组中且也在 'staging' 组中但不在 'phoenix' 组中的所有机器。\par

您可以对 FQDN 或 IP 地址使用通配符模式，只要主机在清单中按 FQDN 或 IP 地址命名：\par
\begin{verbatim}
192.0.*
*.example.com
*.com
\end{verbatim}
\par

您可以同时混合使用通配符模式和组：\par
\begin{verbatim}
one*.com:dbservers
\end{verbatim}
\par

\textbf{模式的限制}\par
模式依赖于清单。如果主机或组未在清单中列出，您就不能使用模式来定位它。如果您的模式包含未出现在清单中的 IP 地址或主机名，您将看到如下错误：\par
\begin{verbatim}
[WARNING]: No inventory was parsed, only implicit localhost is available
[WARNING]: Could not match supplied host pattern, ignoring: *.not_in_inventory.com
\end{verbatim}
\par

您的模式必须匹配清单语法。如果您将主机定义为别名：\par
\begin{verbatim}
atlanta:
  hosts:
    host1:
      http_port: 80
      maxRequestsPerChild: 808
      ansible_host: 127.0.0.2
\end{verbatim}
\par

您必须在模式中使用别名。在上面的示例中，您必须在模式中使用 host1。如果您使用 IP 地址，您将再次收到错误：\par
\begin{verbatim}
[WARNING]: Could not match supplied host pattern, ignoring: 127.0.0.2
\end{verbatim}
\par

\textbf{模式处理顺序}\par
处理有点特殊，按以下顺序进行：\par

1. : 和 ,\par
2. &\par
3. !\par

这种定位只考虑每个操作内部的处理顺序：a:b:&c:!d:!e == &c:a:!d:b:!e == !d:a:!e:&c:b\par

所有这些都导致以下结果：\par

主机在 (a 或 b) 中 AND 主机在 all(c) 中 AND 主机不在 all(d, e) 中。\par

现在 a:b:!e:!d:&c 略有变化，因为 !e 在 !d 之前处理，尽管这没有太大区别：\par

主机在 (a 或 b) 中 AND 主机在 all(c) 中 AND 主机不在 all(e, d) 中。\par

\textbf{高级模式选项}\par
上面描述的常见模式将满足您的大多数需求，但 Ansible 提供了其他几种方法来定义您要定位的主机和组。\par

\textbf{在模式中使用变量}\par
您可以使用变量通过 -e 参数向 ansible-playbook 传递组说明符：\par
\begin{verbatim}
webservers:!{{ excluded }}:&{{ required }}
\end{verbatim}
\par

\textbf{在模式中使用组位置}\par
您可以通过主机在组中的位置来定义主机或主机子集。例如，给定以下组：\par
\begin{verbatim}
[webservers]
cobweb
webbing
weber
\end{verbatim}
\par

您可以使用下标选择 webservers 组中的单个主机或范围。\par

\textbf{在特定项目处切片}\par
• 操作：s[i]\par
• 结果：s 的第 i 个项目，索引原点为 0\par

如果 i 为负数，则索引相对于序列 s 的末尾：使用 len(s) + i 代替。但是 -0 是 0。\par
\begin{verbatim}
webservers[0]       # == cobweb
webservers[-1]      # == weber
\end{verbatim}
\par

\textbf{使用起点和终点切片}\par
• 操作：s[i:j]\par
• 结果：s 从 i 到 j 的切片\par

从 i 到 j 的 s 切片定义为索引 k 满足 i <= k <= j 的项目序列。如果省略 i，则使用 0。如果省略 j，则使用 len(s)。省略 i 和 j 的切片会导致无效的主机模式。如果 i 大于 j，则切片为空。如果 i 等于 j，则替换为 s[i]。\par
\begin{verbatim}
webservers[0:2]     # == webservers[0],webservers[1],webservers[2]
                     # == cobweb,webbing,weber
webservers[1:2]     # == webservers[1],webservers[2]
                     # == webbing,weber
webservers[1:]      # == webbing,weber
webservers[:3]      # == cobweb,webbing,weber
\end{verbatim}
\par

\textbf{在模式中使用正则表达式}\par
您可以通过以 ~ 开头将模式指定为正则表达式：\par
\begin{verbatim}
~(web|db).*\.example\.com
\end{verbatim}
\par

\textbf{模式和临时命令}\par
您可以使用命令行选项更改临时命令中定义的模式的行为。您还可以使用 --limit 标志限制在特定运行中定位的主机。\par

• 限制到一个主机\par
\begin{verbatim}
$ ansible all -m <module> -a "<module options>" --limit "host1"
\end{verbatim}
\par

• 限制到多个主机\par
\begin{verbatim}
$ ansible all -m <module> -a "<module options>" --limit "host1,host2"
\end{verbatim}
\par

• 否定限制。请注意，必须使用单引号以防止 bash 插值。\par
\begin{verbatim}
$ ansible all -m <module> -a "<module options>" --limit 'all:!host1'
\end{verbatim}
\par

• 限制到主机组\par
\begin{verbatim}
$ ansible all -m <module> -a "<module options>" --limit 'group1'
\end{verbatim}
\par

\textbf{模式和 ansible-playbook 标志}\par
您可以使用命令行选项更改 playbook 中定义的模式的行为。例如，您可以通过指定 -i 127.0.0.2,（注意 trailing comma）在单个主机上运行定义了 hosts: all 的 playbook。即使您定位的主机未在清单中定义，这也有效，但此方法不会读取清单中与该主机相关的变量，playbook 所需的任何变量都需要在命令行上手动指定。\par

您还可以使用 --limit 标志限制在特定运行中定位的主机，这将引用您的清单：\par
\begin{verbatim}
ansible-playbook site.yml --limit datacenter2
\end{verbatim}
\par

最后，您可以使用 --limit 从文件中读取主机列表，方法是在文件名前加上 @：\par
\begin{verbatim}
ansible-playbook site.yml --limit @retry_hosts.txt
\end{verbatim}
\par

如果 RETRY_FILES_ENABLED 设置为 True，ansible-playbook 运行后会创建一个 .retry 文件，其中包含所有 play 中失败主机的列表。每次 ansible-playbook 运行完成时，此文件都会被覆盖。\par
\begin{verbatim}
ansible-playbook site.yml --limit @site.retry
\end{verbatim}
\par

要将您对模式的了解应用于 Ansible 命令和 playbook，请阅读临时命令简介和 Ansible playbook。\par

\subsubsection{连接方法和详细信息}\par
本节将向您展示如何扩展和完善 Ansible 用于清单的连接方法。\par

\textbf{ControlPersist 和 paramiko}\par
默认情况下，Ansible 使用原生 OpenSSH，因为它支持 ControlPersist（一种性能特性）、Kerberos 以及 ~/.ssh/config 中的选项，如 Jump Host 设置。如果您的控制机器使用不支持 ControlPersist 的旧版 OpenSSH，Ansible 将回退到称为 'paramiko' 的 Python 实现的 OpenSSH。\par

\textbf{设置远程用户}\par
默认情况下，Ansible 使用您在控制节点上使用的用户名连接到所有远程设备。如果该用户名在远程设备上不存在，您可以为连接设置不同的用户名。如果您只需要以不同用户身份执行某些任务，请查看了解权限提升：become。\par

您可以在 playbook 中设置连接用户：\par
\begin{verbatim}
---
- name: update webservers
  hosts: webservers
  remote_user: admin

  tasks:
  - name: thing to do first in this playbook

  # ...
\end{verbatim}
\par

作为清单中的主机变量：\par
\begin{verbatim}
other1.example.com     ansible_connection=ssh        ansible_user=myuser
other2.example.com     ansible_connection=ssh        ansible_user=myotheruser
\end{verbatim}
\par

或作为清单中的组变量：\par
\begin{verbatim}
cloud:
  hosts:
    cloud1: my_backup.cloud.com
    cloud2: my_backup2.cloud.com
  vars:
    ansible_user: admin
\end{verbatim}
\par

\begin{notice}[note]
\textbf{另请参阅}\
ssh – 通过 ssh 客户端二进制文件连接\par
关于 remote_user 关键字和 ansible_user 变量的详细信息。\par
控制 Ansible 的行为：优先级规则\par
关于 Ansible 优先级规则的详细信息。
\end{notice}

\textbf{设置 SSH 密钥}\par
默认情况下，Ansible 假设您使用 SSH 密钥连接到远程机器。SSH 密钥是推荐的，但如果需要，您可以使用 --ask-pass 选项使用密码认证。如果您需要为权限提升（sudo、pbrun 等）提供密码，请使用 --ask-become-pass。\par

\begin{notice}[note]
Ansible 不会公开一个通道来允许用户和 ssh 进程之间的通信，以便在使用 ssh 连接插件（默认）时手动接受密码来解密 ssh 密钥。强烈建议使用 ssh-agent。
\end{notice}

要设置 SSH agent 以避免重新输入密码，您可以执行：\par
\begin{verbatim}
$ ssh-agent bash
$ ssh-add ~/.ssh/id_rsa
\end{verbatim}
\par

根据您的设置，您可能希望使用 Ansible 的 --private-key 命令行选项来指定 pem 文件。您还可以添加私钥文件：\par
\begin{verbatim}
$ ssh-agent bash
$ ssh-add ~/.ssh/keypair.pem
\end{verbatim}
\par

另一种在不使用 ssh-agent 的情况下添加私钥文件的方法是在清单文件中使用 ansible_ssh_private_key_file，如这里所述：如何构建您的清单。\par

\textbf{在本地主机上运行}\par
您可以通过使用 "localhost" 或 "127.0.0.1" 作为服务器名称来在控制节点上运行命令：\par
\begin{verbatim}
$ ansible localhost -m ping -e 'ansible_python_interpreter="/usr/bin/env python"'
\end{verbatim}
\par

您可以通过在清单文件中添加以下内容来明确指定 localhost：\par
\begin{verbatim}
localhost ansible_connection=local ansible_python_interpreter="/usr/bin/env python"
\end{verbatim}
\par

\textbf{管理主机密钥检查}\par
Ansible 默认启用主机密钥检查。检查主机密钥可以防止服务器欺骗和中间人攻击，但确实需要一些维护。\par

如果主机被重新安装并且在 'known_hosts' 中有不同的密钥，这将导致错误消息，直到更正为止。如果新主机不在 'known_hosts' 中，您的控制节点可能会提示确认密钥，这会导致使用 Ansible 时的交互式体验，例如从 cron 运行。您可能不希望这样。\par

如果您了解其含义并希望禁用此行为，您可以通过编辑 /etc/ansible/ansible.cfg 或 ~/.ansible.cfg 来实现：\par
\begin{verbatim}
[defaults]
host_key_checking = False
\end{verbatim}
\par

或者，这可以通过 ANSIBLE_HOST_KEY_CHECKING 环境变量设置：\par
\begin{verbatim}
$ export ANSIBLE_HOST_KEY_CHECKING=False
\end{verbatim}
\par

另请注意，在 paramiko 模式下，主机密钥检查速度相当慢，因此在使用此功能时也建议切换到 'ssh'。\par

\textbf{其他连接方法}\par
Ansible 可以使用 SSH 以外的各种连接方法。您可以选择任何连接插件，包括在本地管理和管理 chroot、lxc 和 jail 容器。一种称为 'ansible-pull' 的模式还可以反转系统，让系统通过计划的 Git 签出 "电话回家"，从中央存储库中提取配置指令。\par

\subsubsection{使用 Ansible 命令行工具}\par
欢迎使用 Ansible 命令行工具指南。Ansible 提供了临时命令和多个实用程序，用于执行各种操作和自动化任务。\par

\textbf{使用命令行工具}\par
大多数用户都熟悉 ansible 和 ansible-playbook，但这些并不是 Ansible 提供的唯一实用程序。以下是 Ansible 实用程序的完整列表。每个页面都包含实用程序的描述和支持的参数列表。\par

\begin{notice}[note]
您不应针对相同的目标并行运行大多数 Ansible CLI 工具。
\end{notice}

• ansible\par
• ansible-config\par
• ansible-console\par
• ansible-doc\par
• ansible-galaxy\par
• ansible-inventory\par
• ansible-playbook\par
• ansible-pull\par
• ansible-vault\par

\textbf{ansible}\par
定义并在一组主机上运行单个任务 'playbook'\par

• 概要\par
• 描述\par
• 通用选项\par
• 环境\par
• 文件\par
• 作者\par
• 许可证\par
• 另请参阅\par

\textbf{概要}\par
\begin{verbatim}
usage: ansible [-h] [--version] [-v] [-b] [--become-method BECOME_METHOD]
             [--become-user BECOME_USER]
             [-K | --become-password-file BECOME_PASSWORD_FILE]
             [-i INVENTORY] [--list-hosts] [-l SUBSET] [--flush-cache]
             [-P POLL_INTERVAL] [-B SECONDS] [-o] [-t TREE]
             [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER]
             [-c CONNECTION] [-T TIMEOUT]
             [--ssh-common-args SSH_COMMON_ARGS]
             [--sftp-extra-args SFTP_EXTRA_ARGS]
             [--scp-extra-args SCP_EXTRA_ARGS]
             [--ssh-extra-args SSH_EXTRA_ARGS]
             [-k | --connection-password-file CONNECTION_PASSWORD_FILE] [-C]
             [-D] [-e EXTRA_VARS] [--vault-id VAULT_IDS]
             [-J | --vault-password-file VAULT_PASSWORD_FILES] [-f FORKS]
             [-M MODULE_PATH] [--playbook-dir BASEDIR]
             [--task-timeout TASK_TIMEOUT] [-a MODULE_ARGS] [-m MODULE_NAME]
             pattern
\end{verbatim}
\par

\textbf{描述}\par
是一个用于执行 '远程操作' 的超简单工具/框架/API。此命令允许您定义并在一组主机上运行单个任务 'playbook'\par

\textbf{通用选项}\par
\begin{verbatim}
--become-method <BECOME_METHOD>
privilege escalation method to use (default=sudo), use ansible-doc -t become -l to list valid choices.

--become-password-file <BECOME_PASSWORD_FILE>, --become-pass-file <BECOME_PASSWORD_FILE>
Become password file

--become-user <BECOME_USER>
run operations as this user (default=root)

--connection-password-file <CONNECTION_PASSWORD_FILE>, --conn-pass-file <CONNECTION_PASSWORD_FILE>
Connection password file

--flush-cache
clear the fact cache for every host in inventory

--list-hosts
outputs a list of matching hosts; does not execute anything else

--playbook-dir <BASEDIR>
Since this tool does not use playbooks, use this as a substitute playbook directory. This sets the relative path for many features including roles/ group_vars/ etc.

--private-key <PRIVATE_KEY_FILE>, --key-file <PRIVATE_KEY_FILE>
use this file to authenticate the connection

--scp-extra-args <SCP_EXTRA_ARGS>
specify extra arguments to pass to scp only (e.g. -l)

--sftp-extra-args <SFTP_EXTRA_ARGS>
specify extra arguments to pass to sftp only (e.g. -f, -l)

--ssh-common-args <SSH_COMMON_ARGS>
specify common arguments to pass to sftp/scp/ssh (e.g. ProxyCommand)

--ssh-extra-args <SSH_EXTRA_ARGS>
specify extra arguments to pass to ssh only (e.g. -R)

--task-timeout <TASK_TIMEOUT>
set task timeout limit in seconds, must be positive integer.

--vault-id
the vault identity to use. This argument may be specified multiple times.

--vault-password-file, --vault-pass-file
vault password file

--version
show program's version number, config file location, configured module search path, module location, executable location and exit

-B <SECONDS>, --background <SECONDS>
run asynchronously, failing after X seconds (default=N/A)

-C, --check
don't make any changes; instead, try to predict some of the changes that may occur

-D, --diff
when changing (small) files and templates, show the differences in those files; works great with --check

-J, --ask-vault-password, --ask-vault-pass
ask for vault password

-K, --ask-become-pass
ask for privilege escalation password

-M, --module-path
prepend colon-separated path(s) to module library (default={{ ANSIBLE_HOME ~ "/plugins/modules:/usr/share/ansible/plugins/modules" }}). This argument may be specified multiple times.

-P <POLL_INTERVAL>, --poll <POLL_INTERVAL>
set the poll interval if using -B (default=15)

-T <TIMEOUT>, --timeout <TIMEOUT>
override the connection timeout in seconds (default depends on connection)

-a <MODULE_ARGS>, --args <MODULE_ARGS>
The action's options in space separated k=v format: -a 'opt1=val1 opt2=val2' or a json string: -a '{"opt1": "val1", "opt2": "val2"}'

-b, --become
run operations with become (does not imply password prompting)

-c <CONNECTION>, --connection <CONNECTION>
connection type to use (default=ssh)

-e, --extra-vars
set additional variables as key=value or YAML/JSON, if filename prepend with @. This argument may be specified multiple times.

-f <FORKS>, --forks <FORKS>
specify number of parallel processes to use (default=5)

-h, --help
show this help message and exit

-i, --inventory, --inventory-file
specify inventory host path or comma separated host list. This argument may be specified multiple times.

-k, --ask-pass
ask for connection password

-l <SUBSET>, --limit <SUBSET>
further limit selected hosts to an additional pattern

-m <MODULE_NAME>, --module-name <MODULE_NAME>
Name of the action to execute (default=command)

-o, --one-line
condense output

-t <TREE>, --tree <TREE>
log output to this directory

-u <REMOTE_USER>, --user <REMOTE_USER>
connect as this user (default=None)

-v, --verbose
Causes Ansible to print more debug messages. Adding multiple -v will increase the verbosity, the builtin plugins currently evaluate up to -vvvvvv. A reasonable level to start is -vvv, connection debugging might require -vvvv. This argument may be specified multiple times.
\end{verbatim}
\par

\textbf{环境}\par
可以指定以下环境变量：\par

ANSIBLE_INVENTORY – 覆盖默认的 ansible 清单文件\par
ANSIBLE_LIBRARY – 覆盖默认的 ansible 模块库路径\par
ANSIBLE_CONFIG – 覆盖默认的 ansible 配置文件\par

ansible.cfg 中的大多数选项都有更多可用的环境变量。\par

\textbf{文件}\par
/etc/ansible/hosts – 默认清单文件\par
/etc/ansible/ansible.cfg – 配置文件，如果存在则使用\par
~/.ansible.cfg – 用户配置文件，如果存在则覆盖默认配置\par

\textbf{作者}\par
Ansible 最初由 Michael DeHaan 编写。\par

有关完整的贡献者列表，请参阅 AUTHORS 文件。\par

\textbf{许可证}\par
Ansible 以 GPLv3+ 许可证的条款发布。\par

\textbf{另请参阅}\par
ansible-config(1), ansible-console(1), ansible-doc(1), ansible-galaxy(1), ansible-inventory(1), ansible-playbook(1), ansible-pull(1), ansible-vault(1)\par

\subsubsection{临时命令简介}\par
Ansible 临时命令使用 /usr/bin/ansible 命令行工具在一个或多个被管理节点上自动化单个任务。临时命令快速且简单，但它们不可重用。那么为什么要学习临时命令呢？临时命令展示了 Ansible 的简单性和强大功能。您在这里学习的概念将直接移植到 playbook 语言中。在阅读和执行这些示例之前，请阅读如何构建您的清单。\par

• 为什么使用临时命令？\par
• 临时任务的使用场景\par
  ◦ 重启服务器\par
  ◦ 管理文件\par
  ◦ 管理软件包\par
  ◦ 管理用户和组\par
  ◦ 管理服务\par
  ◦ 收集事实\par
  ◦ 检查模式\par
  ◦ 模式和临时命令\par

\textbf{为什么使用临时命令？}\par
临时命令非常适合您很少重复的任务。例如，如果您想在圣诞节假期关闭实验室中的所有机器，您可以在 Ansible 中执行一个快速的单行命令，而无需编写 playbook。\par

临时命令如下所示：\par
\begin{verbatim}
$ ansible [pattern] -m [module] -a "[module options]"
\end{verbatim}
\par

-a 选项通过 key=value 语法或从 { 开始并以 } 结束的 JSON 字符串接受选项，以获得更复杂的选项结构。您可以在其他页面上了解有关模式和模块的更多信息。\par

\textbf{临时任务的使用场景}\par
临时任务可用于重启服务器、复制文件、管理软件包和用户等。您可以在临时任务中使用任何 Ansible 模块。临时任务与 playbook 一样，使用声明性模型，计算并执行达到指定最终状态所需的操作。它们通过在开始前检查当前状态并仅在当前状态与指定最终状态不同时执行操作来实现某种形式的幂等性。\par

\textbf{重启服务器}\par
ansible 命令行工具的默认模块是 ansible.builtin.command 模块。您可以使用临时任务调用 command 模块并重启亚特兰大的所有 Web 服务器，一次 10 个。在 Ansible 能够执行此操作之前，您必须在清单的名为 [atlanta] 的组中列出亚特兰大的所有服务器，并且必须对该组中的每台机器都有有效的 SSH 凭据。\par

要重启 [atlanta] 组中的所有服务器：\par
\begin{verbatim}
$ ansible atlanta -a "/sbin/reboot"
\end{verbatim}
\par

默认情况下，Ansible 仅使用五个并发进程。如果您的主机数量超过为 fork 计数设置的值，可能会增加 Ansible 与主机通信所需的时间。要使用 10 个并行 fork 重启 [atlanta] 服务器：\par
\begin{verbatim}
$ ansible atlanta -a "/sbin/reboot" -f 10
\end{verbatim}
\par

/usr/bin/ansible 默认将以您的用户帐户运行。要以不同用户身份连接：\par
\begin{verbatim}
$ ansible atlanta -a "/sbin/reboot" -f 10 -u username
\end{verbatim}
\par

重启可能需要权限提升。您可以以 username 身份连接到服务器并使用 become 关键字以 root 用户身份运行命令：\par
\begin{verbatim}
$ ansible atlanta -a "/sbin/reboot" -f 10 -u username --become [--ask-become-pass]
\end{verbatim}
\par

如果您添加 --ask-become-pass 或 -K，Ansible 会提示您输入用于权限提升的密码（sudo/su/pfexec/doas 等）。\par

\begin{notice}[note]
command 模块不支持管道和重定向等扩展 shell 语法（尽管 shell 变量始终有效）。如果您的命令需要特定于 shell 的语法，请改用 shell 模块。
\end{notice}

到目前为止，我们的所有示例都使用了默认的 'command' 模块。要使用不同的模块，请传递 -m 作为模块名称。例如，要使用 ansible.builtin.shell 模块：\par
\begin{verbatim}
$ ansible raleigh -m ansible.builtin.shell -a 'echo $TERM'
\end{verbatim}
\par

当使用 Ansible 临时 CLI（与 Playbooks 相对）运行任何命令时，请特别注意 shell 引用规则，以便本地 shell 保留变量并将其传递给 Ansible。例如，在上面的示例中使用双引号而不是单引号会在您所在的机器上评估变量。\par

\textbf{管理文件}\par
临时任务可以利用 Ansible 和 SCP 的功能将多个文件并行传输到多台机器。要将文件直接传输到 [atlanta] 组中的所有服务器：\par
\begin{verbatim}
$ ansible atlanta -m ansible.builtin.copy -a "src=/etc/hosts dest=/tmp/hosts"
\end{verbatim}
\par

如果您计划重复执行此类任务，请在 playbook 中使用 ansible.builtin.template 模块。\par

ansible.builtin.file 模块允许更改文件的所有权和权限。这些相同的选项也可以直接传递给 copy 模块：\par
\begin{verbatim}
$ ansible webservers -m ansible.builtin.file -a "dest=/srv/foo/a.txt mode=600"
$ ansible webservers -m ansible.builtin.file -a "dest=/srv/foo/b.txt mode=600 owner=mdehaan group=mdehaan"
\end{verbatim}
\par

file 模块还可以创建目录，类似于 mkdir -p：\par
\begin{verbatim}
$ ansible webservers -m ansible.builtin.file -a "dest=/path/to/c mode=755 owner=mdehaan group=mdehaan state=directory"
\end{verbatim}
\par

以及删除目录（递归）和删除文件：\par
\begin{verbatim}
$ ansible webservers -m ansible.builtin.file -a "dest=/path/to/c state=absent"
\end{verbatim}
\par

\textbf{管理软件包}\par
您还可以使用临时任务使用 yum 等软件包管理模块在被管理节点上安装、更新或删除软件包。软件包管理模块支持安装、删除和一般管理软件包的通用功能。由于某些特定于软件包管理器的功能不是通用软件包管理的一部分，因此可能不会在 Ansible 模块中提供。\par

要确保安装了软件包而不更新它：\par
\begin{verbatim}
$ ansible webservers -m ansible.builtin.yum -a "name=acme state=present"
\end{verbatim}
\par

要确保安装了特定版本的软件包：\par
\begin{verbatim}
$ ansible webservers -m ansible.builtin.yum -a "name=acme-1.5 state=present"
\end{verbatim}
\par

要确保软件包是最新版本：\par
\begin{verbatim}
$ ansible webservers -m ansible.builtin.yum -a "name=acme state=latest"
\end{verbatim}
\par

要确保软件包未安装：\par
\begin{verbatim}
$ ansible webservers -m ansible.builtin.yum -a "name=acme state=absent"
\end{verbatim}
\par

Ansible 有用于在许多平台下管理软件包的模块。如果没有适用于您的软件包管理器的模块，您可以使用 command 模块安装软件包或为您的软件包管理器创建模块。\par

\textbf{管理用户和组}\par
您可以使用临时任务在被管理节点上创建、管理和删除用户帐户：\par
\begin{verbatim}
$ ansible all -m ansible.builtin.user -a "name=foo password=<encrypted password here>"

$ ansible all -m ansible.builtin.user -a "name=foo state=absent"
\end{verbatim}
\par

有关所有可用选项的详细信息，包括如何操作组和组成员资格，请参阅 ansible.builtin.user 模块文档。\par

\textbf{管理服务}\par
确保所有 web 服务器上的服务已启动：\par
\begin{verbatim}
$ ansible webservers -m ansible.builtin.service -a "name=httpd state=started"
\end{verbatim}
\par

或者，在所有 web 服务器上重启服务：\par
\begin{verbatim}
$ ansible webservers -m ansible.builtin.service -a "name=httpd state=restarted"
\end{verbatim}
\par

确保服务已停止：\par
\begin{verbatim}
$ ansible webservers -m ansible.builtin.service -a "name=httpd state=stopped"
\end{verbatim}
\par

\textbf{收集事实}\par
事实表示关于系统的已发现变量。您可以使用事实实现任务的条件执行，也可以只是获取有关系统的临时信息。要查看所有事实：\par
\begin{verbatim}
$ ansible all -m ansible.builtin.setup
\end{verbatim}
\par

您还可以过滤此输出以仅显示某些事实，有关详细信息，请参阅 ansible.builtin.setup 模块文档。\par

\textbf{检查模式}\par
在检查模式下，Ansible 不会对远程系统进行任何更改。Ansible 仅打印命令。它不运行命令。\par
\begin{verbatim}
$ ansible all -m copy -a "content=foo dest=/root/bar.txt" -C
\end{verbatim}
\par

在上述命令中启用检查模式（-C 或 --check）意味着 Ansible 实际上不会在任何远程系统上创建或更新 /root/bar.txt 文件。\par

\textbf{模式和临时命令}\par
有关所有可用选项的详细信息，包括如何在临时命令中使用模式进行限制，请参阅模式文档。\par

现在您了解了 Ansible 执行的基本元素，您已经准备好学习使用 Ansible Playbooks 自动化重复任务。

\subsection{Playbooks}
它们包含 Plays（Ansible 执行的基本单位）。这既是一个“执行概念”，也是我们如何描述 ansible-playbook 操作的文件。\par

Playbooks 用 YAML 编写，易于阅读、编写、共享和理解。\par

\subsubsection{Plays}
Ansible 执行的主要上下文，此 playbook 对象将被管理节点（主机）映射到任务。Play 包含变量、角色和有序的任务列表，可以重复运行。它基本上由映射主机和任务的隐式循环组成，并定义了如何迭代它们。\par

\subsubsection{Roles}
可重用 Ansible 内容（任务、处理器、变量、插件、模板和文件）的有限分发，用于 Play 内部。\par

要使用任何 Role 资源，Role 本身必须导入到 Play 中。\par

\subsubsection{Tasks}
要应用于被管理主机的“操作”的定义。您可以使用 ansible 或 ansible-console（两者都创建虚拟 Play）通过临时命令执行单个任务一次。\par

\subsubsection{Handlers}
Task 的一种特殊形式，仅在由之前导致“changed”状态的任务通知时执行。\par

\subsection{模块}
Ansible 复制到每个被管理节点并在其上执行（必要时）以完成每个 Task 中定义的操作的代码或二进制文件。\par

每个模块都有特定用途，从管理特定类型数据库上的用户到管理特定类型网络设备上的 VLAN 接口。\par

您可以使用任务调用单个模块，或在 playbook 中调用多个不同的模块。Ansible 模块按集合分组。\par

\subsection{插件}
扩展 Ansible 核心功能的代码片段。插件可以控制您如何连接到被管理节点（连接插件）、操作数据（过滤插件），甚至控制在控制台中显示的内容（回调插件）。\par

\subsection{集合}
分发 Ansible 内容的格式，可以包含 playbooks、roles、modules 和 plugins。您可以通过 Ansible Galaxy 安装和使用集合。\par

集合资源可以相互独立和离散地使用。\par

\section{Ansible 的核心组件}
\subsection{Ansible 架构}
Ansible 采用无代理架构，主要由控制节点和被管理节点组成。控制节点运行 Ansible 命令，通过 SSH 协议与被管理节点通信，无需在被管理节点上安装额外的软件。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Images/ansible_inv_start.jpg}
    \caption{Ansible 架构图}
    \label{fig:ansible_architecture}
\end{figure}

如图所示，大多数 Ansible 环境都有三个主要核心组件：

\begin{enumerate}
\item \textbf{控制节点（Control Node）}\\
安装 Ansible 的系统，是执行 Ansible 命令的中心。\\
- 运行 Ansible 命令的机器（如 ansible 或 ansible-inventory）\\
- 需要安装 Ansible 软件\\
- 负责执行 Playbooks 和管理被管理节点\\
- 通常是 Linux 或 macOS 系统

\item \textbf{主机清单（Inventory）}\\
逻辑组织的被管理节点列表，用于描述主机部署情况。\\
- 主机清单文件，定义被管理节点的分组和属性\\
- 默认位于 `/etc/ansible/hosts`\\
- 支持静态和动态两种形式

\item \textbf{被管理节点（Managed Nodes）}\\
Ansible 控制的远程系统或主机。\\
- 被 Ansible 管理的服务器或设备\\
- 不需要安装 Ansible 软件\\
- 需要支持 SSH 协议（Linux/Unix）或 WinRM（Windows）
\end{enumerate}

除了以上三个核心组件外，Ansible 还包括以下重要组件：

\begin{enumerate}
\setcounter{enumi}{3}
\item \textbf{Playbooks}\\
Ansible 的配置、部署和编排语言。\\
- 使用 YAML 格式编写\\
- 包含一个或多个 Play

\item \textbf{Modules}\\
Ansible 执行具体任务的单元。\\
- 内置模块超过 3000 个\\
- 支持文件操作、包管理、服务管理等多种功能

\item \textbf{Plugins}\\
扩展 Ansible 核心功能的组件。\\
- 包括连接插件、缓存插件、过滤插件等\\
- 可以自定义开发

\item \textbf{Roles}\\
结构化组织 Playbooks 的方式。\\
- 便于代码重用和共享\\
- 符合特定目录结构规范

\item \textbf{Collections}\\
打包和分发 Ansible 内容的格式。\\
- 包含 roles、modules、plugins 等\\
- 可以从 Ansible Galaxy 下载
\end{enumerate}

\section{安装 Ansible}
Ansible 是一种无代理自动化工具，您可以将其安装在单个主机（称为控制节点）上。从控制节点，Ansible 可以通过 SSH、Powershell 远程管理以及许多其他传输方式远程管理整个机器和其他设备集群（称为被管理节点），所有操作都通过简单的命令行界面完成，无需数据库或守护进程。\par

\subsection{选择要安装的 Ansible 包和版本}
Ansible 的社区包有两种分发方式：\par
- \textbf{ansible-core}：一个极简的语言和运行时包，包含一组内置模块和插件。\par
- \textbf{ansible}：一个更大的“包含电池”的包，添加了社区策划的 Ansible 集合选择，用于自动化各种设备。\par

选择适合您需求的包。以下说明使用 ansible 作为包名，但如果您更喜欢从最小包开始并单独安装仅所需的 Ansible 集合，则可以替换为 ansible-core。\par

ansible 或 ansible-core 包可能在您的操作系统包管理器中可用，您可以自由使用首选方法安装这些包。有关更多信息，请参阅特定操作系统上安装 Ansible 的指南。这些安装说明仅涵盖使用 pip 安装 Python 包的官方支持方法。\par

Ansible 可以在多种操作系统上安装，以下是常见的安装方法：\par

\subsection{使用 pip 安装和升级 Ansible}
\paragraph{定位 Python}
定位并记住您希望用来运行 Ansible 的 Python 解释器的路径。以下说明将此 Python 称为 python3。例如，如果您确定要在 /usr/bin/python3.9 下的 Python 上安装 Ansible，请指定该路径而不是 python3。\par

\paragraph{确保 pip 可用}
要验证您首选的 Python 是否已安装 pip：\par
\begin{verbatim}
python3 -m pip -V
\end{verbatim}

如果一切正常，您应该看到类似以下内容：\par
\begin{verbatim}
python3 -m pip -V
pip 21.0.1 from /usr/lib/python3.9/site-packages/pip (python 3.9)
\end{verbatim}

如果是这样，pip 可用，您可以继续下一步。\par

如果您看到类似 "No module named pip" 的错误，则需要在继续之前在您选择的 Python 解释器下安装 pip。这可能意味着安装额外的 OS 包（例如 python3-pip），或通过运行以下命令直接从 Python Packaging Authority 安装最新的 pip：\par
\begin{verbatim}
curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
python3 get-pip.py --user
\end{verbatim}

在能够运行 Ansible 之前，您可能需要执行一些额外的配置。有关更多信息，请参阅 Python 文档中关于安装到用户站点的部分。\par

\paragraph{安装 Ansible}
在您选择的 Python 环境中使用 pip 为当前用户安装完整的 Ansible 包：\par
\begin{verbatim}
python3 -m pip install --user ansible
\end{verbatim}

您可以为当前用户安装最小的 ansible-core 包：\par
\begin{verbatim}
python3 -m pip install --user ansible-core
\end{verbatim}

或者，您可以安装特定版本的 ansible-core：\par
\begin{verbatim}
python3 -m pip install --user ansible-core==2.12.3
\end{verbatim}

\paragraph{升级 Ansible}
要将此 Python 环境中现有的 Ansible 安装升级到最新发布版本，只需在上面的命令中添加 --upgrade：\par
\begin{verbatim}
python3 -m pip install --upgrade --user ansible
\end{verbatim}

\subsection{使用 pipx 安装和升级 Ansible}
在某些系统上，由于操作系统开发人员的决定，可能无法使用 pip 安装 Ansible。在这种情况下，pipx 是一个广泛可用的替代方案。\par

**安装 Ansible：**\par
在您的环境中使用 pipx 安装完整的 Ansible 包：\par
\begin{verbatim}
pipx install --include-deps ansible
\end{verbatim}

您可以安装最小的 ansible-core 包：\par
\begin{verbatim}
pipx install ansible-core
\end{verbatim}

或者，您可以安装特定版本的 ansible-core：\par
\begin{verbatim}
pipx install ansible-core==2.12.3
\end{verbatim}

**升级 Ansible：**\par
要将现有的 Ansible 安装升级到最新发布版本：\par
\begin{verbatim}
pipx upgrade --include-injected ansible
\end{verbatim}

**安装额外的 Python 依赖项：**\par
要安装可能需要的其他 Python 依赖项，例如安装下面描述的 argcomplete Python 包：\par
\begin{verbatim}
pipx inject ansible argcomplete
\end{verbatim}

包含 --include-apps 选项，使其他 Python 依赖项中的应用程序在您的 PATH 上可用。这允许您从 shell 执行这些应用程序的命令。\par
\begin{verbatim}
pipx inject --include-apps ansible argcomplete
\end{verbatim}

如果您需要从 requirements 文件安装依赖项，例如在安装 Azure 集合时，您可以使用 runpip。\par
\begin{verbatim}
pipx runpip ansible install -r ~/.ansible/collections/ansible_collections/azure/azcollection/requirements.txt
\end{verbatim}

\subsection{在 macOS 上安装}
\begin{verbatim}
# 使用 Homebrew 安装
brew install ansible
\end{verbatim}

\subsection{在 Windows 上安装}
Windows 系统需要安装 Windows Subsystem for Linux (WSL)，然后在 WSL 中安装 Ansible。\par

**验证安装：**\par
\begin{verbatim}
# 检查 Ansible 版本
ansible --version
\end{verbatim}

\subsection{在特定操作系统上安装 Ansible}
\textbf{注意：}\par
这些说明来自各自的社区。如果您遇到错误或问题，请向该社区提交，以更新这些说明。Ansible 仅维护 pip 安装说明。\par

在大多数系统上，您始终可以使用 pip 从 PyPI 安装 ansible 包。社区还为各种 Linux 发行版打包和维护 Ansible。\par

本指南向您展示如何从不同的发行版包存储库安装 Ansible。\par

\subsubsection{添加新发行版的要求}
希望向本指南添加另一个发行版说明的包维护者必须满足以下要求：\par
- 确保发行版提供合理更新的 ansible 版本。\par
- 在构建系统允许的范围内保持 ansible-core 和 ansible 版本同步。\par
- 提供一种在说明中联系发行版维护者的方式。\par
- 还鼓励发行版维护者加入并监控 Ansible 打包 Matrix 聊天室。\par

\subsubsection{在 Fedora Linux 上安装 Ansible}
Fedora Linux 通过标准存储库提供完整的 Ansible 包和最小的 ansible-core 包。\par

安装完整的 ansible 包：\par
\begin{verbatim}
sudo dnf install ansible
\end{verbatim}

安装最小的 ansible-core 包：\par
\begin{verbatim}
sudo dnf install ansible-core
\end{verbatim}

Fedora 存储库包含几个作为独立包的 Ansible 集合，您可以与 ansible-core 一起安装。例如，安装 community.general 集合：\par
\begin{verbatim}
sudo dnf install ansible-collection-community-general
\end{verbatim}

请参阅 Fedora 包索引以获取 Fedora 中打包的 Ansible 集合的完整列表。\par

通过在 Red Hat Bugzilla 中针对 Fedora 产品提交错误来联系包维护者。\par

\subsubsection{从 EPEL 安装 Ansible}
如果您使用 CentOS Stream、Almalinux、Rocky Linux 或相关发行版，您可以从社区维护的 EPEL（Enterprise Linux 额外包）存储库安装 ansible 或 Ansible 集合：\par
1. 启用 EPEL 存储库。\par
2. 使用与 Fedora Linux 相同的 dnf 命令。\par

通过在 Red Hat Bugzilla 中针对 Fedora EPEL 产品提交错误来联系包维护者。\par

\subsubsection{在 OpenSUSE Tumbleweed/Leap 上安装 Ansible}
OpenSUSE 通过标准包管理器提供 Ansible 包。\par
\begin{verbatim}
sudo zypper install ansible
\end{verbatim}

请参阅 OpenSUSE 支持门户以获取有关在 OpenSUSE 上使用 Ansible 的额外帮助。\par

\subsubsection{在 Ubuntu 上安装 Ansible}
Ubuntu 通过个人包存档 (PPA) 提供 Ansible 包，其中包含比标准存储库更新的版本。\par

Ubuntu 构建可在此处的 PPA 中获得。\par

在您的系统上配置 PPA 并安装 Ansible：\par
\begin{verbatim}
sudo apt update
sudo apt install software-properties-common
sudo add-apt-repository --yes --update ppa:ansible/ansible
sudo apt install ansible
\end{verbatim}

\textbf{注意：}\par
在较旧的 Ubuntu 发行版上，"software-properties-common" 称为 "python-software-properties"。在较旧版本中，您可能希望使用 apt-get 而不是 apt。此外，只有较新的发行版（18.04、18.10 及更高版本）有 -u 或 --update 标志。根据需要调整您的脚本。\par

在 PPA 的问题跟踪器中提交任何问题。\par

\subsubsection{在 Debian 上安装 Ansible}
Debian 用户可以在标准存储库或 Ubuntu PPA 之间选择，以获取更新的版本。\par

虽然 Ansible 可从 Debian 主存储库获得，但此版本可能已过时。\par

对于更新的版本，Debian 用户可以根据下表使用 Ubuntu PPA：\par
\begin{table}[H]
    \centering
    \caption{Debian 与 Ubuntu 版本对应关系}
    \label{tab:debian-ubuntu}
    \begin{tabular}{ccc}
        \toprule
        Debian & Ubuntu & UBUNTUCODENAME \\
        \midrule
        Debian 13 (Trixie) & Ubuntu 24.04 (Noble) & noble \\
        Debian 12 (Bookworm) & Ubuntu 22.04 (Jammy) & jammy \\
        Debian 11 (Bullseye) & Ubuntu 20.04 (Focal) & focal \\
        Debian 10 (Buster) & Ubuntu 18.04 (Bionic) & bionic \\
        \bottomrule
    \end{tabular}
\end{table}

以下示例假设您已经安装了 wget 和 gpg。\par

添加存储库并安装 Ansible。根据上面的表格设置 UBUNTUCODENAME=...（在此示例中我们使用 jammy）：\par
\begin{verbatim}
UBUNTU_CODENAME=jammy
wget -O- "https://keyserver.ubuntu.com/pks/lookup?fingerprint=on&op=get&search=0x6125E2A8C77F2818FB7BD15B93C4A3FD7BB9C367" | sudo gpg --dearmour -o /usr/share/keyrings/ansible-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/ansible-archive-keyring.gpg] http://ppa.launchpad.net/ansible/ansible/ubuntu $UBUNTU_CODENAME main" | sudo tee /etc/apt/sources.list.d/ansible.list
sudo apt update && sudo apt install ansible
\end{verbatim}

\textbf{注意：}\par
像上面的示例一样，在 keyserver URL 和 "echo deb" 命令周围使用双引号。\par

这些命令下载签名密钥并向 apt 的源添加一个条目，指向 PPA。\par

以前，您可能使用过 apt-key add。出于安全原因，apt-key add 方法现在已被弃用（在 Debian、Ubuntu 和其他地方）。\par

因此，我们不会将密钥添加到 /etc/apt/trusted.gpg.d/ 或 /etc/apt/trusted.gpg，在那里密钥将被允许签署来自任何存储库的版本。\par

\subsubsection{在 Arch Linux 上安装 Ansible}
Arch Linux 通过标准包存储库提供完整的 Ansible 包和 ansible-core。\par

安装完整的 ansible 包：\par
\begin{verbatim}
sudo pacman -S ansible
\end{verbatim}

安装最小的 ansible-core 包：\par
\begin{verbatim}
sudo pacman -S ansible-core
\end{verbatim}

Arch Linux 存储库包含几个作为独立包的 Ansible 生态系统包，您可以与 ansible-core 一起安装。请参阅 Arch Linux 包索引以获取 Arch Linux 中 Ansible 包的完整列表。\par

通过在相关包的 GitLab 存储库中打开问题来联系包维护者。\par

\subsubsection{在 Windows 上安装 Ansible}
您不能将 Windows 系统用作 Ansible 控制节点。\par

\subsection{为开发目的安装 Ansible}
如果您正在测试新功能、修复错误或与开发团队合作修改核心代码，您可以从 GitHub 安装并运行源代码。\par

\textbf{注意：}\par
只有在修改 ansible-core 或尝试开发中的功能时，才应该安装并运行 devel 分支。这是一个快速变化的代码源，随时可能变得不稳定。\par

\subsubsection{使用 pip 从 GitHub 安装 devel 分支}
您可以使用 pip 直接从 GitHub 安装 ansible-core 的 devel 分支：\par
\begin{verbatim}
python3 -m pip install --user https://github.com/ansible/ansible/archive/devel.tar.gz
\end{verbatim}

您可以将上面 URL 中的 devel 替换为 GitHub 上的任何其他分支或标签，以安装旧版本的 Ansible、标记为 alpha 或 beta 的版本以及候选版本。\par

\subsubsection{从克隆运行 devel 分支}
ansible-core 很容易从源代码运行。您不需要 root 权限来使用它，也不需要实际安装任何软件。不需要守护进程或数据库设置。\par

1. 克隆 ansible-core 仓库\par
\begin{verbatim}
git clone https://github.com/ansible/ansible.git
cd ./ansible
\end{verbatim}

2. 设置 Ansible 环境\par

使用 Bash：\par
\begin{verbatim}
source ./hacking/env-setup
\end{verbatim}

使用 Fish：\par
\begin{verbatim}
source ./hacking/env-setup.fish
\end{verbatim}

要抑制杂散的警告/错误，请使用 -q：\par
\begin{verbatim}
source ./hacking/env-setup -q
\end{verbatim}

3. 安装 Python 依赖项\par
\begin{verbatim}
python3 -m pip install --user -r ./requirements.txt
\end{verbatim}

4. 在本地机器上更新 ansible-core 的 devel 分支\par
使用 pull-with-rebase 以便重放任何本地更改。\par
\begin{verbatim}
git pull --rebase
\end{verbatim}

\subsubsection{确认安装}
您可以通过检查版本来测试 Ansible 是否已正确安装：\par
\begin{verbatim}
ansible --version
\end{verbatim}

此命令显示的版本是已安装的关联 ansible-core 包的版本。\par

要检查已安装的 ansible 包的版本：\par
\begin{verbatim}
ansible-community --version
\end{verbatim}

\subsection{添加 Ansible 命令的 shell 补全}
您可以通过安装一个名为 argcomplete 的可选依赖项来添加 Ansible 命令行工具的 shell 补全。它支持 bash，并对 zsh 和 tcsh 有有限的支持。\par

\subsubsection{安装 argcomplete}\par
如果您选择了 pipx 安装说明：\par
\begin{verbatim}
pipx inject --include-apps ansible argcomplete
\end{verbatim}

如果您选择了 pip 安装说明：\par
\begin{verbatim}
python3 -m pip install --user argcomplete
\end{verbatim}

\subsubsection{配置 argcomplete}\par
有两种方法可以配置 argcomplete 以允许 Ansible 命令行工具的 shell 补全：全局或按命令。\par

\paragraph{全局配置}\par
全局补全需要 bash 4.2。\par
\begin{verbatim}
activate-global-python-argcomplete --user
\end{verbatim}

这将把 bash 补全文件写入用户位置。使用 --dest 更改位置或使用 sudo 全局设置补全。\par

\paragraph{按命令配置}\par
如果您没有 bash 4.2，则必须独立注册每个脚本。\par
\begin{verbatim}
eval $(register-python-argcomplete ansible)
eval $(register-python-argcomplete ansible-config)
eval $(register-python-argcomplete ansible-console)
eval $(register-python-argcomplete ansible-doc)
eval $(register-python-argcomplete ansible-galaxy)
eval $(register-python-argcomplete ansible-inventory)
eval $(register-python-argcomplete ansible-playbook)
eval $(register-python-argcomplete ansible-pull)
eval $(register-python-argcomplete ansible-vault)
\end{verbatim}

您应该将上述命令放入 shell 的配置文件中，例如 ~/.profile 或 ~/.bash_profile。\par

\paragraph{在 zsh 或 tcsh 中使用 argcomplete}

\section{配置 Ansible}
\subsection{配置文件}
Ansible 中的某些设置可以通过配置文件 (ansible.cfg) 进行调整。默认配置应该对大多数用户来说已经足够，但可能有一些原因需要更改它们。\par

配置文件搜索的路径在参考文档中列出。\par

\subsubsection{获取最新配置}
如果从包管理器安装 Ansible，最新的 ansible.cfg 文件应该存在于 /etc/ansible 中，在更新的情况下可能作为 .rpmnew 文件（或其他）存在。\par

如果您从 pip 或源代码安装 Ansible，您可能需要创建此文件以覆盖 Ansible 中的默认设置。\par

您可以生成一个 Ansible 配置文件 ansible.cfg，列出所有默认设置，如下所示：\par
\begin{verbatim}
ansible-config init --disabled > ansible.cfg
\end{verbatim}

包含可用插件以创建更完整的 Ansible 配置，如下所示：\par
\begin{verbatim}
ansible-config init --disabled -t all > ansible.cfg
\end{verbatim}

有关更多详细信息和可用配置的完整列表，请访问 configuration_settings。\par

您可以使用 ansible-config 命令行实用程序列出可用选项并检查当前值。\par

有关深入详细信息，请参阅 Ansible 配置设置。\par

\subsection{环境配置}
Ansible 还允许使用环境变量配置设置。\par

如果设置了这些环境变量，它们将覆盖从配置文件加载的任何相关设置。您可以从以下位置获取可用环境变量的完整列表：\par
- Ansible 配置设置：用于配置核心功能\par
- 所有集合环境变量索引：用于配置集合中的插件\par

\subsection{命令行选项}
并非所有配置选项都存在于命令行中，只有那些被认为最有用或最常见的选项。命令行中的设置将覆盖通过配置文件和环境传递的设置。\par

可用选项的完整列表在 ansible-playbook 和 ansible 中。\par

\section{Ansible 快速入门}

通过创建自动化项目、构建清单和创建"Hello World"playbook开始使用Ansible。\par

1. 安装Ansible。\par
\begin{verbatim}
pip install ansible
\end{verbatim}

2. 在文件系统上创建项目文件夹。\par
\begin{verbatim}
mkdir ansible_quickstart && cd ansible_quickstart
\end{verbatim}

使用单一目录结构可以更轻松地添加到源代码控制，以及重用和共享自动化内容。\par

\subsection{创建 Playbook}
Playbooks 是 YAML 格式的自动化蓝图，Ansible 使用它们来部署和配置被管理节点。\par

\textbf{Playbook}：定义 Ansible 执行操作顺序的 play 列表，从上到下，以实现整体目标。\par

\textbf{Play}：映射到清单中被管理节点的有序任务列表。\par

\textbf{Task}：对单个模块的引用，定义 Ansible 执行的操作。\par

\textbf{Module}：Ansible 在被管理节点上运行的代码或二进制单元。Ansible 模块按集合分组，每个模块都有一个完全限定的集合名称 (FQCN)。\par

完成以下步骤创建一个 playbook，用于 ping 您的主机并打印 "Hello world" 消息：\par

1. 在您之前创建的 ansible_quickstart 目录中创建一个名为 playbook.yaml 的文件，内容如下：\par
\begin{verbatim}
- name: My first play
  hosts: myhosts
  tasks:
    - name: Ping my hosts
      ansible.builtin.ping:

    - name: Print message
      ansible.builtin.debug:
        msg: Hello world
\end{verbatim}

2. 运行您的 playbook。\par
\begin{verbatim}
ansible-playbook -i inventory.ini playbook.yaml
\end{verbatim}

Ansible 返回以下输出：\par
\begin{verbatim}
PLAY [My first play] ****************************************************************************

TASK [Gathering Facts] **************************************************************************
ok: [192.0.2.50]
ok: [192.0.2.51]
ok: [192.0.2.52]

TASK [Ping my hosts] ****************************************************************************
ok: [192.0.2.50]
ok: [192.0.2.51]
ok: [192.0.2.52]

TASK [Print message] ****************************************************************************
ok: [192.0.2.50] => {
    "msg": "Hello world"
}
ok: [192.0.2.51] => {
    "msg": "Hello world"
}
ok: [192.0.2.52] => {
    "msg": "Hello world"
}

PLAY RECAP **************************************************************************************
192.0.2.50: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
192.0.2.51: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
192.0.2.52: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
\end{verbatim}

在此输出中，您可以看到：\par
- 您为 play 和每个任务指定的名称。您应该始终使用描述性名称，以便于验证和排查 playbook 问题。\par
- "Gathering Facts" 任务隐式运行。默认情况下，Ansible 收集有关清单的信息，可在 playbook 中使用。\par
- 每个任务的状态。每个任务的状态为 ok，表示运行成功。\par
- play recap 总结了每个主机上 playbook 中所有任务的结果。在此示例中，有三个任务，因此 ok=3 表示每个任务都运行成功。\par

\subsection{构建 Ansible 清单}

欢迎使用构建 Ansible 清单的指南。清单是 Ansible 部署和配置的被管理节点或主机的列表。本指南向您介绍清单，并涵盖以下主题：\par
- 创建清单来跟踪您想要自动化的服务器和设备列表。\par
- 使用动态清单来跟踪云服务中不断启动和停止的服务器和设备。\par
- 使用模式来自动化清单的特定子集。\par
- 扩展和改进 Ansible 用于清单的连接方法。\par

清单在集中式文件中组织被管理节点，为 Ansible 提供系统信息和网络位置。使用清单文件，Ansible 可以通过单个命令管理大量主机。\par

\subsubsection{如何构建您的清单}
Ansible 通过使用称为清单的列表或列表组来自动化您基础架构中的被管理节点或"主机"上的任务。Ansible 从一个或多个"清单源"组成其清单。虽然这些源之一可以是您在命令行传递的主机名列表，但大多数 Ansible 用户创建清单文件。\par

您的清单定义了您自动化的被管理节点以及与这些主机关联的变量。您还可以指定组。组允许您引用多个关联主机作为自动化目标或批量定义变量。一旦定义了清单，您就可以使用模式选择要 Ansible 运行的主机或组。\par

最简单的清单是包含主机和组列表的单个文件。此文件的默认位置是 /etc/ansible/hosts。您可以在命令行使用 -i <路径或表达式> 选项或使用配置系统指定不同的清单源。\par

Ansible 清单插件支持多种格式和来源，这使得您的清单灵活且可自定义。随着清单的扩展，您可能需要多个文件来组织您的主机和组。除了 /etc/ansible/hosts 文件之外，您还有以下常见选项：\par
- 您可以动态生成清单。例如，您可以使用清单插件列出一个或多个云提供商或其他源中的资源。\par
- 您可以使用多个清单源，包括动态清单和静态文件。\par
- 您可以创建包含多个清单源（静态或动态）的目录。\par

\subsubsection{清单基础：格式、主机和组}
您可以根据拥有的清单插件以多种格式创建清单文件。最常见的格式是 INI 和 YAML，因为 Ansible 包含对它们的内置支持。本介绍重点介绍这两种格式，但也可能有许多其他格式和来源。\par

基本的 INI 格式 /etc/ansible/hosts 可能如下所示：\par
\begin{verbatim}
mail.example.com

[webservers]
foo.example.com
bar.example.com

[dbservers]
one.example.com
two.example.com
three.example.com
\end{verbatim}

方括号中的标题是组名。您可以使用组名对主机进行分类，并决定在什么时间和什么目的控制哪些主机。组名应遵循与创建有效变量名相同的指南。\par

以下是相同基本清单文件的 YAML 格式：\par
\begin{verbatim}
ungrouped:
  hosts:
    mail.example.com:
webservers:
  hosts:
    foo.example.com:
    bar.example.com:
dbservers:
  hosts:
    one.example.com:
    two.example.com:
    three.example.com:
\end{verbatim}

\subsubsection{默认组}
即使您在清单中没有定义任何组，Ansible 也会创建两个默认组：all 和 ungrouped。all 组包含每个主机。ungrouped 组包含不属于任何其他组的所有主机。每个主机始终属于至少两个组（all 和 ungrouped，或 all 和另一个组）。例如，在上面的基本清单中，主机 mail.example.com 属于 all 和 ungrouped 组。主机 two.example.com 属于 all 和 dbservers 组。虽然 all 和 ungrouped 始终存在，但它们可能是隐式的，可能不会出现在 group_names 等组列表中。\par

\subsubsection{多个组中的主机}
您可以将主机放在多个组中。例如，您可以将亚特兰大数据中心中的生产 Web 服务器包含在 [prod]、[atlanta] 和 [webservers] 组中。您可以创建跟踪以下条件的组：\par
- **什么** - 应用程序、堆栈或微服务（例如，数据库服务器、Web 服务器等）。\par
- **哪里** - 数据中心或区域，用于与本地 DNS、存储等通信（例如，east、west）。\par
- **何时** - 开发阶段，以避免在生产资源上测试（例如，prod、test）。\par

以下示例扩展了之前的 YAML 清单，包括什么、何时和哪里：\par
\begin{verbatim}
ungrouped:
  hosts:
    mail.example.com:
webservers:
  hosts:
    foo.example.com:
    bar.example.com:
dbservers:
  hosts:
    one.example.com:
    two.example.com:
    three.example.com:
east:
  hosts:
    foo.example.com:
    one.example.com:
    two.example.com:
west:
  hosts:
    bar.example.com:
    three.example.com:
prod:
  hosts:
    foo.example.com:
    one.example.com:
    two.example.com:
test:
  hosts:
    bar.example.com:
    three.example.com:
\end{verbatim}

如示例所示，one.example.com 存在于 dbservers、east 和 prod 组中。\par

\subsubsection{组的分组：父子组关系}
您可以在组之间创建父子关系。父组也称为嵌套组或组的组。例如，如果所有生产主机已经在 atlanta_prod 和 denver_prod 等组中，您可以创建一个包含这些较小组的 production 组。这种方法减少了维护工作，因为您通过编辑子组来添加或删除父组中的主机。\par

要为组创建父子关系，请使用以下方法之一：\par
- 在 INI 格式中，使用 :children 后缀。\par
- 在 YAML 格式中，使用 children: 条目。\par

以下示例显示了与上面相同的清单，使用 prod 和 test 组的父组进行了简化：\par
\begin{verbatim}
ungrouped:
  hosts:
    mail.example.com:
webservers:
  hosts:
    foo.example.com:
    bar.example.com:
dbservers:
  hosts:
    one.example.com:
    two.example.com:
    three.example.com:
east:
  hosts:
    foo.example.com:
    one.example.com:
    two.example.com:
west:
  hosts:
    bar.example.com:
    three.example.com:
prod:
  children:
    east:
test:
  children:
    west:
\end{verbatim}

注意子组的以下属性：\par
- 任何属于子组成员的主机自动成为父组的成员。\par
- 一个组可以有多个父组和子组，但不能有循环关系。\par
- 主机可以在多个组中，但 Ansible 在运行时只处理主机的一个实例。Ansible 合并来自多个组的数据。\par
- 主机和组始终是"全局的"。如果您在不同的"分支"或"实例"下多次定义主机或组，主机或组仍然是同一个实体。多次定义主机或组要么向其添加新信息，要么用最新定义覆盖任何冲突信息。\par

\subsubsection{添加主机范围}
一些插件（如 YAML 和 INI）支持添加主机范围。如果您有许多具有相似模式的主机，您可以将主机添加为范围，而不是单独列出每个主机名：\par

**在 INI 中：**\par
\begin{verbatim}
[webservers]
www[01:50].example.com
\end{verbatim}

**在 YAML 中：**\par
\begin{verbatim}
# ...
  webservers:
    hosts:
      www[01:50].example.com:
\end{verbatim}

定义数字主机范围时，您可以指定步长（序列号之间的增量）：\par

**在 INI 中：**\par
\begin{verbatim}
[webservers]
www[01:50:2].example.com
\end{verbatim}

**在 YAML 中：**\par
\begin{verbatim}
# ...
  webservers:
    hosts:
      www[01:50:2].example.com:
\end{verbatim}

上面的示例匹配子域 www01、www03、www05、…、www49，但不匹配 www00、www02、www50 等，因为步长（增量）为每个步骤 2 个单位。\par

对于数字模式，您可以根据需要包含或删除前导零。范围是包含性的。您还可以定义字母范围：\par
\begin{verbatim}
[databases]
db-[a:f].example.com
\end{verbatim}

\subsubsection{传递多个清单源}
您可以同时针对多个清单源（静态文件、目录、动态清单脚本或清单插件支持的任何内容）。要执行此操作，请从命令行（见下文）或通过配置指定多个清单源，方法是设置 ANSIBLE_INVENTORY 或在 ansible.cfg (DEFAULT_HOST_LIST) 中。当您希望同时针对通常分开的环境（如暂存和生产）执行特定操作时，此功能非常有用。\par

要从命令行针对两个清单源：\par
\begin{verbatim}
ansible-playbook get_logs.yml -i staging -i production
\end{verbatim}

\subsubsection{在目录中组织清单}
您可以将多个清单源整合到单个目录中。这种方法的最简单版本是使用包含多个文件的目录，而不是单个清单文件。当文件变得太长时，维护单个文件会变得困难。如果您有多个团队和多个自动化项目，为每个团队或项目创建一个清单文件可以让每个人轻松找到对他们重要的主机和组。您还可以根据配置或调用 Ansible 的方式单独使用这些文件或使用其子集。\par

这些文件可以使用所有格式或插件配置（例如，YAML 或 INI）。在这种情况下，您的目录成为您的"单个"清单源，Ansible 会聚合它在该目录中找到的多个源。默认情况下，Ansible 会忽略某些目录和扩展名，但您可以在配置中更改此行为（INVENTORY_IGNORE_PATTERNS 和 INVENTORY_IGNORE_EXTS）。\par

您还可以在清单目录中组合多种清单源类型。此方法对于组合静态和动态主机并将它们作为一个清单进行管理非常有用。以下清单目录组合了清单插件源、动态清单脚本和包含静态主机的文件：\par
\begin{verbatim}
inventory/
  openstack.yml          # 配置清单插件以从 OpenStack 云获取主机
  dynamic-inventory.py   # 使用动态清单脚本添加其他主机
  on-prem                # 添加静态主机和组
  parent-groups          # 添加静态主机和组
\end{verbatim}

您可以按如下方式针对此清单目录：\par
\begin{verbatim}
ansible-playbook example.yml -i inventory
\end{verbatim}

您还可以在 ansible.cfg 文件中配置清单目录。有关更多详细信息，请参阅配置 Ansible。\par

Ansible 按字母排序顺序从上到下读取和加载目录中的文件。\par

\subsubsection{管理清单加载顺序}
Ansible 按照您提供的顺序加载清单源。它在遇到源文件时定义主机、组和变量，并在需要时在末尾添加 all 和 ungrouped 组。\par

根据您使用的清单插件，您可能需要重新排列源的顺序，以确保父/子定义的组或主机按照插件期望的方式存在。否则，您可能会遇到解析错误。例如，YAML 和 INI 清单插件在完成处理每个源时会丢弃空组（没有关联主机的组）。\par

如果您多次定义变量，Ansible 会覆盖先前的值。最后一个定义获胜。\par

要完成以下步骤，您需要至少一个主机系统的 IP 地址或完全限定域名 (FQDN)。出于演示目的，主机可以在容器或虚拟机中本地运行。您还必须确保将您的公共 SSH 密钥添加到每个主机上的 authorized_keys 文件中。\par

继续使用 Ansible 并按照以下步骤构建清单：\par

1. 在之前步骤中创建的 ansible_quickstart 目录中创建一个名为 inventory.ini 的文件。\par

2. 在 inventory.ini 文件中添加一个新的 [myhosts] 组，并指定每个主机系统的 IP 地址或完全限定域名 (FQDN)。\par
\begin{verbatim}
[myhosts]
192.0.2.50
192.0.2.51
192.0.2.52
\end{verbatim}

3. 验证您的清单。\par
\begin{verbatim}
ansible-inventory -i inventory.ini --list
\end{verbatim}

4. ping 清单中的 myhosts 组。\par
\begin{verbatim}
ansible myhosts -m ping -i inventory.ini
\end{verbatim}

\textbf{注意：}如果控制节点和被管理节点上的用户名不同，请在 ansible 命令中传递 -u 选项。\par

\begin{verbatim}
192.0.2.50 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}
192.0.2.51 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}
192.0.2.52 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}
\end{verbatim}

恭喜，您已成功构建了清单。\par

\subsection{INI 或 YAML 格式的清单}
您可以在 INI 文件或 YAML 中创建清单。在大多数情况下，例如前面步骤中的示例，对于少量被管理节点，INI 文件简单明了且易于阅读。\par

随着被管理节点数量的增加，以 YAML 格式创建清单成为一个合理的选择。例如，以下是 inventory.ini 的等效版本，它为被管理节点声明唯一名称并使用 ansible_host 字段：\par
\begin{verbatim}
myhosts:
  hosts:
    my_host_01:
      ansible_host: 192.0.2.50
    my_host_02:
      ansible_host: 192.0.2.51
    my_host_03:
      ansible_host: 192.0.2.52
\end{verbatim}

\subsection{构建清单的提示}
- 确保组名有意义且唯一。组名也是区分大小写的。\par
- 避免在组名中使用空格、连字符和前导数字（使用 floor_19，而不是 19th_floor）。\par
- 按逻辑将清单中的主机按其 What、Where 和 When 分组。\par

\textbf{What}：按拓扑分组主机，例如：db、web、leaf、spine。\par

\textbf{Where}：按地理位置分组主机，例如：datacenter、region、floor、building。\par

\textbf{When}：按阶段分组主机，例如：development、test、staging、production。\par

\subsubsection{使用元组}
使用以下语法创建一个元组，组织清单中的多个组：\par
\begin{verbatim}
metagroupname:
  children:
\end{verbatim}

以下清单展示了数据中心的基本结构。此示例清单包含一个包含所有网络设备的 network 元组和一个包含 network 组和所有 webservers 的 datacenter 元组。\par
\begin{verbatim}
leafs:
  hosts:
    leaf01:
      ansible_host: 192.0.2.100
    leaf02:
      ansible_host: 192.0.2.110

spines:
  hosts:
    spine01:
      ansible_host: 192.0.2.120
    spine02:
      ansible_host: 192.0.2.130

network:
  children:
    leafs:
    spines:

webservers:
  hosts:
    webserver01:
      ansible_host: 192.0.2.140
    webserver02:
      ansible_host: 192.0.2.150

datacenter:
  children:
    network:
    webservers:
\end{verbatim}

\subsubsection{创建变量}
变量为被管理节点设置值，例如 IP 地址、FQDN、操作系统和 SSH 用户，这样您在运行 Ansible 命令时就不需要传递它们。\par

变量可以应用于特定主机：\par
\begin{verbatim}
webservers:
  hosts:
    webserver01:
      ansible_host: 192.0.2.140
      http_port: 80
    webserver02:
      ansible_host: 192.0.2.150
      http_port: 443
\end{verbatim}

变量也可以应用于组中的所有主机：\par
\begin{verbatim}
webservers:
  hosts:
    webserver01:
      ansible_host: 192.0.2.140
      http_port: 80
    webserver02:
      ansible_host: 192.0.2.150
      http_port: 443
  vars:
    ansible_user: my_server_user
\end{verbatim}

\section{配置 Ansible 环境}
\subsection{配置文件}
Ansible 的配置文件按以下优先级加载：\par
1. `ANSIBLE\_CONFIG` 环境变量指定的文件
2. 当前目录下的 `ansible.cfg`
3. 用户主目录下的 `.ansible.cfg`
4. 系统级配置文件 `/etc/ansible/ansible.cfg`

**常用配置选项：**\par
\begin{verbatim}
[defaults]
# 主机清单文件位置
inventory = /path/to/hosts

# 默认远程用户
remote_user = ansible

# 私钥文件位置
private_key_file = ~/.ssh/id_rsa

# 主机密钥检查
host_key_checking = False

# 连接超时时间
timeout = 10

# 日志文件
log_path = /var/log/ansible.log
\end{verbatim}

\subsection{SSH 配置}
Ansible 使用 SSH 连接 Linux/Unix 主机，需要配置：\par
1. **SSH 密钥认证**（推荐）：
   \begin{verbatim}
   # 生成 SSH 密钥对
   ssh-keygen -t rsa -b 4096
   
   # 复制公钥到被管理节点
   ssh-copy-id user@hostname
   \end{verbatim}

2. **密码认证**（不推荐）：
   - 需要在 Inventory 中指定密码
   - 或使用 `--ask-pass` 参数

\subsection{权限设置}
被管理节点需要：\par
- 执行命令的权限（通常需要 sudo 权限）
- 对于非 root 用户，需要在 sudoers 文件中配置 NOPASSWD 权限

**示例 sudoers 配置：**\par
\begin{verbatim}
ansible ALL=(ALL) NOPASSWD: ALL
\end{verbatim}

\subsection{测试环境}
**测试 Ansible 连接：**\par
\begin{verbatim}
# 测试单个主机
ansible hostname -m ping

# 测试所有主机
ansible all -m ping
\end{verbatim}

**创建简单的 Playbook 测试：**\par
\begin{verbatim}
---
- name: Test Playbook
  hosts: all
  tasks:
    - name: Print message
      debug:
        msg: "Ansible is working!"
\end{verbatim}

通过以上步骤，您可以完成 Ansible 的安装和基本配置，为后续的自动化任务做好准备。

% 第三章 Inventory 管理
\chapter{Inventory 管理}
\section{Inventory 文件的基本格式}
Inventory 文件是 Ansible 用来定义被管理节点的配置文件，默认位于 `/etc/ansible/hosts`。它支持多种格式：\par

\subsection{INI 格式}
最常用的格式，使用分组和主机条目：\par
\begin{verbatim}
# 单个主机
server1.example.com

# 带端口的主机
server2.example.com:2222

# 使用主机名范围
web[1:5].example.com

# 分组定义
[webservers]
web1.example.com
web2.example.com

[databases]
db1.example.com
db2.example.com

# 嵌套分组
[production:children]
webservers
databases
\end{verbatim}

\subsection{YAML 格式}
更灵活的格式，支持更复杂的配置：\par
\begin{verbatim}
---
all:
  hosts:
    server1.example.com:
    server2.example.com:
  children:
    webservers:
      hosts:
        web1.example.com:
        web2.example.com:
    databases:
      hosts:
        db1.example.com:
        db2.example.com:
    production:
      children:
        webservers:
        databases:
\end{verbatim}

\subsection{主机别名}
为了方便管理，可以为主机设置别名：\par
\begin{verbatim}# INI 格式
[webservers]
web1 ansible_host=192.168.1.101 ansible_user=admin
web2 ansible_host=192.168.1.102 ansible_user=admin

# YAML 格式
webservers:
  hosts:
    web1:
      ansible_host: 192.168.1.101
      ansible_user: admin
    web2:
      ansible_host: 192.168.1.102
      ansible_user: admin
\end{verbatim}

\section{主机分组与变量}
\subsection{主机分组}
主机分组是 Inventory 的核心概念，它允许你：\par

1. **逻辑组织**：按功能、环境、地理位置等组织主机\par
2. **批量操作**：对整个分组执行任务\par
3. **继承属性**：子分组继承父分组的变量

**常见的分组策略**：\par
- 按功能：webservers, databases, loadbalancers\par
- 按环境：development, testing, production\par
- 按地理位置：us-east, us-west, eu-central\par
- 按硬件：physical, virtual, cloud

\subsection{变量定义}
Inventory 中的变量可以在不同级别定义：\par

**主机级变量**：\par
\begin{verbatim}
[webservers]
web1.example.com ansible_user=admin ansible_port=22
web2.example.com ansible_user=root ansible_port=2222
\end{verbatim}

**组级变量**：\par
\begin{verbatim}[webservers]
web1.example.com
web2.example.com

[webservers:vars]
ansible_user=admin
ansible_port=22
environment=production
\end{verbatim}

**YAML 格式的变量**：\par
\begin{verbatim}webservers:
  hosts:
    web1.example.com:
  vars:
    ansible_user: admin
    ansible_port: 22
    environment: production
\end{verbatim}

\subsection{变量文件}
对于复杂的配置，推荐使用单独的变量文件：\par

**目录结构**：\par
\begin{verbatim}inventory/
├── hosts.ini
└── group_vars/
    ├── all.yml
    ├── webservers.yml
    └── databases.yml
└── host_vars/
    ├── web1.example.com.yml
    └── db1.example.com.yml
\end{verbatim}

**变量优先级**（从高到低）：\par
1. 命令行参数 (`-e` 选项)\par
2. 角色默认变量\par
3. Inventory 主机变量\par
4. Inventory 组变量\par
5. 全局变量文件

\section{动态 Inventory}
对于动态环境（如云平台、容器集群），静态 Inventory 难以维护，此时需要使用动态 Inventory。\par

\subsection{工作原理}
动态 Inventory 通过脚本或插件从外部系统获取主机信息：\par
1. Ansible 调用 Inventory 脚本\par
2. 脚本查询外部系统（如 AWS API、OpenStack API）\par
3. 脚本返回 JSON 格式的主机信息\par
4. Ansible 使用这些信息执行任务

\subsection{内置插件}
Ansible 提供了多种云平台的动态 Inventory 插件：\par
- `aws_ec2`：AWS EC2 实例\par
- `azure_rm`：Azure 资源\par
- `gcp_compute`：Google Cloud 实例\par
- `openstack`：OpenStack 实例\par
- `kubernetes`：Kubernetes 集群

\subsection{使用 AWS EC2 插件示例}
**配置文件** (`inventory/aws_ec2.yml`)：\par
\begin{verbatim}---
plugin: aws_ec2
regions:
  - us-east-1
  - us-west-2
keyed_groups:
  - prefix: tag
    key: tags
  - prefix: instance_type
    key: instance_type
filters:
  instance-state-name: running
\end{verbatim}

**使用方法**：\par
\begin{verbatim}# 列出所有主机
ansible-inventory -i inventory/ --list

# 执行 Playbook
ansible-playbook -i inventory/ playbook.yml
\end{verbatim}

\subsection{自定义脚本}
对于特殊需求，可以编写自定义的动态 Inventory 脚本：\par

**脚本要求**：\par
- 可执行文件\par
- 支持 `--list` 和 `--host` 参数\par
- 返回有效的 JSON 格式

**示例脚本** (`inventory.py`)：\par
\begin{verbatim}
#!/usr/bin/env python3
import json
import sys

if len(sys.argv) == 2 and sys.argv[1] == '--list':
    inventory = {
        'webservers': {
            'hosts': ['web1.example.com', 'web2.example.com'],
            'vars': {
                'ansible_user': 'admin'
            }
        },
        'databases': {
            'hosts': ['db1.example.com'],
            'vars': {
                'ansible_user': 'root'
            }
        }
    }
    print(json.dumps(inventory))
elif len(sys.argv) == 3 and sys.argv[1] == '--host':
    print(json.dumps({}))
else:
    print(json.dumps({}))
\end{verbatim}

**使用方法**：\par
\begin{verbatim}# 赋予执行权限
chmod +x inventory.py

# 测试脚本
./inventory.py --list

# 使用脚本
ansible-playbook -i inventory.py playbook.yml
\end{verbatim}

动态 Inventory 极大地简化了云环境和动态基础设施的管理，是 Ansible 适应现代 IT 环境的重要特性。

% 第四章 Playbooks 与 Tasks
\chapter{Playbooks 与 Tasks}
\section{Playbooks 的基本结构}
Playbooks 是 Ansible 的核心配置和编排语言，使用 YAML 格式编写，用于定义和执行自动化任务。\par

\subsection{基本组成}
一个完整的 Playbook 由以下部分组成：\par

**1. Play**\par
Play 是 Playbook 的基本执行单位，定义了要在哪些主机上执行哪些任务：\par
\begin{verbatim}---
- name: Install and configure web server  # Play 的名称
  hosts: webservers                      # 目标主机或分组
  become: true                           # 是否提权
  vars:                                 # 变量定义
    http_port: 80
  tasks:                                # 任务列表
    - name: Install Apache
      yum:
        name: httpd
        state: present
    - name: Start Apache service
      service:
        name: httpd
        state: started
        enabled: true
\end{verbatim}

**2. 核心组件**\par
- `name`：Play 的描述性名称\par
- `hosts`：目标主机或主机组\par
- `become`：是否使用特权模式（sudo）\par
- `vars`：定义变量\par
- `tasks`：要执行的任务列表\par
- `handlers`：由任务通知触发的操作\par
- `roles`：要应用的角色\par
- `pre_tasks`/`post_tasks`：在主任务前后执行的任务\par
- `tags`：用于选择性执行任务的标签

\subsection{YAML 语法规范}
Playbooks 使用 YAML 语法，需要注意以下几点：\par

**1. 缩进**\par
- 使用空格进行缩进（推荐 2 或 4 个空格）\par
- 缩进级别表示层次结构\par
- 不要混合使用空格和制表符

**2. 列表和字典**\par
- 列表项以 `-` 开头：`- item1`\par
- 字典使用 `key: value` 格式\par
- 值可以是字符串、数字、布尔值、列表或字典

**3. 特殊字符**\par
- 包含特殊字符的字符串需要用引号括起来\par
- 多行字符串可以使用 `|`（保留换行）或 `>`（折叠换行）

**4. 注释**\par
- 使用 `#` 开头的行作为注释\par
- 注释不能放在值的后面

\subsection{完整示例}
以下是一个更完整的 Playbook 示例：\par
\begin{verbatim}---
- name: Configure web servers
  hosts: webservers
  become: true
  vars:
    web_package: httpd
    web_service: httpd
    firewall_service: firewalld
  pre_tasks:
    - name: Update package cache
      yum:
        update_cache: yes
      when: ansible_os_family == 'RedHat'
  tasks:
    - name: Install web server package
      package:
        name: "{{ web_package }}"
        state: present
    - name: Configure firewall
      firewalld:
        service: http
        permanent: yes
        state: enabled
      notify: restart firewall
    - name: Create index.html
      template:
        src: templates/index.html.j2
        dest: /var/www/html/index.html
      notify: restart web service
  handlers:
    - name: restart firewall
      service:
        name: "{{ firewall_service }}"
        state: restarted
    - name: restart web service
      service:
        name: "{{ web_service }}"
        state: restarted
  post_tasks:
    - name: Verify web service is running
      uri:
        url: http://localhost
        status_code: 200
      register: result
      until: result.status == 200
      retries: 5
      delay: 2
\end{verbatim}

\section{Tasks 的编写与执行}
\subsection{Task 的基本格式}
Task 是 Playbook 中最小的执行单元，定义了要执行的具体操作：\par

**基本格式**：\par
\begin{verbatim}- name: Task description  # Task 的名称
  module:               # 要使用的模块
    parameter1: value1   # 模块参数
    parameter2: value2
  when: condition        # 条件判断
  with_items: list       # 循环
  notify: handler_name   # 通知 handler
  tags: [tag1, tag2]     # 标签
\end{verbatim}

**示例**：\par
\begin{verbatim}- name: Create user
  user:
    name: john
    state: present
    groups: wheel
    shell: /bin/bash
  tags: user_management
\end{verbatim}

\subsection{常用模块}
Ansible 提供了丰富的内置模块，以下是一些常用模块：\par

**1. 文件操作**\par
- `copy`：复制文件到远程主机\par
- `file`：管理文件和目录属性\par
- `template`：使用模板生成文件\par
- `lineinfile`：修改文件中的特定行\par
- `blockinfile`：在文件中添加或修改块

**2. 包管理**\par
- `yum`/`dnf`：RedHat/CentOS 包管理\par
- `apt`：Debian/Ubuntu 包管理\par
- `pip`：Python 包管理\par
- `package`：通用包管理（自动检测系统）

**3. 服务管理**\par
- `service`：管理系统服务\par
- `systemd`：管理 systemd 服务

**4. 用户管理**\par
- `user`：管理用户账号\par
- `group`：管理用户组

**5. 命令执行**\par
- `command`：执行命令（不通过 shell）\par
- `shell`：执行 shell 命令\par
- `script`：在远程主机执行本地脚本

**6. 网络管理**\par
- `uri`：发送 HTTP 请求\par
- `ping`：测试主机连通性

**7. 云服务**\par
- `ec2`：管理 AWS EC2 实例\par
- `azure_rm_virtualmachine`：管理 Azure 虚拟机

\subsection{任务执行顺序}
Tasks 按以下顺序执行：\par
1. `pre_tasks` 部分的任务\par
2. 角色（`roles`）中的任务\par
3. `tasks` 部分的任务\par
4. 被通知的 `handlers`\par
5. `post_tasks` 部分的任务

\subsection{条件执行}
使用 `when` 语句可以根据条件执行任务：\par

**基本条件**：\par
\begin{verbatim}- name: Install Apache on RedHat
  yum:
    name: httpd
    state: present
  when: ansible_os_family == 'RedHat'

- name: Install Apache on Debian
  apt:
    name: apache2
    state: present
  when: ansible_os_family == 'Debian'
\end{verbatim}

**复杂条件**：\par
\begin{verbatim}- name: Configure production server
  template:
    src: templates/prod.conf.j2
    dest: /etc/app/prod.conf
  when:
    - inventory_hostname in groups['production']
    - ansible_memory_mb.real.total > 4096
\end{verbatim}

**常用条件操作符**：\par
- `==`：等于\par
- `!=`：不等于\par
- `>`/`<`/`>=`/`<=`：比较\par
- `in`：包含\par
- `not in`：不包含\par
- `and`/`or`/`not`：逻辑操作

\subsection{循环执行}
使用循环可以对列表中的每个项执行相同的任务：\par

**基本循环**：\par
\begin{verbatim}- name: Install multiple packages
  yum:
    name: "{{ item }}"
    state: present
  with_items:
    - httpd
    - mysql-server
    - php
\end{verbatim}

**字典循环**：\par
\begin{verbatim}- name: Create users
  user:
    name: "{{ item.name }}"
    groups: "{{ item.groups }}"
    state: present
  with_items:
    - { name: 'john', groups: 'wheel' }
    - { name: 'jane', groups: 'users' }
\end{verbatim}

**现代循环语法**（Ansible 2.5+）：\par
\begin{verbatim}- name: Install packages
  yum:
    name: "{{ item }}"
    state: present
  loop:
    - httpd
    - mysql-server
    - php
\end{verbatim}

**循环控制**：\par
\begin{verbatim}- name: Process items with loop control
  debug:
    msg: "Processing {{ item }}"
  loop:
    - item1
    - item2
    - item3
  loop_control:
    pause: 2  # 每次循环暂停 2 秒
    label: "{{ item }}"  # 循环标签
\end{verbatim}

\section{Handlers 与通知机制}
\subsection{Handlers 的定义}
Handlers 是一种特殊的任务，只有在被其他任务通知时才会执行：\par

**定义格式**：\par
\begin{verbatim}handlers:
  - name: handler name
    module:
      parameter1: value1
      parameter2: value2
    # 其他任务参数
\end{verbatim}

**示例**：\par
\begin{verbatim}handlers:
  - name: restart web service
    service:
      name: httpd
      state: restarted
  - name: reload nginx
    service:
      name: nginx
      state: reloaded
\end{verbatim}

\subsection{通知机制}
任务通过 `notify` 关键字通知 handler：\par

**基本用法**：\par
\begin{verbatim}- name: Update configuration file
  template:
    src: templates/httpd.conf.j2
    dest: /etc/httpd/conf/httpd.conf
  notify: restart web service

- name: Install new package
  yum:
    name: httpd
    state: latest
  notify:
    - restart web service
    - restart firewall
\end{verbatim}

**工作原理**：\par
1. 任务执行并发生变更\par
2. 任务通知 handler\par
3. 所有任务执行完成后\par
4. Ansible 执行被通知的 handler\par
5. 每个 handler 只会执行一次，即使被通知多次

\subsection{最佳实践}
**使用 handlers 的最佳实践**：\par

1. **只用于需要重启的操作**\par
   - 服务重启\par
   - 配置重载\par
   - 系统重启

2. **命名规范**\par
   - 使用动词开头：`restart service`、`reload configuration`\par
   - 名称要清晰明确

3. **集中管理**\par
   - 将相关的 handlers 放在一起\par
   - 对于复杂的 Playbook，可以使用单独的 handlers 文件

4. **条件 handlers**\par
   - 可以在 handlers 中使用 `when` 条件\par
   \begin{verbatim}   handlers:
     - name: restart web service
       service:
         name: httpd
         state: restarted
       when: ansible_os_family == 'RedHat'
   ```

5. **使用变量**\par
   - 在 handlers 中使用变量提高可重用性\par
   ```yaml
   handlers:
     - name: restart service
       service:
         name: "{{ service_name }}"
         state: restarted
   ```

Handlers 机制使得配置变更和服务重启更加有序和高效，是 Ansible 自动化中的重要特性。

% 第五章 变量与 Facts
\chapter{变量与 Facts}
\section{变量的定义与使用}
变量是 Ansible 中存储值的容器，用于在 Playbooks 中传递数据、配置参数和控制逻辑。\par

\subsection{变量的定义方法}
\subsubsection{1. 在 Playbook 中定义}
\end{verbatim}yaml
---
- name: Example Playbook
  hosts: all
  vars:
    http_port: 80
    db_name: "myapp"
    debug_mode: false
  tasks:
    - name: Print variables
      debug:
        msg: "Port: {{ http_port }}, DB: {{ db_name }}, Debug: {{ debug_mode }}"
\begin{verbatim}
\subsubsection{2. 在 Inventory 中定义}
**INI 格式**：\par
\end{verbatim}ini
[webservers]
web1.example.com http_port=8080 env=production
web2.example.com http_port=8081 env=staging

[webservers:vars]
ansible_user=admin
\begin{verbatim}
**YAML 格式**：\par
\end{verbatim}yaml
webservers:
  hosts:
    web1.example.com:
      http_port: 8080
      env: production
    web2.example.com:
      http_port: 8081
      env: staging
  vars:
    ansible_user: admin
\begin{verbatim}
\subsubsection{3. 使用变量文件}
**group_vars 文件** (`group_vars/webservers.yml`)：\par
\end{verbatim}yaml
---
http_port: 80
app_name: "mywebapp"
environment: production
\begin{verbatim}
**host_vars 文件** (`host_vars/web1.example.com.yml`)：\par
\end{verbatim}yaml
---
custom_port: 8080
specific_config: "web1-only"
\begin{verbatim}
\subsubsection{4. 命令行传递}
使用 `-e` 或 `--extra-vars` 选项：\par
\end{verbatim}bash
ansible-playbook playbook.yml -e "http_port=8080 env=production"

# 使用 JSON 格式
ansible-playbook playbook.yml -e '{"http_port": 8080, "env": "production"}'

# 从文件读取
ansible-playbook playbook.yml -e @vars_file.yml
\begin{verbatim}
\subsubsection{5. 角色默认变量}
在角色的 `defaults/main.yml` 文件中定义：\par
\end{verbatim}yaml
---
# 默认变量，优先级较低
http_port: 80
db_port: 3306
debug: false
\begin{verbatim}
\subsection{变量的使用方式}
\subsubsection{1. 基本用法}
在任务中使用变量：\par
\end{verbatim}yaml
- name: Configure web server
  template:
    src: templates/httpd.conf.j2
    dest: /etc/httpd/conf/httpd.conf

- name: Create database
  mysql_db:
    name: "{{ db_name }}"
    state: present
\begin{verbatim}
\subsubsection{2. 在模板中使用}
Jinja2 模板文件 (`templates/httpd.conf.j2`)：\par
\end{verbatim}conf
Listen {{ http_port }}
ServerName {{ inventory_hostname }}

{% if debug_mode %}
LogLevel debug
{% else %}
LogLevel warn
{% endif %}
\begin{verbatim}
\subsubsection{3. 变量过滤器}
使用过滤器修改变量值：\par
\end{verbatim}yaml
- name: Use filters
  debug:
    msg:
      - "Upper case: {{ app_name | upper }}"
      - "Lower case: {{ app_name | lower }}"
      - "Default value: {{ undefined_var | default('default') }}"
      - "Length: {{ app_name | length }}"
      - "Joined: {{ ['a', 'b', 'c'] | join(', ') }}"
\begin{verbatim}
\subsubsection{4. 变量注册}
使用 `register` 关键字捕获任务输出：\par
\end{verbatim}yaml
- name: Get disk usage
  shell: df -h
  register: disk_info

- name: Print disk usage
  debug:
    var: disk_info.stdout

- name: Check if disk is full
  debug:
    msg: "Disk is full!"
  when: "'100%' in disk_info.stdout"
\begin{verbatim}
\section{Facts 的收集与应用}
\subsection{Facts 的概念}
Facts 是 Ansible 自动收集的关于被管理节点的信息，包括：\par
- 主机名、IP 地址、操作系统信息\par
- 硬件配置（CPU、内存、磁盘）\par
- 网络配置、环境变量\par
- 已安装的软件包\par
- 自定义 facts

\subsection{查看 Facts}
**使用 setup 模块**：\par
\end{verbatim}bash
# 查看所有 facts
ansible host1 -m setup

# 查看特定 fact
ansible host1 -m setup -a "filter=ansible_os_family"

# 查看网络相关 facts
ansible host1 -m setup -a "filter=ansible_eth*"
\begin{verbatim}
**在 Playbook 中查看**：\par
\end{verbatim}yaml
- name: Print all facts
  debug:
    var: ansible_facts

- name: Print specific facts
  debug:
    msg:
      - "Hostname: {{ ansible_facts.hostname }}"
      - "OS: {{ ansible_facts.distribution }} {{ ansible_facts.distribution_version }}"
      - "Memory: {{ ansible_facts.memory_mb.real.total }} MB"
\begin{verbatim}
\subsection{在 Playbook 中使用 Facts}
**1. 条件判断**：\par
\end{verbatim}yaml
- name: Install Apache on RedHat
  yum:
    name: httpd
    state: present
  when: ansible_facts.os_family == 'RedHat'

- name: Install Apache on Debian
  apt:
    name: apache2
    state: present
  when: ansible_facts.os_family == 'Debian'
\begin{verbatim}
**2. 模板配置**：\par
\end{verbatim}jinja2
# templates/motd.j2
Welcome to {{ ansible_facts.hostname }}

System Information:
- OS: {{ ansible_facts.distribution }} {{ ansible_facts.distribution_version }}
- Kernel: {{ ansible_facts.kernel }}
- CPU: {{ ansible_facts.processor_count }} cores
- Memory: {{ ansible_facts.memory_mb.real.total }} MB
- IP Address: {{ ansible_facts.default_ipv4.address }}
\begin{verbatim}
**3. 动态配置**：\par
\end{verbatim}yaml
- name: Configure based on memory
  template:
    src: "templates/{{ 'high_mem' if ansible_facts.memory_mb.real.total > 8192 else 'low_mem' }}.j2"
    dest: /etc/app/config.conf
\begin{verbatim}
\subsection{自定义 Facts}
\subsubsection{1. 静态自定义 Facts}
在被管理节点上创建 Facts.d 目录和文件：\par

**创建目录**：\par
\end{verbatim}bash
mkdir -p /etc/ansible/facts.d
\begin{verbatim}
**创建 Facts 文件** (`/etc/ansible/facts.d/custom.fact`)：\par
\end{verbatim}ini
[app]
version=1.2.3
environment=production

[database]
host=db.example.com
port=3306
\begin{verbatim}
**使用自定义 Facts**：\par
\end{verbatim}yaml
- name: Use custom facts
  debug:
    msg: "App version: {{ ansible_facts.ansible_local.custom.app.version }}"
\begin{verbatim}
\subsubsection{2. 动态自定义 Facts}
使用脚本生成 Facts：\par

**创建脚本** (`/etc/ansible/facts.d/custom.fact`)：\par
\end{verbatim}bash
#!/bin/bash
cat << EOF
{
  "app": {
    "version": "$(cat /opt/app/version.txt)",
    "status": "$(systemctl is-active myapp)"
  }
}
EOF
\begin{verbatim}
**赋予执行权限**：\par
\end{verbatim}bash
chmod +x /etc/ansible/facts.d/custom.fact
\begin{verbatim}
\subsection{禁用 Facts 收集}
对于大型环境，可以禁用 Facts 收集以提高性能：\par

**在 Playbook 中禁用**：\par
\end{verbatim}yaml
---
- name: Playbook without facts
  hosts: all
  gather_facts: false
  tasks:
    - name: Print message
      debug:
        msg: "No facts gathered"
\begin{verbatim}
**按需收集 Facts**：\par
\end{verbatim}yaml
---
- name: Playbook with selective facts
  hosts: all
  gather_facts: false
  tasks:
    - name: Gather only network facts
      setup:
        gather_subset:
          - network
    - name: Use network facts
      debug:
        msg: "IP: {{ ansible_facts.default_ipv4.address }}"
\begin{verbatim}
\section{变量优先级与作用域}
\subsection{变量优先级}
Ansible 变量按以下优先级排序（从高到低）：\par

1. **命令行变量** (`-e` 选项)\par
2. **set_fact 模块设置的变量**\par
3. **playbook 中的 vars_prompt 变量**\par
4. **playbook 中的 vars_files 变量**\par
5. **playbook 中的 vars 部分变量**\par
6. **角色中的 vars 目录变量**\par
7. **主机变量** (host_vars/)\par
8. **组变量** (group_vars/)\par
9. **Inventory 中的变量**\par
10. **角色默认变量** (defaults/)\par
11. **Ansible 内置变量**\par
12. **Facts**

\subsection{变量作用域}
\subsubsection{1. 全局作用域}
- 在所有 Play 和任务中可用\par
- 包括命令行变量、Inventory 变量\par
- 使用 `set_fact` 设置的变量

\subsubsection{2. Play 作用域}
- 在单个 Play 中可用\par
- 包括 Play 中定义的 vars\par
- 对该 Play 中的所有任务和角色可见

\subsubsection{3. 任务作用域}
- 仅在单个任务中可用\par
- 包括任务的 register 变量\par
- 可以通过 `delegate_to` 在不同主机间传递

\subsubsection{4. 角色作用域}
- 在角色内部可用\par
- 包括角色的 defaults 和 vars\par
- 角色间默认隔离，需要通过参数传递

\subsection{优先级示例}
**目录结构**：\par
\end{verbatim}
playbook.yml
group_vars/
└── all.yml          # db_port: 3306
roles/
└── mysql/
    ├── defaults/
    │   └── main.yml  # db_port: 3307 (低优先级)
    └── vars/
        └── main.yml  # db_port: 3308 (高优先级)
host_vars/
└── db1.yml          # db_port: 3309
\begin{verbatim}
**playbook.yml**：\par
\end{verbatim}yaml
---
- name: Test variable priority
  hosts: db1
  vars:
    db_port: 3310  # 比 roles/vars 优先级高
  roles:
    - mysql
  tasks:
    - name: Print db_port
      debug:
        var: db_port
    - name: Override with set_fact
      set_fact:
        db_port: 3311  # 比 play vars 优先级高
    - name: Print db_port again
      debug:
        var: db_port
\begin{verbatim}
**命令行执行**：\par
\end{verbatim}bash
# 最终 db_port 将是 3312
ansible-playbook playbook.yml -e "db_port=3312"
\begin{verbatim}
\subsection{最佳实践}
**变量管理的最佳实践**：\par

1. **命名规范**\par
   - 使用小写字母和下划线\par
   - 避免使用特殊字符\par
   - 名称要描述性且一致

2. **变量组织**\par
   - 使用 `group_vars` 和 `host_vars` 目录\par
   - 为不同环境使用不同的变量文件\par
   - 使用目录结构组织复杂变量

3. **默认值设置**\par
   - 在角色的 `defaults` 中设置默认值\par
   - 使用 `default()` 过滤器提供回退值\par
   - 避免硬编码值

4. **敏感变量处理**\par
   - 使用 `ansible-vault` 加密敏感变量\par
   - 避免在版本控制系统中存储密码\par
   - 考虑使用外部密钥管理系统

5. **变量文档**\par
   - 为复杂变量提供注释\par
   - 维护变量字典文档\par
   - 使用一致的变量命名模式

通过合理的变量管理，可以使 Playbooks 更加灵活、可维护，并且更容易适应不同的环境和需求。

% 第六章 模板与文件
\chapter{模板与文件}
\section{Jinja2 模板的使用}
Jinja2 是 Ansible 使用的模板引擎，用于生成动态配置文件、脚本和其他文本文件。它基于 Python，提供了强大的模板功能。\par

\subsection{基本语法}
\subsubsection{1. 变量插值}
使用双大括号 `{{ }}` 插入变量值：\par
\end{verbatim}jinja2
# 基本变量
Hello, {{ name }}!

# 嵌套变量
Server IP: {{ ansible_facts.default_ipv4.address }}

# 字典访问
Database host: {{ db_config.host }}

# 列表访问
First item: {{ items[0] }}
\begin{verbatim}
\subsubsection{2. 控制结构}
\paragraph{条件语句}
\end{verbatim}jinja2
{% if environment == 'production' %}
ServerName production.example.com
{% elif environment == 'staging' %}
ServerName staging.example.com
{% else %}
ServerName development.example.com
{% endif %}
\begin{verbatim}
\paragraph{循环语句}
\end{verbatim}jinja2
# 遍历列表
{% for user in users %}
User: {{ user }}
{% endfor %}

# 遍历字典
{% for key, value in config.items() %}
{{ key }}: {{ value }}
{% endfor %}

# 带索引的循环
{% for i, item in enumerate(items) %}
Item {{ i+1 }}: {{ item }}
{% endfor %}
\begin{verbatim}
\paragraph{包含文件}
\end{verbatim}jinja2
# 包含其他模板文件
{% include 'header.j2' %}

# 包含文件（如果存在）
{% include 'optional_file.j2' ignore missing %}
\begin{verbatim}
\paragraph{继承模板}
**base.j2**：\par
\end{verbatim}jinja2
<!DOCTYPE html>
<html>
<head>
    <title>{% block title %}Default Title{% endblock %}</title>
</head>
<body>
    {% block content %}
    Default content
    {% endblock %}
</body>
</html>
\begin{verbatim}
**child.j2**：\par
\end{verbatim}jinja2
{% extends 'base.j2' %}

{% block title %}Custom Title{% endblock %}

{% block content %}
<h1>Welcome</h1>
<p>This is custom content</p>
{% endblock %}
\begin{verbatim}
\subsection{过滤器}
过滤器用于修改变量值，使用 `|` 符号：\par

\subsubsection{常用过滤器}
\end{verbatim}jinja2
# 字符串过滤器
{{ name | upper }}
{{ name | lower }}
{{ name | capitalize }}
{{ name | trim }}
{{ name | truncate(20) }}

# 数字过滤器
{{ number | abs }}
{{ number | round }}
{{ number | int }}
{{ number | float }}

# 列表过滤器
{{ items | length }}
{{ items | first }}
{{ items | last }}
{{ items | join(', ') }}
{{ items | sort }}
{{ items | unique }}

# 字典过滤器
{{ dict | keys }}
{{ dict | values }}
{{ dict | items }}

# 逻辑过滤器
{{ value | default('default') }}
{{ value | default('default', true) }}
{{ value | bool }}
{{ value | length > 0 | ternary('yes', 'no') }}

# 高级过滤器
{{ datetime | strftime('%Y-%m-%d') }}
{{ data | to_json }}
{{ json_string | from_json }}
{{ text | regex_replace('old', 'new') }}
\begin{verbatim}
\subsubsection{自定义过滤器}
可以在 Ansible 中创建自定义过滤器：\par

**创建过滤器文件** (`filter_plugins/custom_filters.py`)：\par
\end{verbatim}python
def to_uppercase(value):
    return value.upper()

def multiply(value, factor):
    return value * factor

class FilterModule:
    def filters(self):
        return {
            'to_uppercase': to_uppercase,
            'multiply': multiply
        }
\begin{verbatim}
**使用自定义过滤器**：\par
\end{verbatim}jinja2
{{ name | to_uppercase }}
{{ count | multiply(2) }}
\begin{verbatim}
\subsection{测试器}
测试器用于测试变量的特性，使用 `is` 关键字：\par

\end{verbatim}jinja2
# 基本测试
{% if value is defined %}
Value is defined
{% endif %}

{% if value is none %}
Value is None
{% endif %}

{% if value is truthy %}
Value is truthy
{% endif %}

# 类型测试
{% if value is string %}
Value is a string
{% endif %}

{% if value is number %}
Value is a number
{% endif %}

{% if value is iterable %}
Value is iterable
{% endif %}

# 字符串测试
{% if value is lower %}
Value is lowercase
{% endif %}

{% if value is upper %}
Value is uppercase
{% endif %}

{% if value is alpha %}
Value contains only letters
{% endif %}

{% if value is alphanumeric %}
Value contains only letters and numbers
{% endif %}

# 列表测试
{% if value is in [1, 2, 3] %}
Value is in list
{% endif %}

{% if list1 is subset(list2) %}
List1 is subset of list2
{% endif %}
\begin{verbatim}
\subsection{宏}
宏类似于函数，用于重用代码块：\par

\end{verbatim}jinja2
# 定义宏
{% macro input(name, value='', type='text') %}
<input type="{{ type }}" name="{{ name }}" value="{{ value }}">
{% endmacro %}

# 使用宏
{{ input('username') }}
{{ input('password', type='password') }}
{{ input('email', 'user@example.com') }}

# 带默认值的宏
{% macro render_item(item, class='') %}
<div class="item {{ class }}">{{ item }}</div>
{% endmacro %}

# 宏的导入
{% import 'macros.j2' as macros %}
{{ macros.input('username') }}
\begin{verbatim}
\subsection{模板文件的使用}
在 Ansible Playbooks 中使用 `template` 模块：\par

\end{verbatim}yaml
- name: Create configuration file
  template:
    src: templates/httpd.conf.j2
    dest: /etc/httpd/conf/httpd.conf
    owner: root
    group: root
    mode: '0644'
  notify: restart httpd
\begin{verbatim}
**目录结构**：\par
\end{verbatim}
playbook.yml
templates/
├── httpd.conf.j2
├── nginx.conf.j2
└── macros.j2
\begin{verbatim}
\section{文件操作与管理}
Ansible 提供了多种模块用于文件操作和管理，以下是常用的文件相关模块：\par

\subsection{常用文件模块}
\subsubsection{1. copy 模块}
用于复制文件到远程主机：\par

\end{verbatim}yaml
- name: Copy file with permissions
  copy:
    src: files/nginx.conf
    dest: /etc/nginx/nginx.conf
    owner: root
    group: root
    mode: '0644'

- name: Copy file only if different
  copy:
    src: files/app.conf
    dest: /etc/app/app.conf
    force: false  # 仅当文件不同时复制

- name: Copy directory
  copy:
    src: files/configs/
    dest: /etc/app/configs/
    directory_mode: '0755'
\begin{verbatim}
\subsubsection{2. file 模块}
用于管理文件和目录的属性：\par

\end{verbatim}yaml
- name: Create directory
  file:
    path: /opt/app/data
    state: directory
    owner: appuser
    group: appgroup
    mode: '0755'

- name: Create empty file
  file:
    path: /etc/app/empty.conf
    state: touch
    mode: '0644'

- name: Remove file
  file:
    path: /tmp/temporary_file
    state: absent

- name: Create symlink
  file:
    src: /etc/app/current.conf
    dest: /etc/app/conf.d/default.conf
    state: link

- name: Set file permissions
  file:
    path: /etc/app/secure.conf
    owner: root
    group: root
    mode: '0600'
\begin{verbatim}
\subsubsection{3. lineinfile 模块}
用于修改文件中的特定行：\par

\end{verbatim}yaml
- name: Add line to file
  lineinfile:
    path: /etc/hosts
    line: '192.168.1.100 server.example.com'

- name: Replace line
  lineinfile:
    path: /etc/sysctl.conf
    regexp: '^net.ipv4.ip_forward='
    line: 'net.ipv4.ip_forward=1'

- name: Ensure line is present
  lineinfile:
    path: /etc/ssh/sshd_config
    regexp: '^PermitRootLogin'
    line: 'PermitRootLogin no'
    state: present

- name: Remove line
  lineinfile:
    path: /etc/fstab
    regexp: '^tmpfs.*tmp'
    state: absent

- name: Insert line after match
  lineinfile:
    path: /etc/httpd/conf/httpd.conf
    insertafter: '^ServerName'
    line: 'ServerAlias www.example.com'

- name: Insert line before match
  lineinfile:
    path: /etc/nginx/nginx.conf
    insertbefore: '^server {'
    line: 'worker_processes auto;'
\begin{verbatim}
\subsubsection{4. blockinfile 模块}
用于在文件中添加或修改块：\par

\end{verbatim}yaml
- name: Add block to file
  blockinfile:
    path: /etc/httpd/conf.d/vhosts.conf
    block: |
      <VirtualHost *:80>
          ServerName example.com
          DocumentRoot /var/www/html
      </VirtualHost>

- name: Add block with marker
  blockinfile:
    path: /etc/hosts
    block: |
      192.168.1.101 web1
      192.168.1.102 web2
    marker: '# {mark} ANSIBLE MANAGED BLOCK'

- name: Replace existing block
  blockinfile:
    path: /etc/nginx/nginx.conf
    marker: '# {mark} NGINX CONFIG'
    block: |
      user nginx;
      worker_processes auto;
      
      events {
          worker_connections 1024;
      }

- name: Remove block
  blockinfile:
    path: /etc/app/config.conf
    marker: '# {mark} OLD CONFIG'
    state: absent
\begin{verbatim}
\subsubsection{5. assemble 模块}
用于将多个文件组装成一个文件：\par

\end{verbatim}yaml
- name: Assemble configuration files
  assemble:
    src: /etc/app/config.d/
    dest: /etc/app/config.conf
    delimiter: '# --- ASSEMBLED FILE ---'
    backup: yes
\begin{verbatim}
\subsubsection{6. unarchive 模块}
用于解压归档文件：\par

\end{verbatim}yaml
- name: Extract tar.gz file
  unarchive:
    src: files/app-1.0.0.tar.gz
    dest: /opt/app/
    remote_src: no  # 从本地复制后解压

- name: Extract from URL
  unarchive:
    src: https://example.com/app-1.0.0.tar.gz
    dest: /opt/app/
    remote_src: yes  # 直接从远程URL解压

- name: Extract with specific owner
  unarchive:
    src: files/app.zip
    dest: /opt/app/
    owner: appuser
    group: appgroup
\begin{verbatim}
\subsubsection{7. fetch 模块}
用于从远程主机获取文件到本地：\par

\end{verbatim}yaml
- name: Fetch log file
  fetch:
    src: /var/log/app.log
    dest: logs/{{ inventory_hostname }}/
    flat: no  # 保留目录结构

- name: Fetch specific file
  fetch:
    src: /etc/app/config.conf
    dest: configs/{{ inventory_hostname }}.conf
    flat: yes  # 直接保存为指定文件名
\begin{verbatim}
\subsection{文件操作的最佳实践}
1. **权限管理**\par
   - 始终指定文件权限（mode）\par
   - 对敏感文件使用严格权限（如 0600）\par
   - 目录通常使用 0755 权限

2. **文件备份**\par
   - 对重要配置文件使用 `backup: yes`\par
   - 保留原始文件的备份

3. **幂等性**\par
   - 使用 `force: false` 避免不必要的文件复制\par
   - 使用 `lineinfile` 的 `regexp` 确保只修改需要的行

4. **错误处理**\par
   - 使用 `ignore_errors: yes` 处理非关键文件操作\par
   - 使用 `failed_when` 定义自定义失败条件

5. **性能优化**\par
   - 对于大文件，考虑使用 `copy` 模块的 `remote_src`\par
   - 避免在循环中使用文件操作模块

\section{配置文件的模板化}
配置文件模板化是 Ansible 的核心用例之一，它允许你使用变量和逻辑生成动态配置文件。\par

\subsection{基本原理}
1. **创建模板文件**：使用 Jinja2 语法创建模板\par
2. **定义变量**：在 Playbook、变量文件或 Inventory 中定义变量\par
3. **渲染模板**：使用 `template` 模块将模板渲染为实际配置文件\par
4. **应用配置**：重启服务或重新加载配置

\subsection{常见配置文件模板示例}
\subsubsection{1. Web 服务器配置}
**Nginx 模板** (`templates/nginx.conf.j2`)：\par
\end{verbatim}jinja2
user nginx;
worker_processes {{ worker_processes | default('auto') }};

events {
    worker_connections {{ worker_connections | default(1024) }};
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    
    {% if gzip_enabled | default(true) %}
    gzip on;
    gzip_comp_level {{ gzip_comp_level | default(6) }};
    gzip_types text/plain text/css application/json application/javascript;
    {% endif %}
    
    server {
        listen {{ http_port | default(80) }};
        server_name {{ server_name | default('localhost') }};
        
        root {{ document_root | default('/usr/share/nginx/html') }};
        index index.html index.htm;
        
        {% if ssl_enabled | default(false) %}
        listen {{ https_port | default(443) }} ssl;
        ssl_certificate {{ ssl_certificate | default('/etc/nginx/ssl/cert.pem') }};
        ssl_certificate_key {{ ssl_certificate_key | default('/etc/nginx/ssl/key.pem') }};
        {% endif %}
        
        location / {
            try_files $uri $uri/ =404;
        }
    }
}
\begin{verbatim}
**使用模板**：\par
\end{verbatim}yaml
- name: Configure Nginx
  template:
    src: templates/nginx.conf.j2
    dest: /etc/nginx/nginx.conf
    owner: root
    group: root
    mode: '0644'
  vars:
    worker_processes: auto
    worker_connections: 2048
    http_port: 80
    https_port: 443
    server_name: example.com
    document_root: /var/www/example.com
    ssl_enabled: true
    ssl_certificate: /etc/letsencrypt/live/example.com/fullchain.pem
    ssl_certificate_key: /etc/letsencrypt/live/example.com/privkey.pem
  notify: restart nginx
\begin{verbatim}
\subsubsection{2. 数据库配置}
**MySQL 模板** (`templates/my.cnf.j2`)：\par
\end{verbatim}jinja2
[mysqld]
user = mysql
datadir = {{ datadir | default('/var/lib/mysql') }}
socket = {{ socket | default('/var/lib/mysql/mysql.sock') }}
port = {{ port | default(3306) }}
bind-address = {{ bind_address | default('127.0.0.1') }}

# Performance settings
max_connections = {{ max_connections | default(151) }}
table_open_cache = {{ table_open_cache | default(2000) }}
sort_buffer_size = {{ sort_buffer_size | default('256K') }}
read_buffer_size = {{ read_buffer_size | default('128K') }}
read_rnd_buffer_size = {{ read_rnd_buffer_size | default('256K') }}
join_buffer_size = {{ join_buffer_size | default('256K') }}

# Innodb settings
innodb_buffer_pool_size = {{ innodb_buffer_pool_size | default('128M') }}
innodb_file_per_table = {{ innodb_file_per_table | default('ON') }}

# Logging
log-error = {{ log_error | default('/var/log/mysqld.log') }}
pid-file = {{ pid_file | default('/var/run/mysqld/mysqld.pid') }}

{% if slow_query_log | default(false) %}
slow_query_log = 1
slow_query_log_file = {{ slow_query_log_file | default('/var/log/mysql-slow.log') }}
long_query_time = {{ long_query_time | default(2) }}
{% endif %}
\begin{verbatim}
\subsubsection{3. 应用配置}
**Python 应用配置** (`templates/app_config.py.j2`)：\par
\end{verbatim}jinja2
# Application configuration
DEBUG = {{ debug | default(false) }}

# Database configuration
DATABASES = {
    'default': {
        'ENGINE': '{{ db_engine | default("django.db.backends.mysql") }}',
        'NAME': '{{ db_name | default("myapp") }}',
        'USER': '{{ db_user | default("myapp") }}',
        'PASSWORD': '{{ db_password }}',
        'HOST': '{{ db_host | default("localhost") }}',
        'PORT': '{{ db_port | default("3306") }}',
    }
}

# Redis configuration
REDIS_URL = "redis://{{ redis_host | default('localhost') }}:{{ redis_port | default(6379) }}/{{ redis_db | default(0) }}"

# Allowed hosts
ALLOWED_HOSTS = [{{ allowed_hosts | join('", "') }}]

# Secret key
SECRET_KEY = '{{ secret_key }}'

# CORS settings
CORS_ORIGIN_ALLOW_ALL = {{ cors_allow_all | default(false) }}
{% if cors_origins %}
CORS_ORIGIN_WHITELIST = [{{ cors_origins | join('", "') }}]
{% endif %}
\begin{verbatim}
\subsection{高级模板技术}
\subsubsection{1. 模板包含}
将复杂模板分解为多个小模板：\par

**主模板** (`templates/nginx.conf.j2`)：\par
\end{verbatim}jinja2
user nginx;
worker_processes auto;

events {
    worker_connections 1024;
}

http {
    {% include 'nginx/mime.types.j2' %}
    {% include 'nginx/gzip.conf.j2' %}
    {% include 'nginx/upstreams.j2' %}
    {% include 'nginx/vhosts.j2' %}
}
\begin{verbatim}
**子模板** (`templates/nginx/vhosts.j2`)：\par
\end{verbatim}jinja2
{% for vhost in vhosts %}
server {
    listen {{ vhost.port }};
    server_name {{ vhost.server_name }};
    
    root {{ vhost.document_root }};
    index index.html;
}
{% endfor %}
\begin{verbatim}
\subsubsection{2. 条件包含}
根据条件包含不同的模板：\par

\end{verbatim}jinja2
{% if environment == 'production' %}
{% include 'prod_settings.j2' %}
{% elif environment == 'staging' %}
{% include 'staging_settings.j2' %}
{% else %}
{% include 'dev_settings.j2' %}
{% endif %}
\begin{verbatim}
\subsubsection{3. 动态模板选择}
根据变量值动态选择模板：\par

\end{verbatim}yaml
- name: Deploy configuration based on environment
  template:
    src: "templates/{{ environment }}.conf.j2"
    dest: /etc/app/config.conf
  vars:
    environment: production
\begin{verbatim}
\subsection{配置文件管理的最佳实践}
1. **版本控制**\par
   - 将模板文件纳入版本控制系统\par
   - 避免在模板中存储敏感信息

2. **敏感信息处理**\par
   - 使用 Ansible Vault 加密敏感变量\par
   - 或使用外部密钥管理系统

3. **模块化设计**\par
   - 将复杂配置分解为多个小模板\par
   - 使用继承和包含减少重复代码

4. **可维护性**\par
   - 使用清晰的变量命名\par
   - 添加注释说明配置项的用途\par
   - 遵循配置文件的原始格式和缩进

5. **测试**\par
   - 在部署前测试模板渲染\par
   - 使用 `--check` 模式验证更改\par
   - 实施配置验证机制

通过合理使用模板和文件操作模块，Ansible 可以高效地管理各种配置文件，确保环境的一致性和可重复性。

% 第七章 Roles 与 Collections
\chapter{Roles 与 Collections}
\section{Roles 的结构与使用}
Roles 是 Ansible 中结构化组织 Playbooks 的方式，它提供了一种标准化的目录结构，便于代码重用、共享和维护。\par

\subsection{Roles 的目录结构}
一个标准的 Role 目录结构如下：\par

\end{verbatim}
role_name/
├── defaults/           # 默认变量（低优先级）
│   └── main.yml
├── files/              # 静态文件
├── handlers/           # 处理器
│   └── main.yml
├── meta/               # 元数据
│   └── main.yml
├── tasks/              # 任务
│   └── main.yml
├── templates/          # 模板文件
├── tests/              # 测试
│   ├── inventory
│   └── test.yml
└── vars/               # 变量（高优先级）
    └── main.yml
\begin{verbatim}
**各目录的作用**：\par
- `defaults/`：存放默认变量，优先级最低\par
- `files/`：存放静态文件，如配置文件、脚本等\par
- `handlers/`：存放处理器，用于响应任务通知\par
- `meta/`：存放元数据，如角色依赖、作者信息等\par
- `tasks/`：存放主要任务，是角色的核心\par
- `templates/`：存放模板文件，使用 Jinja2 语法\par
- `tests/`：存放测试用例\par
- `vars/`：存放角色变量，优先级较高

\subsection{创建 Roles}
\subsubsection{1. 手动创建}
按照上述目录结构手动创建文件和目录：\par

**1. 创建目录结构**：\par
\end{verbatim}bash
mkdir -p myrole/{defaults,files,handlers,meta,tasks,templates,tests,vars}
mkdir -p myrole/tests
\begin{verbatim}
**2. 创建主要文件**：\par

**tasks/main.yml**：\par
\end{verbatim}yaml
---
- name: Install package
  package:
    name: "{{ package_name }}"
    state: present

- name: Copy configuration file
  template:
    src: config.j2
    dest: "{{ config_path }}"
  notify: restart service

- name: Start and enable service
  service:
    name: "{{ service_name }}"
    state: started
    enabled: true
\begin{verbatim}
**defaults/main.yml**：\par
\end{verbatim}yaml
---
package_name: httpd
config_path: /etc/httpd/conf/httpd.conf
service_name: httpd
\begin{verbatim}
**handlers/main.yml**：\par
\end{verbatim}yaml
---
- name: restart service
  service:
    name: "{{ service_name }}"
    state: restarted
\begin{verbatim}
**templates/config.j2**：\par
\end{verbatim}jinja2
Listen {{ port | default(80) }}
ServerName {{ server_name | default('localhost') }}
\begin{verbatim}
\subsubsection{2. 使用 ansible-galaxy 命令创建}
\end{verbatim}bash
# 创建新角色
ansible-galaxy init myrole

# 创建到指定目录
ansible-galaxy init --init-path ./roles myrole
\begin{verbatim}
\subsection{使用 Roles}
\subsubsection{1. 在 Playbook 中使用}
**基本用法**：\par
\end{verbatim}yaml
---
- name: Use role
  hosts: webservers
  roles:
    - myrole
\begin{verbatim}
**传递变量**：\par
\end{verbatim}yaml
---
- name: Use role with variables
  hosts: webservers
  roles:
    - name: myrole
      vars:
        package_name: nginx
        config_path: /etc/nginx/nginx.conf
        service_name: nginx
        port: 8080
        server_name: web.example.com
\begin{verbatim}
**条件执行角色**：\par
\end{verbatim}yaml
---
- name: Use role conditionally
  hosts: all
  roles:
    - name: myrole
      when: ansible_os_family == 'RedHat'
\begin{verbatim}
**角色执行顺序**：\par
\end{verbatim}yaml
---
- name: Use multiple roles
  hosts: webservers
  roles:
    - role1
    - role2
    - role3
  tasks:
    - name: Task after roles
      debug:
        msg: "Roles completed"
\begin{verbatim}
\subsubsection{2. 在 roles 目录中组织}
**目录结构**：\par
\end{verbatim}
playbook.yml
roles/
├── webserver/
│   └── ...
├── database/
│   └── ...
└── common/
    └── ...
\begin{verbatim}
**使用相对路径**：\par
\end{verbatim}yaml
---
- name: Use roles from directory
  hosts: all
  roles:
    - ./roles/common
    - ./roles/webserver
\begin{verbatim}
\subsection{Roles 的高级特性}
\subsubsection{1. 角色依赖}
在 `meta/main.yml` 中定义角色依赖：\par

\end{verbatim}yaml
---
dependencies:
  - role: geerlingguy.java
    vars:
      java_version: 11
  - role: geerlingguy.mysql
    vars:
      mysql_root_password: "{{ db_root_password }}"
    when: install_database
\begin{verbatim}
\subsubsection{2. 角色参数}
使用 `vars` 关键字传递参数：\par

**定义参数**：\par
\end{verbatim}yaml
---
- name: Define role parameters
  hosts: webservers
  roles:
    - name: apache
      vars:
        apache_listen_port: 80
        apache_server_name: example.com
        apache_document_root: /var/www/html
\begin{verbatim}
**在角色中使用参数**：\par
\end{verbatim}yaml
# tasks/main.yml
---
- name: Configure Apache port
  lineinfile:
    path: /etc/httpd/conf/httpd.conf
    regexp: '^Listen '
    line: 'Listen {{ apache_listen_port }}'
\begin{verbatim}
\subsubsection{3. 角色标签}
使用 `tags` 为角色添加标签：\par

\end{verbatim}yaml
---
- name: Use role with tags
  hosts: webservers
  roles:
    - name: myrole
      tags:
        - web
        - config
\begin{verbatim}
**选择性执行**：\par
\end{verbatim}bash
ansible-playbook playbook.yml --tags "web"
ansible-playbook playbook.yml --skip-tags "config"
\begin{verbatim}
\subsection{Roles 的最佳实践}
1. **命名规范**\par
   - 使用小写字母和下划线\par
   - 名称要描述性：`apache`, `mysql`, `common`\par
   - 避免使用特殊字符

2. **目录结构**\par
   - 遵循标准目录结构\par
   - 只创建必要的目录\par
   - 保持目录结构清晰

3. **变量管理**\par
   - 在 `defaults/main.yml` 中设置默认值\par
   - 在 `vars/main.yml` 中设置角色内部变量\par
   - 使用 `{{ variable | default('value') }}` 提供默认值

4. **可重用性**\par
   - 使角色通用化，避免硬编码\par
   - 使用变量控制角色行为\par
   - 编写文档说明角色的使用方法

5. **测试**\par
   - 为角色编写测试用例\par
   - 使用 CI/CD 测试角色\par
   - 确保角色在不同环境中正常工作

\section{Collections 的概念与应用}
Collections 是 Ansible 2.8+ 引入的一种打包和分发 Ansible 内容的格式，它允许你将 roles、modules、plugins、inventory 插件等打包在一起。\par

\subsection{Collections 的概念}
\subsubsection{1. 什么是 Collections}
Collections 是 Ansible 内容的分发格式，包含：\par
- Roles\par
- Modules\par
- Plugins（连接插件、过滤插件、查找插件等）\par
- Inventory 插件\par
- Playbooks\par
- Documentation

\subsubsection{2. Collections 的优势}
- **模块化**：将相关内容打包在一起\par
- **版本控制**：支持语义化版本控制\par
- **命名空间**：避免命名冲突\par
- **依赖管理**：支持声明依赖关系\par
- **简化分发**：易于分享和重用\par
- **官方支持**：Ansible 核心团队维护的内容以 Collections 形式发布

\subsection{Collections 的目录结构}
一个标准的 Collection 目录结构如下：\par

\end{verbatim}
namespace/collection_name/
├── docs/               # 文档
├── galaxy.yml          # Galaxy 配置
├── meta/               # 元数据
│   └── runtime.yml     # 运行时配置
├── plugins/            # 插件
│   ├── action/         # 动作插件
│   ├── become/         # 提权插件
│   ├── cache/          # 缓存插件
│   ├── callback/       # 回调插件
│   ├── connection/     # 连接插件
│   ├── filter/         # 过滤插件
│   ├── inventory/      # 库存插件
│   ├── lookup/         # 查找插件
│   ├── module_utils/   # 模块工具
│   ├── modules/        # 模块
│   └── shell/          # Shell 插件
├── roles/              # 角色
│   └── role1/
├── playbooks/          # Playbooks
└── tests/              # 测试
\begin{verbatim}
**关键文件**：\par
- `galaxy.yml`：定义 Collection 的元数据，如名称、版本、依赖等\par
- `meta/runtime.yml`：定义运行时配置，如依赖的 Ansible 版本\par
- `plugins/modules/`：自定义模块\par
- `plugins/filter/`：自定义过滤插件\par
- `roles/`：包含的角色

\subsection{使用 Collections}
\subsubsection{1. 安装 Collections}
**从 Ansible Galaxy 安装**：\par
\end{verbatim}bash
# 安装特定版本
ansible-galaxy collection install namespace.collection_name:version

# 安装最新版本
ansible-galaxy collection install namespace.collection_name

# 从 requirements 文件安装
ansible-galaxy collection install -r collections/requirements.yml
\begin{verbatim}
**requirements.yml 文件**：\par
\end{verbatim}yaml
---
collections:
  - name: community.general
    version: 3.7.0
  - name: ansible.posix
    version: 1.4.0
  - name: geerlingguy.php_roles
    source: https://galaxy.ansible.com/
\begin{verbatim}
\subsubsection{2. 在 Playbook 中使用}
**使用完全限定名称**：\par
\end{verbatim}yaml
---
- name: Use collection module
  hosts: all
  tasks:
    - name: Use community.general module
      community.general.docker_container:
        name: web
        image: nginx

- name: Use collection role
  hosts: webservers
  roles:
    - name: community.general.apache
\begin{verbatim}
**使用 collections 关键字**：\par
\end{verbatim}yaml
---
- name: Use collections
  hosts: all
  collections:
    - community.general
    - ansible.posix
  tasks:
    - name: Use module without namespace
      docker_container:
        name: web
        image: nginx
    - name: Use another module
      mount:
        path: /mnt/data
        src: /dev/sdb1
        fstype: ext4
        state: mounted
\begin{verbatim}
**使用角色**：\par
\end{verbatim}yaml
---
- name: Use collection role
  hosts: webservers
  roles:
    - role: community.general.apache
      vars:
        apache_listen_port: 8080
\begin{verbatim}
\subsubsection{3. 搜索 Collections}
**在 Ansible Galaxy 搜索**：\par
\end{verbatim}bash
# 搜索 Collections
ansible-galaxy collection search apache

# 搜索并过滤
ansible-galaxy collection search --author geerlingguy
\begin{verbatim}
**浏览 Ansible Galaxy 网站**：\par
访问 https://galaxy.ansible.com/ 浏览和搜索 Collections

\subsection{创建 Collections}
\subsubsection{1. 初始化 Collection}
\end{verbatim}bash
# 创建 Collection 骨架
ansible-galaxy collection init namespace.collection_name

# 例如
ansible-galaxy collection init mycompany.webservers
\begin{verbatim}
\subsubsection{2. 配置 galaxy.yml}
\end{verbatim}yaml
---
namespace: mycompany
name: webservers
version: 1.0.0
tags:
  - web
  - server
  - apache
  - nginx
description: Collection for web server management
authors:
  - John Doe <john@example.com>
license:
  - GPL-3.0-or-later
readme: README.md
dependencies:
  community.general: '>=3.0.0'
  ansible.posix: '>=1.0.0'
repository: https://github.com/mycompany/ansible-collection-webservers
documentation: https://docs.example.com/collections/mycompany/webservers/
homepage: https://example.com/collections/mycompany/webservers/
bugtracker: https://github.com/mycompany/ansible-collection-webservers/issues
\begin{verbatim}
\subsubsection{3. 构建和发布}
**构建 Collection**：\par
\end{verbatim}bash
# 构建 Collection
ansible-galaxy collection build

# 构建到指定目录
ansible-galaxy collection build --output-path ./builds
\begin{verbatim}
**发布到 Ansible Galaxy**：\par
\end{verbatim}bash
# 发布到 Galaxy
ansible-galaxy collection publish ./mycompany-webservers-1.0.0.tar.gz --api-key=YOUR_API_KEY
\begin{verbatim}
**安装本地 Collection**：\par
\end{verbatim}bash
# 安装本地构建的 Collection
ansible-galaxy collection install ./mycompany-webservers-1.0.0.tar.gz
\begin{verbatim}
\subsection{Collections 与 Roles 的关系}
| 特性 | Roles | Collections |
|------|-------|-------------|
| 内容范围 | 主要包含任务、模板、文件 | 包含 roles、modules、plugins 等 |
| 打包方式 | 目录结构 | 压缩包 (.tar.gz) |
| 版本控制 | 依赖外部版本控制系统 | 内置版本控制 |
| 命名空间 | 无 | 支持命名空间 |
| 依赖管理 | 简单依赖 | 复杂依赖管理 |
| 分发渠道 | Ansible Galaxy、Git | Ansible Galaxy、私有仓库 |

**最佳实践**：\par
- 对于简单的配置管理，使用 Roles\par
- 对于复杂的自动化，包含自定义模块和插件，使用 Collections\par
- 将相关的 Roles 打包到一个 Collection 中

\section{共享与复用自动化代码}
共享和复用自动化代码是 Ansible 的核心优势之一，它可以大大提高开发效率，减少重复工作。\par

\subsection{Ansible Galaxy}
Ansible Galaxy (https://galaxy.ansible.com/) 是 Ansible 社区的中心，用于共享和发现 Roles 和 Collections。\par

\subsubsection{1. 浏览和搜索}
- **网站界面**：通过分类、标签、评分浏览内容\par
- **命令行工具**：使用 `ansible-galaxy search` 搜索\par
- **过滤搜索**：按作者、评分、下载量过滤

\subsubsection{2. 下载和使用}
\end{verbatim}bash
# 下载 Role
ansible-galaxy role install geerlingguy.nginx

# 下载 Collection
ansible-galaxy collection install community.general

# 从文件安装多个
ansible-galaxy install -r requirements.yml
\begin{verbatim}
\subsubsection{3. 发布内容}
**发布 Role**：\par
1. 创建符合标准结构的 Role\par
2. 在 GitHub 上托管\par
3. 在 Ansible Galaxy 上导入

**发布 Collection**：\par
1. 创建和构建 Collection\par
2. 获取 Galaxy API 密钥\par
3. 使用 `ansible-galaxy collection publish` 发布

\subsection{版本控制}
\subsubsection{1. 使用 Git}
**推荐的 Git 工作流**：\par
- 使用分支管理不同版本\par
- 使用标签标记发布版本\par
- 遵循语义化版本控制

**目录结构**：\par
\end{verbatim}
ansible-project/
├── .git/
├── playbooks/
├── roles/
├── collections/
├── inventory/
└── README.md
\begin{verbatim}
\subsubsection{2. 依赖管理}
**requirements.yml 文件**：\par
\end{verbatim}yaml
---
# Roles
roles:
  - name: geerlingguy.nginx
    version: 3.1.0
    source: https://galaxy.ansible.com/
  - name: geerlingguy.mysql
    version: 3.2.0

# Collections
collections:
  - name: community.general
    version: 3.7.0
  - name: ansible.posix
    version: 1.4.0
\begin{verbatim}
**安装依赖**：\par
\end{verbatim}bash
# 安装 roles
ansible-galaxy role install -r requirements.yml

# 安装 collections
ansible-galaxy collection install -r requirements.yml
\begin{verbatim}
\subsection{私有仓库}
对于企业内部使用，可以搭建私有 Ansible Galaxy 仓库：\par

\subsubsection{1. 私有 Galaxy 服务器}
- 使用 `ansible-galaxy-server` 搭建私有服务器\par
- 配置访问控制和权限\par
- 用于内部共享和管理

\subsubsection{2. 本地文件系统}
**本地 Collection 目录**：\par
\end{verbatim}bash
# 设置 COLLECTIONS_PATH 环境变量
export COLLECTIONS_PATH=~/.ansible/collections:/usr/share/ansible/collections:./collections

# 或在 ansible.cfg 中设置
[defaults]
collections_paths = ~/.ansible/collections:/usr/share/ansible/collections:./collections
\begin{verbatim}
**本地 Role 目录**：\par
\end{verbatim}bash
# 在 ansible.cfg 中设置
[defaults]
roles_path = ~/.ansible/roles:/usr/share/ansible/roles:./roles
\begin{verbatim}
\subsection{代码复用的最佳实践}
1. **标准化**\par
   - 遵循 Ansible 最佳实践\par
   - 使用一致的命名规范\par
   - 保持目录结构标准化

2. **文档**\par
   - 为 Roles/Collections 编写详细文档\par
   - 说明变量、参数和使用方法\par
   - 提供示例 Playbooks

3. **测试**\par
   - 编写单元测试和集成测试\par
   - 使用 CI/CD 管道测试代码\par
   - 确保代码在不同环境中正常工作

4. **版本控制**\par
   - 遵循语义化版本控制\par
   - 记录变更日志\par
   - 管理向后兼容性

5. **社区参与**\par
   - 贡献到 Ansible 社区\par
   - 分享经验和最佳实践\par
   - 参与讨论和改进

6. **安全**\par
   - 定期更新依赖\par
   - 扫描代码中的安全漏洞\par
   - 遵循安全最佳实践

通过合理使用 Roles 和 Collections，以及 Ansible Galaxy 等工具，你可以构建一个可维护、可重用的自动化代码库，大大提高工作效率和代码质量。

% 第八章 高级特性
\chapter{高级特性}
\section{条件判断与循环}
Ansible 提供了强大的条件判断和循环功能，使你能够根据不同的情况执行不同的任务，或者对一组数据重复执行相同的操作。\par

\subsection{条件判断}
\subsubsection{1. when 语句}
`when` 语句用于根据条件决定是否执行任务：\par

**基本用法**：\par
\end{verbatim}yaml
- name: Install package on CentOS
  yum:
    name: httpd
    state: present
  when: ansible_os_family == 'RedHat'

- name: Install package on Debian
  apt:
    name: apache2
    state: present
  when: ansible_os_family == 'Debian'
\begin{verbatim}
**使用变量**：\par
\end{verbatim}yaml
- name: Configure firewall
  firewalld:
    service: http
    state: enabled
    permanent: true
    immediate: true
  when: configure_firewall | bool

- name: Set timezone
  timezone:
    name: "{{ timezone }}"
  when: timezone is defined
\begin{verbatim}
**复合条件**：\par
\end{verbatim}yaml
- name: Deploy application
  copy:
    src: app.tar.gz
    dest: /opt/app/
  when:
    - ansible_system == 'Linux'
    - ansible_distribution_major_version | int >= 7
    - inventory_hostname in groups['production']

- name: Restart service
  service:
    name: httpd
    state: restarted
  when: ansible_os_family == 'RedHat' and httpd_installed | bool
\begin{verbatim}
**使用逻辑运算符**：\par
\end{verbatim}yaml
# 逻辑与
when: condition1 and condition2

# 逻辑或
when: condition1 or condition2

# 逻辑非
when: not condition

# 括号分组
when: (condition1 and condition2) or (condition3 and condition4)
\begin{verbatim}
**使用测试**：\par
\end{verbatim}yaml
- name: Create directory if it doesn't exist
  file:
    path: /opt/app
    state: directory
  when: item is not exists
  with_items: ["/opt/app", "/opt/data"]

- name: Check if file is readable
  command: cat /etc/passwd
  when: "/etc/passwd" is readable

- name: Use regex
  debug:
    msg: "IP address found"
  when: ansible_default_ipv4.address is regex('^192\.168\.')
\begin{verbatim}
\subsubsection{2. 条件测试}
Ansible 提供了丰富的测试函数，用于条件判断：\par

**常用测试**：\par
- **存在性测试**：`is defined`, `is not defined`, `is exists`, `is file`, `is directory`\par
- **类型测试**：`is string`, `is number`, `is integer`, `is float`, `is boolean`, `is list`, `is dict`\par
- **比较测试**：`==`, `!=`, `<`, `>`, `<=`, `>=`\par
- **逻辑测试**：`and`, `or`, `not`\par
- **字符串测试**：`is regex`, `is match`, `search`, `startswith`, `endswith`\par
- **列表测试**：`in`, `not in`, `is subset`, `is superset`\par
- **其他测试**：`failed`, `changed`, `succeeded`, `skipped`

**示例**：\par
\end{verbatim}yaml
- name: Test existence
  debug:
    msg: "Variable exists"
  when: my_var is defined

- name: Test type
  debug:
    msg: "Is a list"
  when: my_list is list

- name: Test string
  debug:
    msg: "Starts with 'test'"
  when: my_string.startswith('test')

- name: Test list membership
  debug:
    msg: "Item is in list"
  when: 'item' in my_list
\begin{verbatim}
\subsubsection{3. 条件块}
对于多个需要相同条件的任务，可以使用 `block`：\par

\end{verbatim}yaml
- name: Configure web server
  block:
    - name: Install Apache
      package:
        name: httpd
        state: present
    
    - name: Start Apache
      service:
        name: httpd
        state: started
        enabled: true
    
    - name: Configure firewall
      firewalld:
        service: http
        state: enabled
        permanent: true
        immediate: true
  when: ansible_os_family == 'RedHat'
  become: true
\begin{verbatim}
**带错误处理的条件块**：\par
\end{verbatim}yaml
- name: Deploy application
  block:
    - name: Create application directory
      file:
        path: /opt/app
        state: directory
    
    - name: Copy application files
      copy:
        src: app/
        dest: /opt/app/
  when: deploy_app | bool
  rescue:
    - name: Handle failure
      debug:
        msg: "Deployment failed"
  always:
    - name: Clean up
      file:
        path: /tmp/app
        state: absent
\begin{verbatim}
\subsection{循环}
\subsubsection{1. 基本循环}
**with_items**：遍历列表或字典\par

\end{verbatim}yaml
- name: Install multiple packages
  package:
    name: "{{ item }}"
    state: present
  with_items:
    - httpd
    - mysql-server
    - php

- name: Create multiple users
  user:
    name: "{{ item.name }}"
    password: "{{ item.password }}"
    state: present
  with_items:
    - { name: 'user1', password: 'pass1' }
    - { name: 'user2', password: 'pass2' }
\begin{verbatim}
**loop**：Ansible 2.5+ 推荐的循环语法\par

\end{verbatim}yaml
- name: Install multiple packages
  package:
    name: "{{ item }}"
    state: present
  loop:
    - httpd
    - mysql-server
    - php

- name: Create multiple users
  user:
    name: "{{ item.name }}"
    password: "{{ item.password }}"
    state: present
  loop:
    - { name: 'user1', password: 'pass1' }
    - { name: 'user2', password: 'pass2' }
\begin{verbatim}
\subsubsection{2. 高级循环}
**with_dict**：遍历字典\par

\end{verbatim}yaml
- name: Create users from dict
  user:
    name: "{{ item.key }}"
    groups: "{{ item.value.groups }}"
    state: present
  with_dict:
    alice: { groups: 'wheel' }
    bob: { groups: 'users' }
    charlie: { groups: 'admin' }
\begin{verbatim}
**with_fileglob**：遍历文件\par

\end{verbatim}yaml
- name: Copy configuration files
  copy:
    src: "{{ item }}"
    dest: "/etc/httpd/conf.d/"
    owner: root
    group: root
    mode: '0644'
  with_fileglob:
    - files/*.conf
\begin{verbatim}
**with_sequence**：生成序列\par

\end{verbatim}yaml
- name: Create multiple directories
  file:
    path: "/opt/app{{ item }}"
    state: directory
  with_sequence:
    start=1
    end=5
    stride=1

- name: Generate users with sequence
  user:
    name: "user{{ item }}"
    state: present
  with_sequence: count=10
\begin{verbatim}
**with_lines**：执行命令并遍历输出行\par

\end{verbatim}yaml
- name: Create users from file
  user:
    name: "{{ item }}"
    state: present
  with_lines:
    - cat /tmp/users.txt

- name: Install packages from command
  package:
    name: "{{ item }}"
    state: present
  with_lines:
    - grep '^package' requirements.txt | cut -d' ' -f2
\begin{verbatim}
**with_nested**：嵌套循环\par

\end{verbatim}yaml
- name: Create directory structure
  file:
    path: "/opt/{{ item[0] }}/{{ item[1] }}"
    state: directory
  with_nested:
    - [ 'app1', 'app2' ]
    - [ 'logs', 'data', 'config' ]
\begin{verbatim}
**with_together**：并行遍历多个列表\par

\end{verbatim}yaml
- name: Create users with groups
  user:
    name: "{{ item[0] }}"
    groups: "{{ item[1] }}"
    state: present
  with_together:
    - [ 'alice', 'bob', 'charlie' ]
    - [ 'wheel', 'users', 'admin' ]
\begin{verbatim}
**with_random_choice**：随机选择\par

\end{verbatim}yaml
- name: Select random server
  debug:
    msg: "Selected server: {{ item }}"
  with_random_choice:
    - 'server1'
    - 'server2'
    - 'server3'
\begin{verbatim}
\subsubsection{3. 循环控制}
**loop_control**：控制循环行为\par

\end{verbatim}yaml
- name: Install packages with loop control
  package:
    name: "{{ item }}"
    state: present
  loop:
    - httpd
    - mysql-server
    - php
  loop_control:
    label: "{{ item }}"  # 自定义循环标签，使输出更清晰
    pause: 2  # 每次循环后暂停 2 秒

- name: Create users with index
  user:
    name: "{{ item.name }}"
    state: present
  loop: "{{ users }}"
  loop_control:
    index_var: index  # 提供索引变量
    label: "{{ item.name }} ({{ index }})"
\begin{verbatim}
**循环中的条件**：\par

\end{verbatim}yaml
- name: Install packages conditionally
  package:
    name: "{{ item }}"
    state: present
  loop:
    - httpd
    - mysql-server
    - php
  when: item not in installed_packages

- name: Configure services
  service:
    name: "{{ item }}"
    state: started
    enabled: true
  loop: "{{ services }}"
  when: inventory_hostname in groups[item]['hosts']
\begin{verbatim}
**循环中的错误处理**：\par

\end{verbatim}yaml
- name: Process items with error handling
  block:
    - name: Process item
      command: "{{ item }}"
      register: result
      failed_when: result.rc != 0
  rescue:
    - name: Handle error
      debug:
        msg: "Error processing {{ item }}"
  loop:
    - 'command1'
    - 'command2'
    - 'command3'
\begin{verbatim}
\subsection{条件判断与循环的最佳实践}
1. **条件判断**\par
   - 保持条件简洁明了\par
   - 使用括号分组复杂条件\par
   - 对布尔变量使用 `| bool` 过滤器\par
   - 对数字比较使用 `| int` 过滤器\par
   - 对于多个任务使用条件块

2. **循环**\par
   - 优先使用 `loop` 而不是旧的 `with_*` 语法\par
   - 对于大型循环，考虑使用批处理\par
   - 使用 `loop_control` 自定义循环行为\par
   - 为循环提供有意义的标签\par
   - 避免在循环中执行耗时操作

3. **性能考虑**\par
   - 大型循环会增加执行时间\par
   - 考虑使用 `serial` 关键字分批执行\par
   - 对于大量文件操作，使用 `synchronize` 模块\par
   - 避免在循环中使用 `register` 收集大量数据

4. **可读性**\par
   - 为复杂条件添加注释\par
   - 使用变量使条件更易读\par
   - 保持循环体简洁\par
   - 对于复杂循环，考虑将逻辑提取到角色中

\section{错误处理与重试机制}
Ansible 提供了强大的错误处理机制，使你能够优雅地处理任务失败，确保自动化流程的可靠性。\par

\subsection{错误处理基础}
\subsubsection{1. 任务失败的默认行为}
默认情况下，当一个任务失败时，Ansible 会：\par
- 停止在当前主机上执行后续任务\par
- 继续在其他主机上执行\par
- 最终将主机标记为失败

\subsubsection{2. ignore\_errors}
`ignore_errors` 用于忽略任务失败：\par

\begin{verbatim}
yaml
- name: Test command
  command: /bin/false
  ignore_errors: true

- name: Continue after failure
  debug:
    msg: "This task will run even if the previous one failed"
\begin{verbatim}
**基于条件忽略错误**：\par

\end{verbatim}yaml
- name: Test command with conditional ignore
  command: /bin/false
  register: result
  ignore_errors: "{{ result.rc != 0 }}"

- name: Check result
  debug:
    msg: "Command failed with rc={{ result.rc }}"
  when: result.failed
\begin{verbatim}
\subsubsection{3. failed_when}
`failed_when` 用于自定义失败条件：\par

\end{verbatim}yaml
- name: Check service status
  command: systemctl status httpd
  register: result
  failed_when: "'active (running)' not in result.stdout"

- name: Test with custom failure
  command: echo "Error"
  register: result
  failed_when: "'Error' in result.stdout"

- name: Complex failure condition
  command: curl -s http://localhost
  register: result
  failed_when:
    - result.rc != 0
    - "'404 Not Found' not in result.stdout"
\begin{verbatim}
\subsubsection{4. changed_when}
`changed_when` 用于自定义变更条件：\par

\end{verbatim}yaml
- name: Run idempotent command
  command: echo "Hello"
  register: result
  changed_when: false  # 始终标记为未变更

- name: Check if file exists
  command: stat /etc/passwd
  register: result
  changed_when: false  # 检查操作不应标记为变更

- name: Custom changed condition
  copy:
    src: config.j2
    dest: /etc/app/config.conf
  register: result
  changed_when: "'changed' in result.msg"
\begin{verbatim}
\subsection{高级错误处理}
\subsubsection{1. 块级错误处理}
使用 `block`, `rescue`, `always` 进行块级错误处理：\par

\end{verbatim}yaml
- name: Deploy application
  block:
    - name: Stop service
      service:
        name: app
        state: stopped
    
    - name: Backup configuration
      copy:
        src: /etc/app/config.conf
        dest: /etc/app/config.conf.bak
        remote_src: true
    
    - name: Copy new files
      copy:
        src: app/
        dest: /opt/app/
    
    - name: Start service
      service:
        name: app
        state: started
  rescue:
    - name: Handle failure
      debug:
        msg: "Deployment failed, rolling back"
    
    - name: Restore configuration
      copy:
        src: /etc/app/config.conf.bak
        dest: /etc/app/config.conf
        remote_src: true
    
    - name: Start service
      service:
        name: app
        state: started
  always:
    - name: Clean up
      file:
        path: /tmp/app
        state: absent
    
    - name: Notify admin
      mail:
        to: admin@example.com
        subject: "Deployment status"
        body: "Deployment completed ({{ 'successfully' if not ansible_failed_task else 'with errors' }})"
  become: true
\begin{verbatim}
**嵌套块**：\par

\end{verbatim}yaml
- name: Outer block
  block:
    - name: Inner block
      block:
        - name: Task 1
          command: /bin/true
        
        - name: Task 2 (fails)
          command: /bin/false
      rescue:
        - name: Handle inner failure
          debug:
            msg: "Inner block failed"
    
    - name: Task 3
      debug:
        msg: "This will run after inner block rescue"
  rescue:
    - name: Handle outer failure
      debug:
        msg: "Outer block failed"
\begin{verbatim}
\subsubsection{2. 错误处理变量}
Ansible 提供了几个特殊变量用于错误处理：\par

- `ansible_failed_task`：当前失败的任务\par
- `ansible_failed_result`：失败任务的结果\par
- `ansible_last_host_error`：最后一个主机错误\par
- `ansible_play_hosts`：当前仍在运行的主机列表\par
- `ansible_play_hosts_all`：所有主机列表

**使用示例**：\par

\end{verbatim}yaml
- name: Deploy with error reporting
  block:
    - name: Deploy application
      copy:
        src: app.tar.gz
        dest: /opt/app/
  rescue:
    - name: Report failure
      debug:
        msg:
          - "Task failed: {{ ansible_failed_task.name }}"
          - "Failed host: {{ inventory_hostname }}"
          - "Failure message: {{ ansible_failed_result.msg }}"
    
    - name: Send alert
      slack:
        token: "{{ slack_token }}"
        msg: "Deployment failed on {{ inventory_hostname }}: {{ ansible_failed_result.msg }}"
      delegate_to: localhost
      become: false
\begin{verbatim}
\subsection{重试机制}
\subsubsection{1. retries 与 delay}
`retries` 和 `delay` 用于任务重试：\par

\end{verbatim}yaml
- name: Wait for service to start
  wait_for:
    port: 8080
    host: localhost
    timeout: 30
  retries: 5
  delay: 10

- name: Download file with retry
  get_url:
    url: "{{ download_url }}"
    dest: "/tmp/{{ filename }}"
    timeout: 60
  retries: 3
  delay: 5
  register: result
  until: result is succeeded

- name: Check database connection
  mysql_info:
    login_host: localhost
    login_user: root
    login_password: "{{ mysql_root_password }}"
    filter: version
  retries: 10
  delay: 5
  register: result
  until: result is not failed
\begin{verbatim}
\subsubsection{2. until 循环}
`until` 循环用于重试直到条件满足：\par

\end{verbatim}yaml
- name: Wait for API to be ready
  uri:
    url: http://localhost:8080/api/health
    status_code: 200
  register: result
  until: result.status == 200
  retries: 20
  delay: 3

- name: Wait for file to exist
  stat:
    path: /tmp/ready
  register: result
  until: result.stat.exists
  retries: 10
  delay: 2

- name: Wait for service status
  command: systemctl status httpd
  register: result
  until: "'active (running)' in result.stdout"
  retries: 5
  delay: 5
\begin{verbatim}
\subsubsection{3. 重试策略}
**指数退避**：\par

\end{verbatim}yaml
- name: Retry with exponential backoff
  uri:
    url: "{{ api_url }}"
    method: GET
  register: result
  until: result.status == 200
  retries: 5
  delay: "{{ 2 ** ansible_retry_counter | int }}"

- name: Retry with jitter
  uri:
    url: "{{ api_url }}"
    method: POST
    body: "{{ payload }}"
    body_format: json
  register: result
  until: result.status == 201
  retries: 3
  delay: "{{ 5 + (ansible_retry_counter | int * 3) }}"
\begin{verbatim}
**条件重试**：\par

\end{verbatim}yaml
- name: Conditional retry
  command: "{{ command }}"
  register: result
  until: result.rc == 0 or retry_count | int >= 3
  retries: 3
  delay: 2
  vars:
    retry_count: "{{ ansible_retry_counter | default(0) }}"

- name: Retry on specific error
  command: curl -s "{{ url }}"
  register: result
  until: "'Connection refused' not in result.stderr"
  retries: 5
  delay: 3
\begin{verbatim}
\subsection{错误处理的最佳实践}
1. **错误处理策略**\par
   - 明确区分可忽略错误和不可忽略错误\par
   - 对于临时故障使用重试机制\par
   - 对于永久性故障使用失败处理\par
   - 为关键任务提供详细的错误信息

2. **重试机制**\par
   - 为网络操作和服务启动设置合理的重试次数\par
   - 使用 `until` 循环而不是固定次数重试\par
   - 为不同类型的任务设置适当的延迟时间\par
   - 考虑使用指数退避策略减少并发请求

3. **错误报告**\par
   - 记录详细的错误信息\par
   - 集成监控和告警系统\par
   - 为失败任务提供清晰的错误消息\par
   - 实现自动回滚机制

4. **测试**\par
   - 测试错误处理逻辑\par
   - 模拟各种故障场景\par
   - 验证重试机制的有效性\par
   - 确保错误处理不会掩盖真正的问题

5. **性能考虑**\par
   - 避免过度使用重试，这会增加执行时间\par
   - 为长时间运行的任务设置合理的超时\par
   - 考虑使用异步执行处理可能的超时任务

\section{异步任务与并行执行}
Ansible 提供了异步执行任务和并行处理的能力，使你能够处理长时间运行的操作并提高执行效率。\par

\subsection{异步任务}
\subsubsection{1. 基本概念}
异步任务允许 Ansible 在后台执行长时间运行的操作，而不会阻塞整个 Playbook 的执行。\par

**核心概念**：\par
- **poll**：轮询间隔（秒）\par
- **async**：最大执行时间（秒）\par
- **job_id**：异步任务的唯一标识符

\subsubsection{2. 基本用法}
**简单异步任务**：\par

\end{verbatim}yaml
- name: Run long task asynchronously
  command: sleep 30
  async: 45  # 最大执行时间 45 秒
  poll: 5    # 每 5 秒轮询一次状态

- name: Deploy application
  shell: ./deploy.sh
  async: 300  # 5分钟超时
  poll: 10    # 每10秒检查一次
  register: deploy_result

- name: Show deployment result
  debug:
    var: deploy_result
  when: deploy_result is finished
\begin{verbatim}
**完全异步（火与忘）**：\par

\end{verbatim}yaml
- name: Start long-running task
  command: ./backup.sh
  async: 3600  # 1小时超时
  poll: 0      # 不轮询，立即返回
  register: backup_job

- name: Continue with other tasks
  debug:
    msg: "Backup started in background with job ID {{ backup_job.ansible_job_id }}"

- name: Later, check backup status
  async_status:
    jid: "{{ backup_job.ansible_job_id }}"
  register: job_result
  until: job_result.finished
  retries: 30
  delay: 60

- name: Show backup result
  debug:
    var: job_result
\begin{verbatim}
**异步任务与注册**：\par

\end{verbatim}yaml
- name: Run async task with registration
  command: /path/to/long_running_script.sh
  async: 600
  poll: 0
  register: async_result

- name: Do other work while task runs
  debug:
    msg: "Doing other work..."

- name: Wait for async task to complete
  async_status:
    jid: "{{ async_result.ansible_job_id }}"
  register: job_result
  until: job_result.finished
  retries: 10
  delay: 60

- name: Handle task result
  debug:
    msg: "Task completed with status: {{ job_result.status }}"
  when: job_result.finished

- name: Handle task failure
  debug:
    msg: "Task failed with stderr: {{ job_result.stderr }}"
  when: job_result.failed
\begin{verbatim}
\subsection{并行执行}
\subsubsection{1. 并行度控制}
Ansible 默认会并行执行任务，并行度由 `forks` 参数控制：\par

**配置并行度**：\par

\end{verbatim}ini
# ansible.cfg
[defaults]
forks = 5  # 默认值为 5
\begin{verbatim}
**命令行覆盖**：\par

\end{verbatim}bash
ansible-playbook playbook.yml --forks 10
\begin{verbatim}
\subsubsection{2. 序列化执行}
`serial` 关键字用于控制一次执行的主机数量：\par

\end{verbatim}yaml
- name: Deploy with serialization
  hosts: webservers
  serial: 2  # 一次处理 2 台主机
  tasks:
    - name: Deploy application
      copy:
        src: app.tar.gz
        dest: /opt/app/

- name: Deploy with percentage
  hosts: webservers
  serial: "25%"  # 一次处理 25% 的主机
  tasks:
    - name: Update configuration
      template:
        src: config.j2
        dest: /etc/app/config.conf

- name: Deploy with throttling
  hosts: webservers
  serial:
    - 1  # 先处理 1 台
    - 2  # 然后处理 2 台
    - 5  # 最后处理 5 台
  tasks:
    - name: Restart service
      service:
        name: app
        state: restarted
\begin{verbatim}
\subsubsection{3. 并发异步任务}
**多个异步任务并发执行**：\par

\end{verbatim}yaml
- name: Run multiple async tasks
  block:
    - name: Start task 1
      command: sleep 60
      async: 120
      poll: 0
      register: task1

    - name: Start task 2
      command: sleep 45
      async: 90
      poll: 0
      register: task2

    - name: Start task 3
      command: sleep 30
      async: 60
      poll: 0
      register: task3

    - name: Wait for all tasks to complete
      async_status:
        jid: "{{ item.ansible_job_id }}"
      register: job_results
      until: job_results.finished
      retries: 10
      delay: 10
      loop:
        - "{{ task1 }}"
        - "{{ task2 }}"
        - "{{ task3 }}"
\begin{verbatim}
**批量处理**：\par

\end{verbatim}yaml
- name: Batch processing
  hosts: all
  serial: 5
  tasks:
    - name: Process batch
      command: ./process_batch.sh
      async: 120
      poll: 0
      register: batch_job

    - name: Wait for batch to complete
      async_status:
        jid: "{{ batch_job.ansible_job_id }}"
      register: job_result
      until: job_result.finished
      retries: 6
      delay: 20
\begin{verbatim}
\subsection{异步任务的高级用法}
\subsubsection{1. 异步任务与错误处理}

\end{verbatim}yaml
- name: Run async task with error handling
  block:
    - name: Start async task
      command: ./flaky_script.sh
      async: 300
      poll: 0
      register: async_result

    - name: Wait for completion
      async_status:
        jid: "{{ async_result.ansible_job_id }}"
      register: job_result
      until: job_result.finished
      retries: 5
      delay: 10
  rescue:
    - name: Handle async failure
      debug:
        msg: "Async task failed: {{ job_result.stderr }}"
\begin{verbatim}
\subsubsection{2. 异步任务与事实收集}

\end{verbatim}yaml
- name: Run async task and gather facts
  block:
    - name: Start async task
      command: ./setup.sh
      async: 600
      poll: 0
      register: setup_job

    - name: Wait for setup to complete
      async_status:
        jid: "{{ setup_job.ansible_job_id }}"
      register: job_result
      until: job_result.finished
      retries: 20
      delay: 30

    - name: Gather new facts
      setup:
        gather_subset:
          - hardware
          - network

    - name: Use new facts
      debug:
        msg: "New IP address: {{ ansible_default_ipv4.address }}"
  become: true
\begin{verbatim}
\subsection{并行执行的最佳实践}
1. **并行度设置**\par
   - 根据系统资源和网络带宽设置合理的 `forks` 值\par
   - 对于大型部署，考虑逐步增加并行度\par
   - 监控系统资源使用情况，避免过载

2. **序列化策略**\par
   - 对于关键服务，使用较小的 `serial` 值进行灰度发布\par
   - 对于非关键服务，使用较大的并行度提高效率\par
   - 考虑使用百分比 `serial` 值适应动态主机数量

3. **异步任务**\par
   - 为长时间运行的任务设置合理的超时时间\par
   - 对于需要监控的任务，使用适当的轮询间隔\par
   - 对于不需要等待的任务，使用 `poll: 0` 实现完全异步

4. **错误处理**\par
   - 为异步任务添加适当的错误处理\par
   - 实现超时后的清理操作\par
   - 考虑使用块级错误处理管理复杂流程

5. **适用场景**\par
   - 服务重启和初始化\par
   - 软件包安装和升级\par
   - 数据备份和恢复\par
   - 云资源创建和配置\par
   - 长时间运行的脚本和命令

6. **性能优化**\par
   - 合理使用异步任务减少总执行时间\par
   - 避免过多的并发任务导致资源竞争\par
   - 考虑使用 `strategy: free` 策略提高并行度\par
   - 对于大型 Playbook，使用 `tags` 选择性执行任务

\section{Vault 密码管理}
Ansible Vault 是 Ansible 的加密工具，用于加密敏感数据，如密码、API 密钥和证书，确保这些信息的安全。\par

\subsection{Vault 基础}
\subsubsection{1. 基本概念}
Ansible Vault 提供了以下核心功能：\par
- 加密和解密文件\par
- 加密和解密字符串\par
- 支持多种加密算法\par
- 集成到 Ansible 工作流程中

\subsubsection{2. 基本命令}
**创建加密文件**：\par

\end{verbatim}bash
# 创建新的加密文件
ansible-vault create secrets.yml

# 编辑加密文件
ansible-vault edit secrets.yml

# 查看加密文件内容
ansible-vault view secrets.yml

# 重新加密文件
ansible-vault rekey secrets.yml

# 加密现有文件
ansible-vault encrypt existing_file.yml

# 解密文件
ansible-vault decrypt secrets.yml

# 加密文件到新位置
ansible-vault encrypt --output encrypted.yml plaintext.yml
\begin{verbatim}
**加密字符串**：\par

\end{verbatim}bash
# 创建加密字符串
ansible-vault encrypt_string 'mysecret' --name 'secret_var'

# 输出示例
secret_var: !vault |
          $ANSIBLE_VAULT;1.1;AES256
          66386439653236336462303464656266396665353362363439306135353033383332376464373634
          6538663330356437623037313630386364643338363262300a346635323636346437633535373430
          37326630626463303136663539643935626639373130366232373437666235366639663236353630
          3264313861643964330a373133383561346539303838343138623431313664646239613733306432
          3462
\begin{verbatim}
\subsection{Vault 的使用}
\subsubsection{1. 在 Playbook 中使用}
**使用加密文件**：\par

\end{verbatim}yaml
# 在 Playbook 中使用
- name: Use encrypted variables
  hosts: all
  vars_files:
    - secrets.yml
  tasks:
    - name: Create user with encrypted password
      user:
        name: admin
        password: "{{ admin_password }}"

# 在命令行中指定密码文件
ansible-playbook playbook.yml --vault-password-file vault.pass

# 使用环境变量指定密码
export ANSIBLE_VAULT_PASSWORD_FILE=./vault.pass
ansible-playbook playbook.yml

# 使用交互式密码输入
ansible-playbook playbook.yml --ask-vault-pass
\begin{verbatim}
**在角色中使用**：\par

\end{verbatim}yaml
# roles/myrole/vars/main.yml
---
db_password: !vault |
          $ANSIBLE_VAULT;1.1;AES256
          66386439653236336462303464656266396665353362363439306135353033383332376464373634
          6538663330356437623037313630386364643338363262300a346635323636346437633535373430
          37326630626463303136663539643935626639373130366232373437666235366639663236353630
          3264313861643964330a373133383561346539303838343138623431313664646239613733306432
          3462

# 在角色任务中使用
- name: Configure database
  mysql_db:
    name: app_db
    state: present
    login_password: "{{ db_password }}"
\begin{verbatim}
\subsubsection{2. Vault 密码管理}
**使用密码文件**：\par

\end{verbatim}bash
# 创建密码文件
cat > vault.pass << 'EOF'
mysecretpassword
EOF

# 设置权限
chmod 600 vault.pass

# 使用密码文件
ansible-playbook playbook.yml --vault-password-file vault.pass
\begin{verbatim}
**使用脚本生成密码**：\par

\end{verbatim}bash
# 创建密码脚本
cat > get-vault-password.sh << 'EOF'
#!/bin/bash
# 从安全存储中获取密码
aws secretsmanager get-secret-value --secret-id ansible-vault-password --query SecretString --output text
EOF

chmod +x get-vault-password.sh

# 使用脚本
ansible-playbook playbook.yml --vault-password-file get-vault-password.sh
\begin{verbatim}
**使用环境变量**：\par

\end{verbatim}bash
# 设置环境变量
export ANSIBLE_VAULT_PASSWORD=mysecretpassword

# 运行 Playbook
ansible-playbook playbook.yml
\begin{verbatim}
\subsection{Vault 的高级用法}
\subsubsection{1. 多密码管理}
Ansible 2.4+ 支持多密码管理，使用 `vault_identity_list`：\par

\end{verbatim}ini
# ansible.cfg
[defaults]
vault_identity_list = dev@./vault-dev.pass,prod@./vault-prod.pass
\begin{verbatim}
**在 Playbook 中指定身份**：\par

\end{verbatim}yaml
- name: Deploy to production
  hosts: production
  vars_files:
    - vault://prod@secrets-prod.yml
  tasks:
    - name: Configure production
      template:
        src: config.j2
        dest: /etc/app/config.conf
\begin{verbatim}
\subsubsection{2. 集成外部密钥管理系统}
**使用 HashiCorp Vault**：\par

\end{verbatim}bash
# 安装 hvac 库
pip install hvac

# 创建密码脚本
cat > vault-password.sh << 'EOF'
#!/bin/bash
VAULT_ADDR="http://localhost:8200"
VAULT_TOKEN="$(cat ~/.vault-token)"

curl -s -H "X-Vault-Token: $VAULT_TOKEN" "$VAULT_ADDR/v1/secret/ansible" | jq -r .data.password
EOF

chmod +x vault-password.sh

# 使用脚本
ansible-playbook playbook.yml --vault-password-file vault-password.sh
\begin{verbatim}
**使用 AWS Secrets Manager**：\par

\end{verbatim}bash
# 创建密码脚本
cat > aws-vault-password.sh << 'EOF'
#!/bin/bash
aws secretsmanager get-secret-value --secret-id ansible-vault --query SecretString --output text
EOF

chmod +x aws-vault-password.sh

# 使用脚本
ansible-playbook playbook.yml --vault-password-file aws-vault-password.sh
\begin{verbatim}
\subsection{Vault 的最佳实践}
1. **文件组织**\par
   - 将敏感数据与普通配置分离\par
   - 使用单独的 Vault 文件存储不同环境的凭据\par
   - 避免在单个文件中存储过多敏感信息\par
   - 考虑使用目录结构组织 Vault 文件

2. **密码管理**\par
   - 使用强密码或密钥\par
   - 定期轮换密码\par
   - 不要在版本控制系统中存储密码文件\par
   - 考虑使用外部密钥管理系统\par
   - 为不同环境使用不同的密码

3. **访问控制**\par
   - 限制对 Vault 文件的访问权限\par
   - 使用最小权限原则\par
   - 为不同团队和环境使用不同的密码\par
   - 实现审计日志\par
   - 考虑使用多因素认证

4. **工作流程**\par
   - 在开发和测试环境中使用模拟数据\par
   - 在 CI/CD 管道中安全处理 Vault 密码\par
   - 为 Vault 操作建立明确的流程和审批\par
   - 定期备份 Vault 文件\par
   - 文档化 Vault 的使用方法和流程

5. **安全性**\par
   - 定期更新 Ansible 以获取安全补丁\par
   - 使用最新的加密算法\par
   - 避免在日志中暴露敏感信息\par
   - 实现传输层加密\par
   - 定期扫描系统漏洞

6. **性能考虑**\par
   - 避免加密大型文件，这会增加处理时间\par
   - 考虑使用变量文件而非加密整个 Playbook\par
   - 对于频繁访问的加密数据，考虑使用缓存策略\par
   - 监控 Vault 操作的性能

通过合理使用 Ansible 的高级特性，包括条件判断、错误处理、异步任务和 Vault 密码管理，你可以构建更可靠、更安全、更高效的自动化流程，应对各种复杂的 IT 环境和场景。

% 第九章 最佳实践
\chapter{最佳实践}
\section{Playbooks 编写规范}
编写高质量的 Playbooks 是 Ansible 自动化成功的关键。遵循一致的编写规范可以提高代码的可读性、可维护性和可重用性。\par

\subsection{基本规范}
\subsubsection{1. 命名规范}
- **文件命名**：使用小写字母、数字和下划线，避免使用空格和特殊字符\par
  - 好的例子：`webserver.yml`, `database_setup.yml`\par
  - 坏的例子：`Web Server.yml`, `database setup.yml`

- **变量命名**：使用小写字母、数字和下划线\par
  - 好的例子：`http_port`, `database_name`\par
  - 坏的例子：`HTTPPort`, `DatabaseName`

- **任务命名**：使用描述性的名称，以动词开头\par
  - 好的例子：`Install Apache`, `Configure firewall`\par
  - 坏的例子：`Apache`, `Firewall`

- **角色命名**：使用小写字母、数字和下划线，名称要描述性\par
  - 好的例子：`apache`, `mysql`, `common`\par
  - 坏的例子：`webserver_role`, `db`

\subsubsection{2. 格式规范}
- **缩进**：使用 2 个空格进行缩进（YAML 标准）\par
- **行长度**：保持每行不超过 120 个字符\par
- **空行**：在逻辑块之间使用空行分隔\par
- **注释**：为复杂的任务和逻辑添加注释\par
- **引号**：对于包含特殊字符的字符串使用引号

**示例**：\par
\end{verbatim}yaml
---
# 安装和配置 Apache
- name: Install and configure Apache
  hosts: webservers
  become: true
  vars:
    http_port: 80
    server_name: example.com
  tasks:
    - name: Install Apache package
      yum:
        name: httpd
        state: present

    - name: Configure Apache
      template:
        src: templates/httpd.conf.j2
        dest: /etc/httpd/conf/httpd.conf
      notify: restart apache

  handlers:
    - name: restart apache
      service:
        name: httpd
        state: restarted
\begin{verbatim}
\subsubsection{3. 内容规范}
- **任务描述**：每个任务都应该有清晰的名称\par
- **幂等性**：确保任务是幂等的（多次执行产生相同结果）\par
- **错误处理**：为关键任务添加适当的错误处理\par
- **变量使用**：使用变量而不是硬编码值\par
- **模块选择**：优先使用官方模块而不是 shell 命令\par
- **参数顺序**：按照逻辑顺序排列模块参数

**示例**：\par
\end{verbatim}yaml
# 好的做法
- name: Create application directory
  file:
    path: "{{ app_dir }}"
    state: directory
    owner: "{{ app_user }}"
    group: "{{ app_group }}"
    mode: '0755'

# 坏的做法
- name: Create dir
  file: path=/opt/app state=directory owner=app group=app mode=0755
\begin{verbatim}
\subsection{高级规范}
\subsubsection{1. 任务组织}
- **逻辑分组**：将相关任务分组到同一个 Playbook 或角色中\par
- **任务顺序**：按照逻辑顺序排列任务（安装 → 配置 → 启动）\par
- **模块使用**：优先使用专用模块而不是通用模块\par
- **条件执行**：合理使用条件判断控制任务执行\par
- **循环使用**：对于重复操作使用循环

**示例**：\par
\end{verbatim}yaml
- name: Configure web server
  block:
    - name: Install required packages
      package:
        name: "{{ item }}"
        state: present
      loop:
        - httpd
        - mod_ssl
        - php

    - name: Configure firewall
      firewalld:
        service: http
        state: enabled
        permanent: true
        immediate: true

    - name: Start and enable service
      service:
        name: httpd
        state: started
        enabled: true
  become: true
\begin{verbatim}
\subsubsection{2. 变量管理}
- **变量位置**：
  - 全局变量：`group_vars/all`\par
  - 组变量：`group_vars/group_name`\par
  - 主机变量：`host_vars/host_name`\par
  - 角色变量：`roles/role_name/vars/main.yml`\par
  - 默认变量：`roles/role_name/defaults/main.yml`

- **变量优先级**：了解并合理使用变量优先级\par
- **变量命名空间**：为不同模块的变量使用命名空间\par
- **敏感变量**：使用 Ansible Vault 加密敏感变量\par
- **变量文档**：为复杂的变量添加文档

**示例**：\par
\end{verbatim}yaml
# group_vars/webservers.yml
---
# Web server configuration
webserver:
  package: httpd
  service: httpd
  port: 80
  config_dir: /etc/httpd/conf.d
  document_root: /var/www/html

# 使用命名空间变量
- name: Configure web server
  template:
    src: webserver.conf.j2
    dest: "{{ webserver.config_dir }}/site.conf"
  vars:
    server_name: "{{ webserver.server_name }}"
    document_root: "{{ webserver.document_root }}"
\begin{verbatim}
\subsubsection{3. 注释规范}
- **文件头部**：为每个 Playbook 添加头部注释，说明其用途\par
- **变量注释**：为复杂的变量添加注释说明\par
- **任务注释**：为复杂的任务添加注释，说明其目的和逻辑\par
- **逻辑注释**：为复杂的条件和循环添加注释\par
- **版本信息**：在文件头部添加版本信息和修改历史

**示例**：\par
\end{verbatim}yaml
---
# 文件名: webserver.yml
# 描述: 安装和配置 web 服务器
# 版本: 1.0
# 作者: John Doe
# 日期: 2023-01-01

- name: Install and configure web server
  hosts: webservers
  become: true
  vars:
    # HTTP 端口配置
    http_port: 80
    # 服务器名称
    server_name: example.com
  tasks:
    - name: Install Apache package
      yum:
        name: httpd
        state: present
      # 确保安装最新版本的 Apache

    - name: Configure Apache
      template:
        src: templates/httpd.conf.j2
        dest: /etc/httpd/conf/httpd.conf
      notify: restart apache
      # 配置文件模板化，支持变量替换
\begin{verbatim}
\subsubsection{4. 标签规范}
- **标签命名**：使用小写字母、数字和下划线\par
- **标签用途**：为相关的任务组添加标签\par
- **标签层次**：使用层次化的标签（如 `web:install`, `web:configure`）\par
- **标签一致性**：在整个项目中保持标签使用的一致性\par
- **标签文档**：在项目文档中记录使用的标签

**示例**：\par
\end{verbatim}yaml
- name: Install Apache
  yum:
    name: httpd
    state: present
  tags:
    - web
    - web:install

- name: Configure Apache
  template:
    src: httpd.conf.j2
    dest: /etc/httpd/conf/httpd.conf
  tags:
    - web
    - web:configure

- name: Start Apache
  service:
    name: httpd
    state: started
    enabled: true
  tags:
    - web
    - web:start
\begin{verbatim}
\subsection{最佳实践}
1. **可读性**\par
   - 保持 Playbooks 简洁明了\par
   - 使用一致的缩进和格式\par
   - 为复杂逻辑添加注释\par
   - 使用描述性的变量和任务名称

2. **可维护性**\par
   - 将复杂的 Playbooks 拆分为多个小文件\par
   - 使用角色组织相关的任务\par
   - 避免硬编码值，使用变量\par
   - 定期更新和重构 Playbooks

3. **可重用性**\par
   - 编写通用的角色和任务\par
   - 使用变量控制角色行为\par
   - 避免环境特定的硬编码\par
   - 为角色编写文档

4. **可靠性**\par
   - 确保任务是幂等的\par
   - 添加适当的错误处理\par
   - 为关键任务添加检查\par
   - 测试 Playbooks 在不同环境中的表现

5. **安全性**\par
   - 使用 Ansible Vault 加密敏感数据\par
   - 避免在 Playbooks 中存储密码\par
   - 限制特权升级的使用\par
   - 遵循最小权限原则

\section{目录结构与组织}
合理的目录结构是 Ansible 项目成功的基础。一个良好的目录结构可以提高代码的组织性、可维护性和可扩展性。\par

\subsection{基本目录结构}
\subsubsection{1. 小型项目}
对于小型项目（管理少量服务器和简单任务），可以使用简单的目录结构：\par

\end{verbatim}
ansible-project/
├── inventory/           # 库存文件
│   ├── production.ini
│   └── staging.ini
├── playbooks/           # Playbooks
│   ├── webserver.yml
│   └── database.yml
├── roles/               # 角色
│   ├── common/
│   ├── webserver/
│   └── database/
├── group_vars/          # 组变量
│   ├── all.yml
│   └── webservers.yml
├── host_vars/           # 主机变量
│   └── server1.yml
├── files/               # 静态文件
├── templates/           # 模板文件
├── ansible.cfg          # Ansible 配置
└── README.md            # 项目文档
\begin{verbatim}
\subsubsection{2. 中型项目}
对于中型项目（管理多个服务器和复杂任务），可以使用更详细的目录结构：\par

\end{verbatim}
ansible-project/
├── inventory/           # 库存文件
│   ├── production/
│   │   ├── hosts.yml
│   │   └── group_vars/
│   └── staging/
│       ├── hosts.yml
│       └── group_vars/
├── playbooks/           # Playbooks
│   ├── common/
│   │   └── setup.yml
│   ├── webserver/
│   │   ├── install.yml
│   │   └── configure.yml
│   └── database/
│       ├── install.yml
│       └── configure.yml
├── roles/               # 角色
│   ├── common/
│   ├── apache/
│   ├── mysql/
│   └── nginx/
├── collections/         # Collections
├── plugins/             # 自定义插件
│   ├── filters/
│   └── lookup/
├── library/             # 自定义模块
├── docs/                # 文档
├── tests/               # 测试
├── ansible.cfg          # Ansible 配置
├── requirements.yml     # 依赖文件
└── README.md            # 项目文档
\begin{verbatim}
\subsubsection{3. 大型项目}
对于大型项目（管理大量服务器和复杂的自动化流程），可以使用更结构化的目录结构：\par

\end{verbatim}
ansible-project/
├── environments/        # 环境配置
│   ├── production/
│   │   ├── inventory/
│   │   ├── group_vars/
│   │   ├── host_vars/
│   │   └── ansible.cfg
│   ├── staging/
│   │   ├── inventory/
│   │   ├── group_vars/
│   │   ├── host_vars/
│   │   └── ansible.cfg
│   └── development/
│       ├── inventory/
│       ├── group_vars/
│       ├── host_vars/
│       └── ansible.cfg
├── playbooks/           # Playbooks
│   ├── infrastructure/
│   │   ├── networking.yml
│   │   └── storage.yml
│   ├── applications/
│   │   ├── webapp/
│   │   └── database/
│   └── compliance/
│       └── security.yml
├── roles/               # 角色
│   ├── infrastructure/
│   │   ├── network/
│   │   └── storage/
│   ├── applications/
│   │   ├── web/
│   │   └── db/
│   └── compliance/
│       └── security/
├── collections/         # Collections
│   └── requirements.yml
├── plugins/             # 自定义插件
├── library/             # 自定义模块
├── docs/                # 文档
│   ├── architecture/
│   ├── playbooks/
│   └── roles/
├── tests/               # 测试
│   ├── integration/
│   └── unit/
├── tools/               # 工具脚本
├── ansible.cfg          # 全局配置
├── requirements.yml     # 全局依赖
└── README.md            # 项目文档
\begin{verbatim}
\subsection{目录结构详解}
\subsubsection{1. 库存目录 (inventory/)}
- **用途**：存储库存文件和环境特定的配置\par
- **文件格式**：可以使用 INI 或 YAML 格式\par
- **环境分离**：为不同环境（生产、测试、开发）创建单独的库存文件\par
- **动态库存**：对于云环境，使用动态库存脚本

**示例**：\par
\end{verbatim}
inventory/
├── production.yml       # 生产环境库存
├── staging.yml          # 测试环境库存
├── development.yml      # 开发环境库存
└── dynamic_inventory.py # 动态库存脚本
\begin{verbatim}
\subsubsection{2. Playbooks 目录 (playbooks/)}
- **用途**：存储 Playbooks 文件\par
- **组织方式**：按功能或服务组织\par
- **模块化**：将复杂的 Playbooks 拆分为多个小文件\par
- **入口文件**：创建主入口 Playbooks 文件

**示例**：\par
\end{verbatim}
playbooks/
├── site.yml             # 主入口文件
├── common/              # 通用配置
│   └── setup.yml
├── webserver/           # Web 服务器配置
│   ├── install.yml
│   ├── configure.yml
│   └── deploy.yml
└── database/            # 数据库配置
    ├── install.yml
    └── configure.yml
\begin{verbatim}
\subsubsection{3. 角色目录 (roles/)}
- **用途**：存储 Ansible 角色\par
- **标准结构**：每个角色遵循标准的目录结构\par
- **组织方式**：按功能或服务组织角色\par
- **依赖管理**：使用 meta/main.yml 管理角色依赖

**示例**：\par
\end{verbatim}
roles/
├── common/              # 通用角色
│   ├── defaults/
│   ├── files/
│   ├── handlers/
│   ├── meta/
│   ├── tasks/
│   ├── templates/
│   └── vars/
├── apache/              # Apache 角色
│   └── ...
└── mysql/               # MySQL 角色
    └── ...
\begin{verbatim}
\subsubsection{4. 变量目录 (group_vars/ 和 host_vars/)}
- **用途**：存储组变量和主机变量\par
- **文件格式**：使用 YAML 格式\par
- **组织方式**：按组名或主机名命名文件\par
- **敏感数据**：对于敏感数据，使用 Ansible Vault 加密

**示例**：\par
\end{verbatim}
group_vars/
├── all.yml              # 所有主机的变量
├── webservers.yml       # webservers 组的变量
└── databases.yml        # databases 组的变量

host_vars/
├── server1.yml          # server1 的变量
└── server2.yml          # server2 的变量
\begin{verbatim}
\subsubsection{5. 文件和模板目录 (files/ 和 templates/)}
- **用途**：存储静态文件和模板文件\par
- **组织方式**：按功能或服务组织文件\par
- **模板**：使用 Jinja2 语法创建模板文件\par
- **文件管理**：保持文件的版本控制

**示例**：\par
\end{verbatim}
files/
├── scripts/
│   ├── backup.sh
│   └── deploy.sh
└── configs/
    └── httpd.conf

templates/
├── httpd.conf.j2
├── mysql.cnf.j2
└── nginx.conf.j2
\begin{verbatim}
\subsubsection{6. 配置文件 (ansible.cfg)}
- **用途**：配置 Ansible 的行为\par
- **位置**：可以放在项目根目录或环境目录中\par
- **优先级**：项目级配置会覆盖全局配置\par
- **配置项**：根据项目需求配置合适的选项

**示例**：\par
\end{verbatim}ini
[defaults]
inventory = inventory/production.yml
roles_path = roles/
forks = 10
remote_user = ansible
become = true
become_method = sudo
become_user = root

[privilege_escalation]
become_ask_pass = false

[ssh_connection]
pipelining = true
control_path = ~/.ssh/ansible-%%r@%%h:%%p
\begin{verbatim}
\subsection{目录结构的最佳实践}
1. **一致性**\par
   - 在整个项目中保持一致的目录结构\par
   - 使用标准的命名规范\par
   - 遵循 Ansible 的最佳实践

2. **模块化**\par
   - 将功能拆分为独立的模块\par
   - 使用角色组织相关的任务\par
   - 避免大型的单文件 Playbooks

3. **环境分离**\par
   - 为不同环境创建独立的配置\par
   - 避免在代码中硬编码环境特定的值\par
   - 使用变量控制环境差异

4. **可扩展性**\par
   - 设计灵活的目录结构，支持未来扩展\par
   - 预留空间用于新的功能和服务\par
   - 考虑项目增长的需求

5. **可维护性**\par
   - 为目录和文件添加清晰的命名\par
   - 编写详细的文档\par
   - 定期清理和组织目录结构

6. **安全性**\par
   - 避免在版本控制系统中存储敏感数据\par
   - 使用 .gitignore 排除不需要版本控制的文件\par
   - 为敏感目录设置适当的权限

\section{性能优化策略}
优化 Ansible 的性能可以显著减少自动化执行时间，提高效率，特别是在管理大量服务器时。\par

\subsection{连接优化}
\subsubsection{1. SSH 优化}
- **启用 SSH 多路复用**：减少 SSH 连接建立的时间\par
- **使用 SSH 管道**：减少 SSH 命令执行的开销\par
- **调整 SSH 超时**：根据网络环境设置合适的超时时间\par
- **使用压缩**：对于慢速网络，启用 SSH 压缩

**配置示例**：\par
\end{verbatim}ini
# ansible.cfg
[ssh_connection]
pipelining = true
ssh_args = -o ControlMaster=auto -o ControlPersist=30m -o ConnectionAttempts=10 -o ConnectTimeout=10
control_path = ~/.ssh/ansible-%%r@%%h:%%p
\begin{verbatim}
\subsubsection{2. 连接插件}
- **选择合适的连接插件**：根据目标系统选择合适的连接插件\par
  - `ssh`：默认连接插件，适用于大多数系统\par
  - `local`：本地执行，适用于控制节点\par
  - `winrm`：适用于 Windows 系统\par
  - `docker`：适用于 Docker 容器\par
  - `paramiko`：纯 Python SSH 实现，作为备用

- **配置连接插件**：根据需要配置连接插件的参数

\subsection{执行优化}
\subsubsection{1. 并行执行}
- **增加 forks 值**：根据控制节点的资源和网络带宽，增加 `forks` 值\par
  - 小型环境：5-10\par
  - 中型环境：10-20\par
  - 大型环境：20-50

- **使用 serial 关键字**：对于大型部署，使用 `serial` 关键字控制并发主机数量\par
- **使用 free 策略**：对于某些场景，使用 `strategy: free` 提高并行度

**配置示例**：\par
\end{verbatim}ini
# ansible.cfg
[defaults]
forks = 20
\begin{verbatim}
**Playbook 示例**：\par
\end{verbatim}yaml
- name: Deploy application
  hosts: webservers
  serial: 5  # 一次处理 5 台主机
  strategy: free  # 自由策略，提高并行度
  tasks:
    - name: Deploy application
      copy:
        src: app.tar.gz
        dest: /opt/app/
\begin{verbatim}
\subsubsection{2. 任务优化}
- **使用高效的模块**：优先使用专用模块而不是 shell 命令\par
- **减少任务数量**：合并相关任务，减少任务总数\par
- **使用批量操作**：对于文件和包管理，使用批量操作\par
- **避免不必要的事实收集**：对于不需要事实的任务，使用 `gather_facts: false`\par
- **使用事实缓存**：启用事实缓存，减少事实收集的开销

**示例**：\par
\end{verbatim}yaml
# 好的做法：使用批量操作
- name: Install multiple packages
  yum:
    name:
      - httpd
      - mysql-server
      - php
    state: present

# 坏的做法：多个单独的任务
- name: Install Apache
  yum:
    name: httpd
    state: present

- name: Install MySQL
  yum:
    name: mysql-server
    state: present

- name: Install PHP
  yum:
    name: php
    state: present
\begin{verbatim}
\subsubsection{3. 事实收集优化}
- **选择性事实收集**：使用 `gather_subset` 只收集需要的事实\par
- **禁用事实收集**：对于不需要事实的 Playbooks，禁用事实收集\par
- **使用事实缓存**：启用事实缓存，减少重复收集

**示例**：\par
\end{verbatim}yaml
# 选择性事实收集
- name: Deploy application
  hosts: webservers
  gather_facts: true
  gather_subset:
    - hardware
    - network
  tasks:
    - name: Deploy application
      copy:
        src: app.tar.gz
        dest: /opt/app/

# 禁用事实收集
- name: Run quick task
  hosts: all
  gather_facts: false
  tasks:
    - name: Check service status
      command: systemctl status httpd
\begin{verbatim}
\subsubsection{4. 模板优化}
- **减少模板复杂度**：保持模板简洁，避免复杂的逻辑\par
- **使用条件包含**：对于大型模板，使用条件包含减少处理时间\par
- **预编译模板**：对于频繁使用的模板，考虑预编译

**示例**：\par
\end{verbatim}jinja2
# 好的做法：简洁的模板
ServerName {{ server_name }}
Listen {{ http_port }}

# 坏的做法：复杂的模板
{% if env == 'production' %}
ServerName {{ server_name }}
Listen {{ http_port }}
{% elif env == 'staging' %}
ServerName {{ server_name }}-staging
Listen {{ http_port }}
{% else %}
ServerName {{ server_name }}-dev
Listen {{ http_port }}
{% endif %}
\begin{verbatim}
\subsection{缓存优化}
\subsubsection{1. 事实缓存}
- **启用事实缓存**：减少事实收集的开销\par
- **选择缓存后端**：根据需要选择合适的缓存后端\par
  - `jsonfile`：简单的文件缓存\par
  - `redis`：高性能的内存缓存\par
  - `memcached`：分布式内存缓存

**配置示例**：\par
\end{verbatim}ini
# ansible.cfg
[defaults]
gathering = smart
fact_caching = jsonfile
fact_caching_connection = ~/.ansible/facts
fact_caching_timeout = 86400  # 24小时
\begin{verbatim}
\subsubsection{2. 模块缓存}
- **启用模块缓存**：减少模块传输的开销\par
- **配置缓存目录**：设置合适的缓存目录

**配置示例**：\par
\end{verbatim}ini
# ansible.cfg
[defaults]
module_cache = enabled
module_cache_dir = ~/.ansible/module_cache
\begin{verbatim}
\subsection{性能优化的最佳实践}
1. **连接优化**\par
   - 启用 SSH 多路复用和管道\par
   - 为不同的目标系统选择合适的连接插件\par
   - 调整 SSH 超时和重试设置

2. **并行执行**\par
   - 根据系统资源和网络带宽调整 `forks` 值\par
   - 对于大型部署，使用 `serial` 控制并发\par
   - 考虑使用 `strategy: free` 提高并行度

3. **任务优化**\par
   - 使用高效的模块，避免使用 shell 命令\par
   - 合并相关任务，减少任务总数\par
   - 使用批量操作处理多个项目\par
   - 选择性地收集事实，避免不必要的开销

4. **缓存使用**\par
   - 启用事实缓存，减少事实收集的开销\par
   - 选择合适的缓存后端\par
   - 设置合理的缓存超时时间

5. **监控和调优**\par
   - 监控 Ansible 的执行时间和资源使用\par
   - 识别性能瓶颈并进行优化\par
   - 定期测试和调整优化设置

6. **适用场景**\par
   - **小型环境**：简单的优化措施即可\par
   - **中型环境**：需要更多的优化措施\par
   - **大型环境**：需要全面的优化策略，包括并行执行、缓存和任务优化

\section{版本控制与协作}
使用版本控制系统管理 Ansible 代码是最佳实践的重要组成部分。版本控制可以跟踪代码变更、协作开发和回滚错误。\par

\subsection{版本控制基础}
\subsubsection{1. 选择版本控制系统}
- **Git**：最流行的分布式版本控制系统，推荐使用\par
- **Subversion (SVN)**：集中式版本控制系统\par
- **Mercurial**：分布式版本控制系统

**推荐**：使用 Git 作为 Ansible 项目的版本控制系统

\subsubsection{2. 基本 Git 操作}
- **初始化仓库**：`git init`\par
- **克隆仓库**：`git clone <repository>`\par
- **添加文件**：`git add <file>`\par
- **提交更改**：`git commit -m "<message>"`\par
- **推送更改**：`git push`\par
- **拉取更改**：`git pull`\par
- **分支管理**：`git branch`, `git checkout`, `git merge`

\subsection{Git 工作流程}
\subsubsection{1. 基本工作流程}
对于小型项目，可以使用简单的 Git 工作流程：\par

1. **主分支 (main/master)**：存储稳定的生产代码\par
2. **开发分支 (develop)**：集成新功能和修复\par
3. **特性分支 (feature/***)**：开发新功能\par
4. **修复分支 (bugfix/***)**：修复 bug\par
5. **发布分支 (release/***)**：准备发布

\subsubsection{2. GitFlow 工作流程}
对于大型项目，可以使用 GitFlow 工作流程：\par

1. **主分支 (main/master)**：存储稳定的生产代码\par
2. **开发分支 (develop)**：集成新功能和修复\par
3. **特性分支 (feature/***)**：从 develop 分支创建，开发完成后合并回 develop\par
4. **发布分支 (release/***)**：从 develop 分支创建，准备发布\par
5. **修复分支 (hotfix/***)**：从 main/master 分支创建，修复生产环境的紧急问题\par
6. **支持分支 (support/***)**：为旧版本提供长期支持

\subsubsection{3. GitHub Flow}
对于持续部署的项目，可以使用 GitHub Flow：\par

1. **主分支 (main)**：存储可部署的生产代码\par
2. **特性分支 (feature/***)**：从 main 分支创建\par
3. **Pull Request**：提交代码审查\par
4. **测试**：通过自动化测试\par
5. **合并**：合并到 main 分支\par
6. **部署**：自动部署到生产环境

\subsection{.gitignore 文件}
创建一个合理的 `.gitignore` 文件，排除不需要版本控制的文件：\par

\end{verbatim}gitignore
# Ansible
*.retry
ansible.cfg

# 敏感文件
*vault.yml
*vault.yaml
secrets.yml
passwords.yml

# 临时文件
*.tmp
*.temp
/tmp/

# 日志文件
*.log
logs/

# 编辑器文件
.vscode/
.idea/
*.swp
*.swo
*~

# 操作系统文件
.DS_Store
Thumbs.db

# Python
__pycache__/
*.pyc

# 环境文件
.env

# 构建文件
build/
dist/
*.egg-info/
\begin{verbatim}
\subsection{协作开发}
\subsubsection{1. 代码审查}
- **Pull Request**：使用 Pull Request 进行代码审查\par
- **代码审查工具**：使用 GitHub、GitLab 或 Bitbucket 的代码审查功能\par
- **审查标准**：建立明确的代码审查标准\par
- **反馈机制**：提供建设性的反馈和建议

\subsubsection{2. 持续集成}
- **CI/CD 管道**：集成 CI/CD 管道，如 Jenkins、GitHub Actions、GitLab CI\par
- **自动化测试**：使用 ansible-lint、molecule 等工具进行测试\par
- **部署自动化**：实现自动化部署流程\par
- **质量保证**：确保代码质量和安全性

**示例 CI 配置**：\par
\end{verbatim}yaml
# .github/workflows/ansible-test.yml
name: Ansible Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.8'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install ansible ansible-lint molecule docker
    
    - name: Lint playbooks
      run: ansible-lint
    
    - name: Test roles with molecule
      run: molecule test -s default
\begin{verbatim}
\subsubsection{3. 文档协作}
- **项目文档**：维护详细的项目文档\par
- **README 文件**：为每个项目和角色创建 README 文件\par
- **变更日志**：维护详细的变更日志\par
- **文档更新**：确保文档与代码同步更新

**README 示例**：\par
\end{verbatim}markdown
# Ansible Web Server Role

This role installs and configures Apache web server.

## Requirements

- Ansible 2.9+
- RHEL/CentOS 7+
- Debian/Ubuntu 18.04+

## Variables

| Variable | Default | Description |
|----------|---------|-------------|
| `http_port` | 80 | HTTP port |
| `server_name` | localhost | Server name |
| `document_root` | /var/www/html | Document root directory |

## Usage

\begin{verbatim}- hosts: webservers
  roles:
    - role: webserver
      vars:
        http_port: 8080
        server_name: example.com
\end{verbatim}

## License

MIT
\begin{verbatim}
\subsection{版本控制的最佳实践}
1. **代码组织**\par
   - 将 Ansible 代码与应用代码分开存储\par
   - 使用模块化的目录结构\par
   - 为不同的环境使用不同的配置

2. **提交规范**\par
   - 使用清晰、描述性的提交消息\par
   - 每个提交只包含一个逻辑更改\par
   - 提交前运行测试\par
   - 避免提交敏感数据

3. **分支管理**\par
   - 使用有意义的分支名称\par
   - 定期合并和清理分支\par
   - 避免长时间运行的功能分支\par
   - 为发布创建标签

4. **代码审查**\par
   - 实施 Pull Request 或代码审查流程\par
   - 审查代码的安全性、可靠性和效率\par
   - 提供建设性的反馈\par
   - 使用自动化工具辅助代码审查

5. **持续集成**\par
   - 集成 CI/CD 管道\par
   - 自动化测试 Playbooks\par
   - 检查代码质量和安全性\par
   - 自动部署到测试环境

6. **备份和恢复**\par
   - 使用远程 Git 仓库（GitHub、GitLab、Bitbucket）\par
   - 定期备份 Git 仓库\par
   - 建立灾难恢复计划\par
   - 测试备份的恢复流程

7. **协作开发**\par
   - 建立清晰的开发流程和规范\par
   - 使用 issue 跟踪系统管理任务\par
   - 文档化代码和流程\par
   - 定期召开团队会议讨论进展

8. **版本控制策略**\par
   - **小型项目**：使用简单的主分支和特性分支\par
   - **中型项目**：使用 GitFlow 工作流程\par
   - **大型项目**：使用完整的 GitFlow 工作流程，包括持续集成和部署

通过遵循这些最佳实践，你可以构建一个高效、可靠、可维护的 Ansible 项目，提高自动化的质量和效率。

% 第十章 实际应用场景
\chapter{实际应用场景}
\section{服务器配置管理}
服务器配置管理是 Ansible 最常见的应用场景之一。通过 Ansible，你可以自动化服务器的初始配置、软件安装、配置文件管理等任务，确保服务器配置的一致性和可重复性。\par

\subsection{基础配置管理}
\subsubsection{1. 系统初始化}
**场景**：新服务器的初始配置\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Initialize new server
  hosts: new_servers
  become: true
  vars:
    timezone: Asia/Shanghai
    ssh_port: 22
    admin_user: ansible
  tasks:
    - name: Update system packages
      package:
        name: '*'
        state: latest

    - name: Set timezone
      timezone:
        name: "{{ timezone }}"

    - name: Create admin user
      user:
        name: "{{ admin_user }}"
        groups: wheel
        shell: /bin/bash
        createhome: true

    - name: Set up sudo for admin user
      lineinfile:
        path: /etc/sudoers
        line: "{{ admin_user }} ALL=(ALL) NOPASSWD: ALL"
        validate: "visudo -cf %s"

    - name: Configure SSH
      template:
        src: templates/sshd_config.j2
        dest: /etc/ssh/sshd_config
      notify: restart ssh

    - name: Install basic packages
      package:
        name:
          - vim
          - git
          - curl
          - wget
          - tmux
          - htop
        state: present

  handlers:
    - name: restart ssh
      service:
        name: sshd
        state: restarted
\begin{verbatim}
\subsubsection{2. 安全加固}
**场景**：服务器安全配置\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Secure server
  hosts: all
  become: true
  tasks:
    - name: Install firewalld
      package:
        name: firewalld
        state: present

    - name: Start and enable firewalld
      service:
        name: firewalld
        state: started
        enabled: true

    - name: Configure firewall rules
      firewalld:
        service: "{{ item }}"
        state: enabled
        permanent: true
        immediate: true
      loop:
        - ssh
        - http
        - https

    - name: Disable unnecessary services
      service:
        name: "{{ item }}"
        state: stopped
        enabled: false
      loop:
        - avahi-daemon
        - cups
        - dhcpd
        - named

    - name: Set password complexity
      pamd:
        name: system-auth
        type: password
        control: requisite
        module_path: pam_pwquality.so
        module_arguments: "retry=3 minlen=12 dcredit=-1 ucredit=-1 ocredit=-1 lcredit=-1"
        state: present

    - name: Enable SELinux
      selinux:
        policy: targeted
        state: enforcing
\begin{verbatim}
\subsubsection{3. 配置文件管理}
**场景**：管理应用配置文件\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Manage Nginx configuration
  hosts: webservers
  become: true
  vars:
    nginx_configs:
      - name: default
        template: templates/nginx/default.conf.j2
        enabled: true
      - name: api
        template: templates/nginx/api.conf.j2
        enabled: true
  tasks:
    - name: Install Nginx
      package:
        name: nginx
        state: present

    - name: Create Nginx config directory
      file:
        path: /etc/nginx/conf.d
        state: directory
        mode: '0755'

    - name: Deploy Nginx configurations
      template:
        src: "{{ item.template }}"
        dest: "/etc/nginx/conf.d/{{ item.name }}.conf"
      loop: "{{ nginx_configs }}"
      notify: reload nginx

    - name: Enable Nginx service
      service:
        name: nginx
        state: started
        enabled: true

  handlers:
    - name: reload nginx
      service:
        name: nginx
        state: reloaded
\begin{verbatim}
\subsection{高级配置管理}
\subsubsection{1. 服务编排}
**场景**：多服务协同配置\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Deploy LAMP stack
  hosts: webservers
  become: true
  vars:
    mysql_root_password: "{{ vault_mysql_root_password }}"
    db_name: wordpress
    db_user: wp_user
    db_password: "{{ vault_db_password }}"
  tasks:
    - name: Install Apache, MySQL, PHP
      package:
        name:
          - httpd
          - mariadb-server
          - php
          - php-mysqlnd
          - php-gd
          - php-xml
          - php-mbstring
        state: present

    - name: Start and enable services
      service:
        name: "{{ item }}"
        state: started
        enabled: true
      loop:
        - httpd
        - mariadb

    - name: Set MySQL root password
      mysql_user:
        name: root
        password: "{{ mysql_root_password }}"
        host_all: true

    - name: Create database
      mysql_db:
        name: "{{ db_name }}"
        state: present

    - name: Create database user
      mysql_user:
        name: "{{ db_user }}"
        password: "{{ db_password }}"
        priv: "{{ db_name }}.*:ALL"
        state: present

    - name: Configure Apache virtual host
      template:
        src: templates/httpd/wordpress.conf.j2
        dest: /etc/httpd/conf.d/wordpress.conf
      notify: restart httpd

  handlers:
    - name: restart httpd
      service:
        name: httpd
        state: restarted
\begin{verbatim}
\subsubsection{2. 监控配置}
**场景**：服务器监控配置\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Deploy Prometheus Node Exporter
  hosts: all
  become: true
  vars:
    node_exporter_version: 1.3.1
  tasks:
    - name: Download Node Exporter
      get_url:
        url: "https://github.com/prometheus/node_exporter/releases/download/v{{ node_exporter_version }}/node_exporter-{{ node_exporter_version }}.linux-amd64.tar.gz"
        dest: /tmp/node_exporter.tar.gz

    - name: Extract Node Exporter
      unarchive:
        src: /tmp/node_exporter.tar.gz
        dest: /tmp/
        remote_src: true

    - name: Move Node Exporter binary
      copy:
        src: "/tmp/node_exporter-{{ node_exporter_version }}.linux-amd64/node_exporter"
        dest: /usr/local/bin/node_exporter
        remote_src: true
        mode: '0755'

    - name: Create Node Exporter systemd service
      template:
        src: templates/node_exporter.service.j2
        dest: /etc/systemd/system/node_exporter.service

    - name: Start and enable Node Exporter
      systemd:
        name: node_exporter
        state: started
        enabled: true
        daemon_reload: true

    - name: Configure firewall for Node Exporter
      firewalld:
        port: 9100/tcp
        state: enabled
        permanent: true
        immediate: true
\begin{verbatim}
\subsection{配置管理的最佳实践}
1. **分层配置**\par
   - 使用角色组织配置任务\par
   - 按功能模块分离配置\par
   - 使用变量控制配置差异

2. **版本控制**\par
   - 将配置文件模板纳入版本控制\par
   - 记录配置变更历史\par
   - 使用 Git 管理配置代码

3. **验证机制**\par
   - 配置变更前进行语法检查\par
   - 使用 `--check` 模式预览变更\par
   - 实施配置验证测试

4. **回滚机制**\par
   - 配置变更前备份原有配置\par
   - 实现配置回滚 Playbook\par
   - 建立配置变更审批流程

5. **监控与告警**\par
   - 监控配置文件变更\par
   - 对异常配置发出告警\par
   - 定期审计服务器配置

\section{应用部署与升级}
应用部署与升级是 Ansible 的另一个重要应用场景。通过 Ansible，你可以自动化应用的打包、部署、升级和回滚等流程，提高部署效率和可靠性。\par

\subsection{基础应用部署}
\subsubsection{1. 静态网站部署}
**场景**：部署静态网站\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Deploy static website
  hosts: webservers
  become: true
  vars:
    website_name: example.com
    document_root: /var/www/{{ website_name }}
    website_files: ./website/
  tasks:
    - name: Install Nginx
      package:
        name: nginx
        state: present

    - name: Create document root directory
      file:
        path: "{{ document_root }}"
        state: directory
        mode: '0755'

    - name: Deploy website files
      copy:
        src: "{{ website_files }}"
        dest: "{{ document_root }}"
        directory_mode: '0755'

    - name: Configure Nginx virtual host
      template:
        src: templates/nginx/static_site.conf.j2
        dest: /etc/nginx/conf.d/{{ website_name }}.conf
      notify: reload nginx

    - name: Start and enable Nginx
      service:
        name: nginx
        state: started
        enabled: true

  handlers:
    - name: reload nginx
      service:
        name: nginx
        state: reloaded
\begin{verbatim}
\subsubsection{2. 动态应用部署}
**场景**：部署 PHP/ Python 等动态应用\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Deploy Python Flask application
  hosts: app_servers
  become: true
  vars:
    app_name: myapp
    app_dir: /opt/{{ app_name }}
    venv_dir: /opt/{{ app_name }}/venv
    python_version: 3.8
    app_port: 5000
  tasks:
    - name: Install dependencies
      package:
        name:
          - python{{ python_version }}
          - python{{ python_version }}-pip
          - python{{ python_version }}-venv
          - git
        state: present

    - name: Create application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        mode: '0755'

    - name: Clone application repository
      git:
        repo: https://github.com/username/{{ app_name }}.git
        dest: "{{ app_dir }}"
        version: main

    - name: Create virtual environment
      command:
        cmd: python{{ python_version }} -m venv {{ venv_dir }}
        creates: "{{ venv_dir }}"

    - name: Install Python dependencies
      pip:
        requirements: "{{ app_dir }}/requirements.txt"
        virtualenv: "{{ venv_dir }}"

    - name: Create systemd service
      template:
        src: templates/{{ app_name }}.service.j2
        dest: /etc/systemd/system/{{ app_name }}.service

    - name: Start and enable application
      systemd:
        name: "{{ app_name }}"
        state: started
        enabled: true
        daemon_reload: true

    - name: Configure firewall
      firewalld:
        port: "{{ app_port }}/tcp"
        state: enabled
        permanent: true
        immediate: true
\begin{verbatim}
\subsection{高级应用部署}
\subsubsection{1. 容器化应用部署}
**场景**：使用 Docker 部署容器化应用\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Deploy Docker application
  hosts: docker_servers
  become: true
  vars:
    app_name: webapp
    docker_compose_file: ./docker-compose.yml
  tasks:
    - name: Install Docker
      package:
        name: docker
        state: present

    - name: Install Docker Compose
      get_url:
        url: https://github.com/docker/compose/releases/download/v2.2.3/docker-compose-Linux-x86_64
        dest: /usr/local/bin/docker-compose
        mode: '0755'

    - name: Start and enable Docker
      service:
        name: docker
        state: started
        enabled: true

    - name: Create application directory
      file:
        path: /opt/{{ app_name }}
        state: directory
        mode: '0755'

    - name: Copy Docker Compose file
      copy:
        src: "{{ docker_compose_file }}"
        dest: /opt/{{ app_name }}/docker-compose.yml

    - name: Deploy application with Docker Compose
      community.docker.docker_compose:
        project_src: /opt/{{ app_name }}
        state: present
        pull: true
\begin{verbatim}
\subsubsection{2. 应用升级与回滚}
**场景**：应用版本升级与回滚\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Upgrade application
  hosts: app_servers
  become: true
  vars:
    app_name: myapp
    app_dir: /opt/{{ app_name }}
    backup_dir: /opt/{{ app_name }}_backup
    new_version: 2.0.0
  tasks:
    - name: Create backup directory
      file:
        path: "{{ backup_dir }}"
        state: directory
        mode: '0755'

    - name: Backup current application
      copy:
        src: "{{ app_dir }}"
        dest: "{{ backup_dir }}"
        remote_src: true

    - name: Download new version
      get_url:
        url: "https://example.com/{{ app_name }}-{{ new_version }}.tar.gz"
        dest: /tmp/{{ app_name }}.tar.gz

    - name: Extract new version
      unarchive:
        src: /tmp/{{ app_name }}.tar.gz
        dest: /tmp/
        remote_src: true

    - name: Deploy new version
      copy:
        src: "/tmp/{{ app_name }}-{{ new_version }}/"
        dest: "{{ app_dir }}"
        remote_src: true
      notify: restart application

  handlers:
    - name: restart application
      service:
        name: "{{ app_name }}"
        state: restarted

# 回滚 Playbook
- name: Rollback application
  hosts: app_servers
  become: true
  vars:
    app_name: myapp
    app_dir: /opt/{{ app_name }}
    backup_dir: /opt/{{ app_name }}_backup
  tasks:
    - name: Stop application
      service:
        name: "{{ app_name }}"
        state: stopped

    - name: Restore from backup
      copy:
        src: "{{ backup_dir }}"
        dest: "{{ app_dir }}"
        remote_src: true

    - name: Start application
      service:
        name: "{{ app_name }}"
        state: started
\begin{verbatim}
\subsection{应用部署的最佳实践}
1. **环境分离**\par
   - 为开发、测试、生产环境创建独立的部署 Playbook\par
   - 使用不同的变量文件控制环境差异\par
   - 实施环境隔离措施

2. **自动化测试**\par
   - 部署前运行单元测试\par
   - 部署后运行集成测试\par
   - 实施冒烟测试验证部署成功

3. **版本管理**\par
   - 对应用代码和配置进行版本控制\par
   - 使用标签标记重要版本\par
   - 记录版本变更日志

4. **部署策略**\par
   - **蓝绿部署**：通过切换流量实现零 downtime 部署\par
   - **滚动部署**：逐步更新服务器，降低风险\par
   - **金丝雀部署**：先在少量服务器上测试，再全面部署

5. **监控与告警**\par
   - 监控应用部署过程\par
   - 对部署失败发出告警\par
   - 监控应用运行状态

6. **安全性**\par
   - 部署过程中保护敏感信息\par
   - 验证应用包的完整性\par
   - 实施部署权限控制

\section{云资源管理}
云资源管理是 Ansible 的一个重要应用场景。通过 Ansible，你可以自动化云资源的创建、配置、管理和销毁等任务，实现云基础设施的即代码（Infrastructure as Code）管理。\par

\subsection{基础云资源管理}
\subsubsection{1. AWS 资源管理}
**场景**：管理 AWS EC2 实例\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Manage AWS EC2 instances
  hosts: localhost
  gather_facts: false
  vars:
    aws_region: us-east-1
    ec2_instance_name: web-server
    ec2_instance_type: t2.micro
    ec2_ami: ami-0c55b159cbfafe1f0  # Amazon Linux 2 AMI
    ec2_key_name: my-key
    ec2_security_group: web-sg
  tasks:
    - name: Create security group
      amazon.aws.ec2_security_group:
        name: "{{ ec2_security_group }}"
        description: Web server security group
        region: "{{ aws_region }}"
        rules:
          - proto: tcp
            ports:
              - 22
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            ports:
              - 80
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            ports:
              - 443
            cidr_ip: 0.0.0.0/0
        state: present

    - name: Launch EC2 instance
      amazon.aws.ec2_instance:
        name: "{{ ec2_instance_name }}"
        key_name: "{{ ec2_key_name }}"
        instance_type: "{{ ec2_instance_type }}"
        image_id: "{{ ec2_ami }}"
        security_group: "{{ ec2_security_group }}"
        region: "{{ aws_region }}"
        wait: true
        count: 1
        tags:
          Environment: Production
          Application: Web Server
      register: ec2_result

    - name: Display EC2 instance information
      debug:
        msg:
          - "Instance ID: {{ ec2_result.instances[0].instance_id }}"
          - "Public IP: {{ ec2_result.instances[0].public_ip_address }}"
          - "Private IP: {{ ec2_result.instances[0].private_ip_address }}"
\begin{verbatim}
\subsubsection{2. Azure 资源管理}
**场景**：管理 Azure 虚拟机\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Manage Azure virtual machines
  hosts: localhost
  gather_facts: false
  vars:
    azure_resource_group: my-resource-group
    azure_location: eastus
    azure_vm_name: web-server
    azure_vm_size: Standard_B1s
    azure_admin_username: azureuser
    azure_admin_password: MyPassword12345!
  tasks:
    - name: Create resource group
      azure.azcollection.azure_rm_resourcegroup:
        name: "{{ azure_resource_group }}"
        location: "{{ azure_location }}"
        state: present

    - name: Create virtual network
      azure.azcollection.azure_rm_virtualnetwork:
        resource_group: "{{ azure_resource_group }}"
        name: my-vnet
        address_prefixes: "10.0.0.0/16"

    - name: Create subnet
      azure.azcollection.azure_rm_subnet:
        resource_group: "{{ azure_resource_group }}"
        name: my-subnet
        address_prefix: "10.0.1.0/24"
        virtual_network: my-vnet

    - name: Create security group
      azure.azcollection.azure_rm_securitygroup:
        resource_group: "{{ azure_resource_group }}"
        name: my-sg
        rules:
          - name: SSH
            protocol: Tcp
            destination_port_range: 22
            access: Allow
            priority: 1001
            direction: Inbound
          - name: HTTP
            protocol: Tcp
            destination_port_range: 80
            access: Allow
            priority: 1002
            direction: Inbound

    - name: Create public IP address
      azure.azcollection.azure_rm_publicipaddress:
        resource_group: "{{ azure_resource_group }}"
        allocation_method: Dynamic
        name: my-public-ip

    - name: Create virtual machine
      azure.azcollection.azure_rm_virtualmachine:
        resource_group: "{{ azure_resource_group }}"
        name: "{{ azure_vm_name }}"
        vm_size: "{{ azure_vm_size }}"
        admin_username: "{{ azure_admin_username }}"
        admin_password: "{{ azure_admin_password }}"
        network_interfaces: my-nic
        image:
          offer: UbuntuServer
          publisher: Canonical
          sku: 18.04-LTS
          version: latest

    - name: Create network interface
      azure.azcollection.azure_rm_networkinterface:
        resource_group: "{{ azure_resource_group }}"
        name: my-nic
        virtual_network: my-vnet
        subnet: my-subnet
        public_ip_name: my-public-ip
        security_group: my-sg
\begin{verbatim}
\subsubsection{3. GCP 资源管理}
**场景**：管理 GCP 计算实例\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Manage GCP compute instances
  hosts: localhost
  gather_facts: false
  vars:
    gcp_project: my-project
    gcp_zone: us-central1-a
    gcp_instance_name: web-server
    gcp_machine_type: n1-standard-1
    gcp_image_family: debian-10
    gcp_image_project: debian-cloud
  tasks:
    - name: Create GCP compute instance
      google.cloud.gcp_compute_instance:
        name: "{{ gcp_instance_name }}"
        project: "{{ gcp_project }}"
        zone: "{{ gcp_zone }}"
        machine_type: "{{ gcp_machine_type }}"
        disks:
          - auto_delete: true
            boot: true
            initialize_params:
              image_family: "{{ gcp_image_family }}"
              image_project: "{{ gcp_image_project }}"
        network_interfaces:
          - network: default
            access_configs:
              - name: External NAT
                type: ONE_TO_ONE_NAT
        tags:
          items:
            - web-server
            - http-server
            - https-server
        state: present
      register: gcp_result

    - name: Display GCP instance information
      debug:
        msg:
          - "Instance ID: {{ gcp_result.instance.id }}"
          - "Public IP: {{ gcp_result.instance.networkInterfaces[0].accessConfigs[0].natIP }}"
          - "Private IP: {{ gcp_result.instance.networkInterfaces[0].networkIP }}"
\begin{verbatim}
\subsection{高级云资源管理}
\subsubsection{1. 云资源编排}
**场景**：使用 Ansible 编排多个云资源\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Deploy complete web application stack
  hosts: localhost
  gather_facts: false
  vars:
    project_name: my-web-app
    aws_region: us-east-1
    ec2_instance_type: t2.micro
    rds_instance_type: db.t2.micro
    rds_db_name: myappdb
    rds_db_user: dbuser
    rds_db_password: MyDBPassword123
  tasks:
    - name: Create VPC
      amazon.aws.ec2_vpc_net:
        name: "{{ project_name }}-vpc"
        cidr_block: 10.0.0.0/16
        region: "{{ aws_region }}"
        state: present
      register: vpc_result

    - name: Create public subnet
      amazon.aws.ec2_vpc_subnet:
        vpc_id: "{{ vpc_result.vpc.id }}"
        cidr: 10.0.1.0/24
        az: "{{ aws_region }}a"
        region: "{{ aws_region }}"
        state: present
        map_public: true
      register: public_subnet_result

    - name: Create private subnet
      amazon.aws.ec2_vpc_subnet:
        vpc_id: "{{ vpc_result.vpc.id }}"
        cidr: 10.0.2.0/24
        az: "{{ aws_region }}a"
        region: "{{ aws_region }}"
        state: present
        map_public: false
      register: private_subnet_result

    - name: Create security groups
      amazon.aws.ec2_security_group:
        name: "{{ item.name }}"
        description: "{{ item.description }}"
        vpc_id: "{{ vpc_result.vpc.id }}"
        region: "{{ aws_region }}"
        rules: "{{ item.rules }}"
        state: present
      loop:
        - name: "{{ project_name }}-web-sg"
          description: Web server security group
          rules:
            - proto: tcp
              ports: 22
              cidr_ip: 0.0.0.0/0
            - proto: tcp
              ports: 80
              cidr_ip: 0.0.0.0/0
            - proto: tcp
              ports: 443
              cidr_ip: 0.0.0.0/0
        - name: "{{ project_name }}-db-sg"
          description: Database security group
          rules:
            - proto: tcp
              ports: 3306
              cidr_ip: 10.0.1.0/24

    - name: Launch web server instance
      amazon.aws.ec2_instance:
        name: "{{ project_name }}-web"
        key_name: my-key
        instance_type: "{{ ec2_instance_type }}"
        image_id: ami-0c55b159cbfafe1f0
        security_group: "{{ project_name }}-web-sg"
        subnet_id: "{{ public_subnet_result.subnet.id }}"
        region: "{{ aws_region }}"
        wait: true
        tags:
          Name: "{{ project_name }}-web"
          Environment: Production
      register: ec2_result

    - name: Create RDS instance
      community.aws.rds_instance:
        db_instance_identifier: "{{ project_name }}-db"
        state: present
        engine: mysql
        engine_version: "8.0"
        db_instance_class: "{{ rds_instance_type }}"
        username: "{{ rds_db_user }}"
        password: "{{ rds_db_password }}"
        db_name: "{{ rds_db_name }}"
        allocated_storage: 20
        vpc_security_group_ids:
          - "{{ project_name }}-db-sg"
        db_subnet_group_name: "{{ project_name }}-db-subnet-group"
        region: "{{ aws_region }}"
        tags:
          Name: "{{ project_name }}-db"
          Environment: Production

    - name: Create DB subnet group
      community.aws.rds_subnet_group:
        name: "{{ project_name }}-db-subnet-group"
        state: present
        description: DB subnet group
        subnet_ids:
          - "{{ private_subnet_result.subnet.id }}"
        region: "{{ aws_region }}"

    - name: Display deployment information
      debug:
        msg:
          - "Web Server Public IP: {{ ec2_result.instances[0].public_ip_address }}"
          - "RDS Endpoint: {{ rds_result.endpoint }}"
\begin{verbatim}
\subsection{云资源管理的最佳实践}
1. **基础设施即代码**\par
   - 将所有云资源定义为代码\par
   - 使用版本控制管理基础设施代码\par
   - 实施基础设施代码审查

2. **环境一致性**\par
   - 使用相同的代码创建不同环境的资源\par
   - 通过变量控制环境差异\par
   - 确保开发、测试、生产环境的一致性

3. **资源标签**\par
   - 为所有云资源添加统一的标签\par
   - 使用标签进行资源管理和成本分配\par
   - 建立标签命名规范

4. **安全管理**\par
   - 使用 Ansible Vault 加密云凭证\par
   - 实施最小权限原则\par
   - 定期轮换云凭证

5. **成本管理**\par
   - 自动化资源的创建和销毁\par
   - 监控云资源使用情况\par
   - 实施资源使用限制

6. **灾难恢复**\par
   - 自动化云资源的备份\par
   - 实现跨区域资源部署\par
   - 建立灾难恢复演练流程

\section{网络设备自动化}
网络设备自动化是 Ansible 的一个重要应用场景。通过 Ansible，你可以自动化网络设备的配置、管理和监控等任务，提高网络管理效率和可靠性。\par

\subsection{基础网络自动化}
\subsubsection{1. Cisco 设备配置}
**场景**：配置 Cisco 交换机\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Configure Cisco switch
  hosts: cisco_switches
  gather_facts: false
  connection: network_cli
  vars:
    vlans:
      - id: 10
        name: Management
      - id: 20
        name: Users
      - id: 30
        name: Servers
  tasks:
    - name: Configure hostname
      cisco.ios.ios_config:
        lines:
          - hostname {{ inventory_hostname }}

    - name: Configure NTP
      cisco.ios.ios_config:
        lines:
          - ntp server 10.0.0.1
          - ntp server 10.0.0.2

    - name: Configure VLANs
      cisco.ios.ios_vlan:
        vlan_id: "{{ item.id }}"
        name: "{{ item.name }}"
        state: present
      loop: "{{ vlans }}"

    - name: Configure interface
      cisco.ios.ios_interface:
        name: GigabitEthernet1/0/1
        description: Uplink to Core
        mode: access
        access_vlan: 10

    - name: Configure trunk interface
      cisco.ios.ios_interface:
        name: GigabitEthernet1/0/24
        description: Trunk to Distribution
        mode: trunk
        trunk_allowed_vlans: "10,20,30"

    - name: Save configuration
      cisco.ios.ios_command:
        commands: write memory
\begin{verbatim}
\subsubsection{2. Juniper 设备配置}
**场景**：配置 Juniper 路由器\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Configure Juniper router
  hosts: juniper_routers
  gather_facts: false
  connection: netconf
  vars:
    bgp_as: 65000
    bgp_neighbors:
      - ip: 10.0.0.1
        as: 65001
      - ip: 10.0.0.2
        as: 65002
  tasks:
    - name: Configure system settings
      junipernetworks.junos.junos_config:
        lines:
          - set system host-name {{ inventory_hostname }}
          - set system time-zone UTC
          - set system name-server 8.8.8.8
          - set system name-server 8.8.4.4

    - name: Configure interfaces
      junipernetworks.junos.junos_config:
        lines:
          - set interfaces ge-0/0/0 unit 0 family inet address 10.0.0.10/24
          - set interfaces ge-0/0/1 unit 0 family inet address 20.0.0.10/24

    - name: Configure BGP
      junipernetworks.junos.junos_config:
        lines:
          - set routing-options autonomous-system {{ bgp_as }}

    - name: Configure BGP neighbors
      junipernetworks.junos.junos_config:
        lines:
          - set protocols bgp group external neighbor {{ item.ip }} peer-as {{ item.as }}
      loop: "{{ bgp_neighbors }}"

    - name: Commit configuration
      junipernetworks.junos.junos_config:
        commit: true
\begin{verbatim}
\subsection{高级网络自动化}
\subsubsection{1. 网络配置备份}
**场景**：备份网络设备配置\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Backup network device configurations
  hosts: network_devices
  gather_facts: false
  vars:
    backup_dir: ./backups
  tasks:
    - name: Create backup directory
      file:
        path: "{{ backup_dir }}"
        state: directory
      delegate_to: localhost
      run_once: true

    - name: Backup Cisco IOS configuration
      cisco.ios.ios_command:
        commands: show running-config
      register: config_output
      when: ansible_network_os == 'ios'

    - name: Backup Juniper Junos configuration
      junipernetworks.junos.junos_command:
        commands: show configuration
      register: config_output
      when: ansible_network_os == 'junos'

    - name: Backup Arista EOS configuration
      arista.eos.eos_command:
        commands: show running-config
      register: config_output
      when: ansible_network_os == 'eos'

    - name: Save configuration to file
      copy:
        content: "{{ config_output.stdout[0] }}"
        dest: "{{ backup_dir }}/{{ inventory_hostname }}_{{ ansible_date_time.iso8601 }}.cfg"
      delegate_to: localhost
\begin{verbatim}
\subsubsection{2. 网络设备监控}
**场景**：监控网络设备状态\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Monitor network devices
  hosts: network_devices
  gather_facts: false
  vars:
    monitor_commands:
      - show interface status
      - show interface counters errors
      - show version
  tasks:
    - name: Run monitoring commands
      ios_command:
        commands: "{{ monitor_commands }}"
      register: monitor_output
      when: ansible_network_os == 'ios'

    - name: Analyze interface status
      debug:
        msg: "Interface issues found on {{ inventory_hostname }}"
      when:
        - ansible_network_os == 'ios'
        - 'err-disabled' in monitor_output.stdout[0]

    - name: Analyze interface errors
      debug:
        msg: "Interface errors found on {{ inventory_hostname }}"
      when:
        - ansible_network_os == 'ios'
        - 'CRC' in monitor_output.stdout[1]

    - name: Check firmware version
      debug:
        msg: "Firmware version on {{ inventory_hostname }}: {{ monitor_output.stdout[2] | regex_search('Version [0-9.]+') }}"
      when: ansible_network_os == 'ios'
\begin{verbatim}
\subsection{网络自动化的最佳实践}
1. **标准化配置**\par
   - 建立网络设备配置标准\par
   - 使用模板管理配置文件\par
   - 实施配置变更审批流程

2. **版本控制**\par
   - 对网络配置进行版本控制\par
   - 记录配置变更历史\par
   - 实现配置回滚机制

3. **自动化测试**\par
   - 配置变更前进行语法检查\par
   - 部署后验证网络连接性\par
   - 实施网络健康检查

4. **监控与告警**\par
   - 监控网络设备状态\par
   - 对异常配置和状态发出告警\par
   - 定期审计网络配置

5. **安全性**\par
   - 保护网络设备凭证\par
   - 实施网络设备访问控制\par
   - 定期更新网络设备固件

6. **文档化**\par
   - 维护网络拓扑文档\par
   - 记录网络设备配置说明\par
   - 建立网络自动化流程文档

\section{持续集成与持续部署}
持续集成与持续部署（CI/CD）是 Ansible 的一个重要应用场景。通过 Ansible，你可以将自动化部署集成到 CI/CD 管道中，实现代码提交到部署的全自动化流程。\par

\subsection{基础 CI/CD 集成}
\subsubsection{1. Jenkins 集成}
**场景**：使用 Jenkins 与 Ansible 实现 CI/CD\par

**Jenkins Pipeline 示例**：\par
\end{verbatim}groovy
pipeline {
    agent any
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        stage('Test') {
            steps {
                sh 'pytest'
            }
        }
        stage('Build') {
            steps {
                sh 'docker build -t myapp:${BUILD_NUMBER} .'
            }
        }
        stage('Deploy') {
            steps {
                sh 'ansible-playbook -i inventory/production.yml playbooks/deploy.yml --extra-vars "app_version=${BUILD_NUMBER}"'
            }
        }
        stage('Verify') {
            steps {
                sh 'ansible-playbook -i inventory/production.yml playbooks/verify.yml'
            }
        }
    }
    post {
        success {
            echo 'Deployment successful!'
        }
        failure {
            echo 'Deployment failed!'
            sh 'ansible-playbook -i inventory/production.yml playbooks/rollback.yml'
        }
    }
}
\begin{verbatim}
**Ansible Deploy Playbook**：\par
\end{verbatim}yaml
---
- name: Deploy application
  hosts: app_servers
  become: true
  vars:
    app_version: "{{ app_version }}"
    app_image: "myapp:{{ app_version }}"
  tasks:
    - name: Pull Docker image
      docker_image:
        name: "{{ app_image }}"
        source: pull

    - name: Stop existing container
      docker_container:
        name: myapp
        state: stopped
      ignore_errors: true

    - name: Remove existing container
      docker_container:
        name: myapp
        state: absent
      ignore_errors: true

    - name: Run new container
      docker_container:
        name: myapp
        image: "{{ app_image }}"
        ports:
          - "80:80"
        env:
          ENVIRONMENT: production
          DATABASE_URL: "{{ database_url }}"
        state: started
\begin{verbatim}
\subsubsection{2. GitHub Actions 集成}
**场景**：使用 GitHub Actions 与 Ansible 实现 CI/CD\par

**GitHub Actions Workflow 示例**：\par
\end{verbatim}yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.8'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pytest
    - name: Run tests
      run: pytest

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.8'
    - name: Install Ansible
      run: pip install ansible
    - name: Add SSH key
      uses: webfactory/ssh-agent@v0.5.3
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
    - name: Deploy with Ansible
      run: |
        ansible-playbook -i inventory/production.yml playbooks/deploy.yml
      env:
        ANSIBLE_VAULT_PASSWORD_FILE: <(echo "${{ secrets.ANSIBLE_VAULT_PASSWORD }}")
\begin{verbatim}
\subsection{高级 CI/CD 集成}
\subsubsection{1. 多环境部署}
**场景**：实现开发、测试、生产环境的自动化部署\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Deploy to multiple environments
  hosts: "{{ target_environment }}"
  become: true
  vars:
    app_version: "{{ app_version | default('latest') }}"
  tasks:
    - name: Deploy to development
      include_tasks: tasks/deploy_dev.yml
      when: target_environment == 'development'

    - name: Deploy to staging
      include_tasks: tasks/deploy_staging.yml
      when: target_environment == 'staging'

    - name: Deploy to production
      include_tasks: tasks/deploy_prod.yml
      when: target_environment == 'production'

    - name: Run health check
      uri:
        url: "http://{{ inventory_hostname }}/health"
        status_code: 200
      register: health_check
      retries: 10
      delay: 5
      until: health_check.status == 200
\begin{verbatim}
\subsubsection{2. 部署回滚}
**场景**：自动化部署回滚\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Rollback application deployment
  hosts: app_servers
  become: true
  vars:
    rollback_version: "{{ rollback_version }}"
  tasks:
    - name: Stop current container
      docker_container:
        name: myapp
        state: stopped

    - name: Remove current container
      docker_container:
        name: myapp
        state: absent

    - name: Run rollback container
      docker_container:
        name: myapp
        image: "myapp:{{ rollback_version }}"
        ports:
          - "80:80"
        env:
          ENVIRONMENT: production
          DATABASE_URL: "{{ database_url }}"
        state: started

    - name: Verify rollback
      uri:
        url: "http://{{ inventory_hostname }}/health"
        status_code: 200
      register: health_check
      retries: 5
      delay: 3
      until: health_check.status == 200

    - name: Notify rollback successful
      slack:
        token: "{{ slack_token }}"
        msg: "Rollback to version {{ rollback_version }} successful on {{ inventory_hostname }}"
      delegate_to: localhost
      when: health_check.status == 200
\begin{verbatim}
\subsection{CI/CD 集成的最佳实践}
1. **自动化流程**\par
   - 实现从代码提交到部署的全自动化\par
   - 减少人工干预，提高部署效率\par
   - 建立标准化的部署流程

2. **测试集成**\par
   - 部署前运行单元测试\par
   - 部署后运行集成测试\par
   - 实施冒烟测试验证部署成功

3. **环境一致性**\par
   - 使用相同的部署流程部署不同环境\par
   - 通过变量控制环境差异\par
   - 确保开发、测试、生产环境的一致性

4. **部署策略**\par
   - 实施蓝绿部署或滚动部署\par
   - 实现零 downtime 部署\par
   - 建立部署审批机制

5. **监控与告警**\par
   - 监控部署过程\par
   - 对部署失败发出告警\par
   - 监控应用运行状态

6. **安全性**\par
   - 保护部署凭证和敏感信息\par
   - 验证代码和容器镜像的完整性\par
   - 实施部署权限控制

7. **文档化**\par
   - 记录 CI/CD 流程和配置\par
   - 为部署 Playbooks 编写文档\par
   - 建立部署故障排查指南

通过 Ansible 在各种实际应用场景中的使用，你可以实现 IT 基础设施的全面自动化，提高效率，减少人为错误，确保系统的一致性和可靠性。无论是服务器配置、应用部署、云资源管理、网络自动化还是 CI/CD 集成，Ansible 都能为你提供强大的自动化能力。

% 第十一章 故障排查
\chapter{故障排查}
\section{常见错误与解决方法}
在使用 Ansible 的过程中，你可能会遇到各种错误。了解常见错误及其解决方法，可以帮助你更快地排查和解决问题。\par

\subsection{连接错误}
\subsubsection{1. SSH 连接失败}
**错误信息**：`Failed to connect to the host via ssh`\par

**可能原因**：\par
- SSH 服务未运行\par
- 网络连接问题\par
- 防火墙阻止连接\par
- SSH 密钥或密码错误\par
- 主机名解析失败\par

**解决方法**：\par
1. 检查目标主机的 SSH 服务是否运行：`systemctl status sshd`\par
2. 验证网络连接：`ping <host>`\par
3. 检查防火墙规则：`sudo iptables -L`\par
4. 验证 SSH 密钥是否正确配置\par
5. 检查主机名是否在 /etc/hosts 或 DNS 中正确配置\par

**Playbook 示例**：使用 `wait_for` 模块检查 SSH 连接\par
\end{verbatim}yaml
---
- name: Check SSH connectivity
  hosts: all
  gather_facts: false
  tasks:
    - name: Wait for SSH to be available
      wait_for:
        host: "{{ inventory_hostname }}"
        port: 22
        timeout: 300
        state: started
      delegate_to: localhost
\begin{verbatim}
\subsubsection{2. 权限错误}
**错误信息**：`Permission denied`\par

**可能原因**：\par
- 用户权限不足\par
- 文件或目录权限错误\par
- SELinux 或 AppArmor 限制\par

**解决方法**：\par
1. 使用 `become: true` 提升权限\par
2. 检查文件权限：`ls -la <file>`\par
3. 调整文件权限：`chmod <permissions> <file>`\par
4. 检查 SELinux 状态：`sestatus`\par
5. 临时禁用 SELinux 进行测试：`setenforce 0`\par

**Playbook 示例**：使用 `become` 提升权限\par
\end{verbatim}yaml
---
- name: Install package with elevated privileges
  hosts: all
  become: true
  tasks:
    - name: Install nginx
      package:
        name: nginx
        state: present
\begin{verbatim}
\subsection{Playbook 错误}
\subsubsection{1. 语法错误}
**错误信息**：`Syntax Error while loading YAML`\par

**可能原因**：\par
- 缩进错误\par
- 缺少冒号\par
- 引号使用不当\par
- 列表格式错误\par

**解决方法**：\par
1. 使用 YAML 验证工具检查语法\par
2. 确保缩进一致（使用空格而非制表符）\par
3. 检查所有键值对后是否有冒号\par
4. 确保字符串中的引号正确嵌套\par

**示例**：正确的 YAML 格式\par
\end{verbatim}yaml
---
- name: Correct YAML example
  hosts: all
  vars:
    web_server: nginx
    ports:
      - 80
      - 443
  tasks:
    - name: Install web server
      package:
        name: "{{ web_server }}"
        state: present
\begin{verbatim}
\subsubsection{2. 模块错误}
**错误信息**：`ModuleNotFoundError` 或模块特定错误\par

**可能原因**：\par
- 模块不存在\par
- 模块参数错误\par
- 模块依赖未安装\par

**解决方法**：\par
1. 检查模块名称是否正确\par
2. 查看模块文档：`ansible-doc <module>`\par
3. 安装模块依赖\par
4. 确保使用正确的模块参数\par

**示例**：查看模块文档\par
\end{verbatim}bash
ansible-doc copy
ansible-doc package
ansible-doc service
\begin{verbatim}
\subsection{执行错误}
\subsubsection{1. 任务失败}
**错误信息**：`FAILED! => {...}`\par

**可能原因**：\par
- 命令执行失败\par
- 资源不存在\par
- 配置错误\par
- 依赖问题\par

**解决方法**：\par
1. 仔细阅读错误信息，了解失败原因\par
2. 在目标主机上手动执行命令，查看详细错误\par
3. 检查相关配置文件\par
4. 确保所有依赖都已安装\par

**Playbook 示例**：使用 `ignore_errors` 和 `register` 处理错误\par
\end{verbatim}yaml
---
- name: Handle task failures
  hosts: all
  tasks:
    - name: Run command with error handling
      command:
        cmd: some_command_that_might_fail
      register: command_result
      ignore_errors: true

    - name: Check command result
      debug:
        msg: "Command failed with output: {{ command_result.stderr }}"
      when: command_result.failed

    - name: Continue with other tasks
      debug:
        msg: "Continuing execution..."
\begin{verbatim}
\subsubsection{2. 超时错误}
**错误信息**：`Timeout`\par

**可能原因**：\par
- 任务执行时间过长\par
- 网络连接缓慢\par
- 目标主机负载过高\par

**解决方法**：\par
1. 增加任务超时时间：`async: <seconds> poll: <seconds>`\par
2. 优化任务执行时间\par
3. 检查目标主机性能\par
4. 考虑使用异步任务\par

**Playbook 示例**：使用异步任务\par
\end{verbatim}yaml
---
- name: Use asynchronous task
  hosts: all
  tasks:
    - name: Long running task
      command:
        cmd: sleep 300
      async: 360
      poll: 0
      register: long_task

    - name: Continue with other tasks
      debug:
        msg: "Continuing while long task runs in background"

    - name: Wait for long task to complete
      async_status:
        jid: "{{ long_task.ansible_job_id }}"
      register: job_result
      until: job_result.finished
      retries: 30
      delay: 10
\begin{verbatim}
\section{调试技巧与工具}
Ansible 提供了多种调试工具和技巧，可以帮助你排查和解决问题。掌握这些调试方法，可以大大提高你的故障排查效率。\par

\subsection{基础调试技巧}
\subsubsection{1. 使用 --verbose 选项}
**功能**：增加输出详细程度，显示更多执行信息\par

**使用方法**：\par
\end{verbatim}bash
# 基本详细输出
ansible-playbook playbook.yml -v

# 更详细的输出
ansible-playbook playbook.yml -vv

# 最详细的输出（包括模块参数）
ansible-playbook playbook.yml -vvv

# 启用连接调试
ansible-playbook playbook.yml -vvvv
\begin{verbatim}
**示例输出**：\par
\end{verbatim}
TASK [Gathering Facts] *********************************************************************
ok: [webserver] => {
    "ansible_facts": {
        "ansible_all_ipv4_addresses": [
            "192.168.1.100"
        ],
        "ansible_distribution": "Ubuntu",
        "ansible_distribution_version": "20.04",
        ...
    },
    "changed": false
}
\begin{verbatim}
\subsubsection{2. 使用 debug 模块}
**功能**：在 Playbook 执行过程中打印变量值和自定义消息\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Debug variables
  hosts: all
  vars:
    app_version: 1.0.0
    environment: production
  tasks:
    - name: Print variable values
      debug:
        msg: "App version: {{ app_version }}, Environment: {{ environment }}"

    - name: Print host facts
      debug:
        var: ansible_facts
        verbosity: 2

    - name: Register and debug command output
      command:
        cmd: ls -la
      register: ls_output

    - name: Print command output
      debug:
        var: ls_output
\begin{verbatim}
\subsubsection{3. 使用 --check 模式}
**功能**：预览 Playbook 执行结果，不实际执行任何更改\par

**使用方法**：\par
\end{verbatim}bash
ansible-playbook playbook.yml --check
\begin{verbatim}
**示例输出**：\par
\end{verbatim}
PLAY [Install nginx] *********************************************************************

TASK [Gathering Facts] *********************************************************************
ok: [webserver]

TASK [Install nginx package] *********************************************************************
changed: [webserver] => (item=nginx)

PLAY RECAP *********************************************************************
webserver                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0

# 注意：changed=1 表示在实际执行时会发生更改
\begin{verbatim}
\subsection{高级调试工具}
\subsubsection{1. 使用 ansible-lint}
**功能**：检查 Playbook 的语法和最佳实践\par

**安装方法**：\par
\end{verbatim}bash
pip install ansible-lint
\begin{verbatim}
**使用方法**：\par
\end{verbatim}bash
ansible-lint playbook.yml
\begin{verbatim}
**示例输出**：\par
\end{verbatim}
[204] Lines should be no longer than 160 chars
playbook.yml:10
Task/Handler: Install nginx package

[301] Commands should not change things if nothing needs doing
playbook.yml:15
Task/Handler: Run command
\begin{verbatim}
\subsubsection{2. 使用 ansible-playbook --syntax-check}
**功能**：检查 Playbook 的语法是否正确\par

**使用方法**：\par
\end{verbatim}bash
ansible-playbook playbook.yml --syntax-check
\begin{verbatim}
**示例输出**：\par
\end{verbatim}
playbook: playbook.yml
# 无输出表示语法正确

# 语法错误示例
ERROR! Syntax Error while loading YAML.
  mapping values are not allowed in this context

The error appears to be in 'playbook.yml': line 5, column 12, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

  vars:
    app_version: 1.0.0
        environment: production
                  ^ here
\begin{verbatim}
\subsubsection{3. 使用策略插件进行调试}
**功能**：使用 `debug` 策略插件查看 Playbook 执行的详细步骤\par

**Playbook 示例**：\par
\end{verbatim}yaml
---
- name: Use debug strategy
  hosts: all
  strategy: debug
  tasks:
    - name: First task
      debug:
        msg: "First task"

    - name: Second task
      command:
        cmd: echo "Second task"

    - name: Third task
      debug:
        msg: "Third task"
\begin{verbatim}
**执行方法**：\par
\end{verbatim}bash
ansible-playbook playbook.yml
\begin{verbatim}
**特点**：执行每个任务后会暂停，等待用户输入，允许你检查当前状态并决定是否继续执行。\par

\section{日志分析与问题定位}
日志分析是故障排查的重要组成部分。通过分析 Ansible 的执行日志和目标主机的系统日志，你可以更准确地定位和解决问题。\par

\subsection{Ansible 日志配置}
\subsubsection{1. 启用 Ansible 日志}
**方法**：在 `ansible.cfg` 文件中配置日志路径\par

**配置示例**：\par
\end{verbatim}ini
[defaults]
# 启用日志
log_path = /var/log/ansible.log

# 日志级别（可选）
# 可能的值：DEBUG, INFO, WARNING, ERROR, CRITICAL
# 默认值：WARNING
# verbosity = 2
\begin{verbatim}
\subsubsection{2. 日志级别说明}
- **DEBUG**：最详细的日志，包括所有模块参数和执行细节\par
- **INFO**：一般信息，包括任务开始和结束\par
- **WARNING**：警告信息，如弃用的功能\par
- **ERROR**：错误信息，如任务失败\par
- **CRITICAL**：严重错误，如无法加载配置\par

\subsection{日志分析技巧}
\subsubsection{1. 分析 Ansible 执行日志}
**查看日志文件**：\par
\end{verbatim}bash
tail -f /var/log/ansible.log
\begin{verbatim}
**关键信息**：\par
- 任务执行开始和结束时间\par
- 任务执行结果（成功/失败）\par
- 失败任务的详细错误信息\par
- 模块参数和返回值\par

**示例日志条目**：\par
\end{verbatim}
2023-12-01 10:00:00,000 p=1234 u=user |  PLAY [Install nginx] *********************************************************
2023-12-01 10:00:00,001 p=1234 u=user |  TASK [Gathering Facts] *********************************************************
2023-12-01 10:00:01,000 p=1234 u=user |  ok: [webserver]
2023-12-01 10:00:01,001 p=1234 u=user |  TASK [Install nginx package] *********************************************************
2023-12-01 10:00:05,000 p=1234 u=user |  ok: [webserver] => (item=nginx)
2023-12-01 10:00:05,001 p=1234 u=user |  PLAY RECAP *********************************************************
2023-12-01 10:00:05,002 p=1234 u=user |  webserver                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
\begin{verbatim}
\subsubsection{2. 分析目标主机日志}
**常见日志文件**：\par
- **/var/log/auth.log** 或 **/var/log/secure**：SSH 连接和认证日志\par
- **/var/log/ansible.log**：Ansible 执行日志（如果在目标主机上配置）\par
- **/var/log/syslog** 或 **/var/log/messages**：系统日志\par
- **/var/log/nginx/error.log**：Nginx 错误日志\par
- **/var/log/mysql/error.log**：MySQL 错误日志\par

**查看日志方法**：\par
\end{verbatim}bash
# 实时查看日志
tail -f /var/log/auth.log

# 搜索特定内容
grep "ansible" /var/log/auth.log

# 查看最近的错误
grep "ERROR" /var/log/syslog | tail -n 20
```

\subsection{问题定位最佳实践}
\subsubsection{1. 系统化排查方法}
1. **复现问题**：尝试再次执行相同的操作，确认问题是否可以复现\par
2. **收集信息**：\par
   - Ansible 执行日志\par
   - 目标主机系统日志\par
   - 网络连接状态\par
   - 目标主机资源使用情况\par
3. **分析错误信息**：仔细阅读错误消息，理解问题的根本原因\par
4. **隔离测试**：\par
   - 简化 Playbook，只保留可能导致问题的部分\par
   - 在单个主机上测试\par
   - 手动执行命令，验证是否可以成功\par
5. **验证解决方案**：实施修复后，再次执行操作验证问题是否解决\par

\subsubsection{2. 常见问题排查流程}
**SSH 连接问题**：\par
1. 检查网络连接：`ping <host>`\par
2. 检查 SSH 服务：`systemctl status sshd`\par
3. 检查防火墙：`iptables -L`\par
4. 测试 SSH 连接：`ssh <user>@<host>`\par

**Playbook 执行失败**：\par
1. 检查语法：`ansible-playbook --syntax-check playbook.yml`\par
2. 启用详细输出：`ansible-playbook -vvv playbook.yml`\par
3. 分析错误信息：查看具体的错误消息和堆栈跟踪\par
4. 在目标主机上手动执行命令，验证是否可以成功\par

**性能问题**：\par
1. 检查目标主机资源使用：`top`、`free -m`、`df -h`\par
2. 优化 Playbook：使用 `serial` 控制并发执行\par
3. 启用事实缓存：减少事实收集时间\par
4. 使用异步任务：处理长时间运行的操作\par

\subsubsection{3. 故障排查工具组合}
| 工具 | 用途 | 示例命令 |\par
|------|------|----------|\par
| ansible-playbook --verbose | 查看详细执行信息 | `ansible-playbook -vvv playbook.yml` |\par
| ansible-lint | 检查 Playbook 最佳实践 | `ansible-lint playbook.yml` |\par
| debug 模块 | 打印变量和执行信息 | 在 Playbook 中使用 `debug` 任务 |\par
| ansible-doc | 查看模块文档 | `ansible-doc <module>` |\par
| ping 命令 | 检查网络连接 | `ping <host>` |\par
| ssh 命令 | 测试 SSH 连接 | `ssh <user>@<host>` |\par
| tail 命令 | 查看日志文件 | `tail -f /var/log/ansible.log` |\par
| grep 命令 | 搜索日志内容 | `grep "ERROR" /var/log/ansible.log` |\par
| systemctl | 检查服务状态 | `systemctl status sshd` |\par
| iptables | 检查防火墙规则 | `iptables -L` |\par

通过掌握这些故障排查方法和工具，你可以更有效地识别和解决 Ansible 使用过程中的各种问题，提高自动化运维的可靠性和效率。

% 第十二章 认证与职业发展
\chapter{认证与职业发展}
\section{Red Hat Ansible 认证}
Red Hat Ansible 认证是业界公认的 Ansible 技能认证，通过获取这些认证，你可以证明自己在 Ansible 自动化方面的专业能力，提升职业竞争力。\par

\subsection{认证路径}
\subsubsection{1. Red Hat Certified System Administrator (RHCSA)}
**认证概述**：RHCSA 是 Red Hat 基础认证，涵盖了 Linux 系统管理的核心技能，包括 Ansible 的基础应用。\par

**考试信息**：\par
- 考试代码：EX200\par
- 考试时长：2.5 小时\par
- 考试形式：实践操作\par
- 语言：英语\par

**Ansible 相关内容**：\par
- 使用 Ansible 执行基本的系统管理任务\par
- 创建和运行简单的 Playbook\par
- 管理文件和包\par

\subsubsection{2. Red Hat Certified Engineer (RHCE)}
**认证概述**：RHCE 是 Red Hat 中级认证，专注于 Linux 系统工程和 Ansible 自动化技能。\par

**考试信息**：\par
- 考试代码：EX294 (基于 Ansible 的 RHCE)\par
- 考试时长：3.5 小时\par
- 考试形式：实践操作\par
- 前提条件：RHCSA 认证\par

**考试内容**：\par
- 使用 Ansible Playbook 自动化配置任务\par
- 管理 Ansible 清单和变量\par
- 使用 Ansible 模板和角色\par
- 实现高级 Ansible 功能，如条件、循环和错误处理\par
- 自动化存储、数据库和 Web 服务配置\par

**备考建议**：\par
1. 完成 Red Hat 官方培训课程：DO447 (使用 Ansible 自动化红帽企业 Linux)\par
2. 实践练习各种 Ansible 场景\par
3. 使用 Red Hat 提供的练习环境\par
4. 熟悉考试大纲和要求\par

\subsubsection{3. Red Hat Certified Architect (RHCA)}
**认证概述**：RHCA 是 Red Hat 最高级别的认证，代表在 Red Hat 技术领域的专家水平。\par

**Ansible 相关路径**：\par
- **Red Hat Certified Architect in Infrastructure**：包含 Ansible 自动化作为核心组件\par
- **Red Hat Certified Architect in DevOps**：强调 CI/CD 和自动化技能\par

**前提条件**：\par
- RHCE 认证\par
- 通过 5 门专业考试\par

**Ansible 相关考试**：\par
- EX407：自动化红帽企业 Linux 系统管理（高级）\par
- EX447：使用 Ansible 自动化进行企业级 Linux 配置\par

\subsection{认证准备}
\subsubsection{1. 学习资源}
**官方资源**：\par
- Red Hat 官方培训课程\par
- Red Hat 认证学习指南\par
- Red Hat 实践实验室\par

**第三方资源**：\par
- Ansible 官方文档\par
- 在线课程平台（如 Udemy、Coursera）\par
- 社区贡献的学习材料\par
- 实践项目和案例研究\par

\subsubsection{2. 实践建议}
1. **建立实验室环境**：\par
   - 使用虚拟机或云服务创建多个 Linux 实例\par
   - 模拟真实的企业环境\par
   - 实践各种自动化场景\par

2. **构建自动化项目**：\par
   - 从简单的任务开始，逐步增加复杂性\par
   - 实现完整的应用部署流程\par
   - 解决实际工作中的自动化挑战\par

3. **参与社区**：\par
   - 加入 Ansible 社区论坛\par
   - 贡献代码或文档\par
   - 参加本地或在线 Ansible 活动\par

\subsubsection{3. 考试技巧}
1. **考前准备**：\par
   - 熟悉考试环境和操作界面\par
   - 复习考试大纲中的所有主题\par
   - 确保充分休息\par

2. **考试策略**：\par
   - 先完成熟悉的任务，建立信心\par
   - 合理分配时间，不要在单个任务上花费过多时间\par
   - 仔细阅读题目要求，确保理解正确\par
   - 验证每个任务的执行结果\par

3. **故障排除**：\par
   - 遇到问题时保持冷静\par
   - 使用 Ansible 的调试功能\par
   - 检查 Playbook 语法和逻辑\par
   - 利用系统日志和错误信息\par

\subsection{认证价值}
\subsubsection{1. 职业优势}
- **提升就业竞争力**：Ansible 认证在招聘市场上备受青睐\par
- **增加薪资潜力**：认证专业人员通常获得更高的薪资\par
- **职业发展机会**：认证是晋升和职业转型的重要依据\par
- **专业认可度**：证明你具备行业认可的技能水平\par

\subsubsection{2. 企业价值}
- **标准化技能**：确保团队成员具备一致的技能水平\par
- **降低风险**：认证专业人员更能有效地实施和管理自动化\par
- **提高效率**：自动化可以显著提高 IT 运维效率\par
- **增强可靠性**：标准化的自动化流程减少人为错误\par

\subsubsection{3. 个人成长}
- **知识体系化**：认证过程帮助你系统掌握 Ansible 技能\par
- **解决问题能力**：通过实践和考试，提升故障排除能力\par
- **持续学习**：认证要求你保持对新技术的关注\par
- **自信心提升**：通过挑战获得认证，增强专业自信\par

\section{Ansible 技能图谱}
Ansible 技能图谱展示了从入门到专家的技能发展路径，帮助你了解需要掌握的核心技能和进阶方向。\par

\subsection{基础技能}
\subsubsection{1. Linux 基础}
- **系统管理**：熟悉 Linux 系统管理命令和工具\par
- **文件系统**：了解 Linux 文件系统结构和权限\par
- **网络基础**：掌握网络配置和故障排除\par
- **服务管理**：熟悉 systemd 和服务配置\par

\subsubsection{2. Ansible 核心概念}
- **基础架构**：理解 Ansible 的工作原理和架构\par
- **安装配置**：掌握 Ansible 的安装和基本配置\par
- **Inventory 管理**：了解主机清单的创建和管理\par
- **Ad-Hoc 命令**：使用临时命令执行简单任务\par

\subsubsection{3. Playbook 基础}
- **语法结构**：掌握 YAML 语法和 Playbook 结构\par
- **任务定义**：创建和执行基本任务\par
- **模块使用**：熟悉常用 Ansible 模块\par
- **执行流程**：理解 Playbook 的执行顺序和机制\par

\subsection{中级技能}
\subsubsection{1. 高级 Playbook}
- **变量管理**：使用和管理变量\par
- **Facts 收集**：利用系统信息进行配置\par
- **条件判断**：使用 when 语句实现条件执行\par
- **循环结构**：使用 loop 处理重复任务\par
- **错误处理**：实现任务失败的处理机制\par

\subsubsection{2. 模板与文件}
- **Jinja2 模板**：创建动态配置文件\par
- **文件操作**：管理文件的创建、复制和修改\par
- **文件权限**：设置和管理文件权限\par
- **配置模板化**：实现配置的版本控制和动态生成\par

\subsubsection{3. 角色与 Collections}
- **角色结构**：创建和使用 Ansible 角色\par
- **角色依赖**：管理角色之间的依赖关系\par
- **Collections 使用**：从 Ansible Galaxy 安装和使用 Collections\par
- **代码复用**：实现 Playbook 和角色的复用\par

\subsubsection{4. 高级特性}
- **Ansible Vault**：加密敏感信息\par
- **异步任务**：处理长时间运行的任务\par
- **委托任务**：将任务委托给其他主机执行\par
- **标签管理**：使用标签控制任务执行\par

\subsection{高级技能}
\subsubsection{1. 企业级部署}
- **环境管理**：管理多环境（开发、测试、生产）\par
- **版本控制**：使用 Git 管理 Playbook 和配置\par
- **CI/CD 集成**：将 Ansible 集成到持续集成/持续部署流程\par
- **自动化测试**：为自动化任务编写测试\par

\subsubsection{2. 云自动化}
- **云提供商集成**：与 AWS、Azure、GCP 等云服务集成\par
- **基础设施即代码**：使用 Ansible 管理云资源\par
- **动态 Inventory**：自动发现和管理云资源\par
- **云服务配置**：自动化配置云服务和资源\par

\subsubsection{3. 网络自动化}
- **网络设备管理**：使用 Ansible 管理网络设备\par
- **网络配置模板**：创建网络设备配置模板\par
- **网络状态验证**：验证网络配置和状态\par
- **多厂商支持**：管理不同厂商的网络设备\par

\subsubsection{4. 安全自动化}
- **安全基线配置**：实施安全最佳实践\par
- **合规性检查**：验证系统合规性\par
- **漏洞管理**：自动化漏洞扫描和修复\par
- **安全策略实施**：强制执行安全策略\par

\subsection{专家技能}
\subsubsection{1. 架构设计}
- **自动化架构**：设计企业级自动化架构\par
- **可扩展性**：确保自动化系统的可扩展性\par
- **高可用性**：设计高可用的自动化解决方案\par
- **性能优化**：优化 Ansible 执行性能\par

\subsubsection{2. 自定义开发}
- **自定义模块**：开发 Ansible 自定义模块\par
- **插件开发**：创建 Ansible 插件\par
- **API 集成**：与第三方系统 API 集成\par
- **自定义 Collections**：创建和发布 Collections\par

\subsubsection{3. 培训与指导}
- **知识传递**：培训团队成员使用 Ansible\par
- **最佳实践分享**：推广自动化最佳实践\par
- **架构评审**：评审自动化架构和实现\par
- **故障排除**：解决复杂的自动化问题\par

\subsubsection{4. 行业专业知识}
- **特定领域自动化**：根据行业特点定制自动化解决方案\par
- **合规性要求**：满足行业特定的合规性要求\par
- **行业标准**：遵循行业最佳实践和标准\par
- **业务流程集成**：将自动化与业务流程集成\par

\subsection{技能评估}
\subsubsection{1. 自我评估}
使用以下标准评估你的 Ansible 技能水平：\par

**入门级**：\par
- 了解 Ansible 基本概念\par
- 能够执行简单的 Ad-Hoc 命令\par
- 编写基本的 Playbook\par
- 管理简单的主机清单\par

**中级**：\par
- 熟练使用变量和 Facts\par
- 编写复杂的 Playbook，包含条件和循环\par
- 创建和使用角色\par
- 集成 Ansible 与基本的 CI/CD 流程\par

**高级**：\par
- 设计企业级自动化架构\par
- 管理多环境和复杂的自动化流程\par
- 开发自定义模块和插件\par
- 实现云资源的自动化管理\par

**专家级**：\par
- 解决复杂的自动化挑战\par
- 指导团队实施自动化战略\par
- 贡献 Ansible 社区\par
- 设计和实施大规模自动化解决方案\par

\subsubsection{2. 技能提升路径}
**从入门到中级**：\par
1. 完成 Ansible 官方入门教程\par
2. 实践基本的系统管理自动化\par
3. 学习 Playbook 高级特性\par
4. 参与小型自动化项目\par

**从中级到高级**：\par
1. 获得 RHCE (EX294) 认证\par
2. 实施企业级自动化项目\par
3. 学习云自动化和网络自动化\par
4. 参与大型自动化架构设计\par

**从高级到专家**：\par
1. 获得 RHCA 认证\par
2. 开发自定义模块和插件\par
3. 贡献 Ansible 社区\par
4. 分享知识，指导他人\par

\section{职业机会与发展路径}
Ansible 技能在当今 IT 自动化时代非常受欢迎，掌握 Ansible 可以为你打开多种职业机会。\par

\subsection{常见职位}
\subsubsection{1. DevOps 工程师}
**职位描述**：DevOps 工程师负责开发和运维之间的协作，实现自动化部署和持续集成/持续部署。\par

**Ansible 相关职责**：\par
- 设计和实施 CI/CD 管道\par
- 使用 Ansible 自动化基础设施配置\par
- 管理容器和云资源\par
- 监控和优化系统性能\par

**技能要求**：\par
- 熟悉 Ansible、Jenkins、Git 等工具\par
- 了解容器技术（Docker、Kubernetes）\par
- 掌握至少一种编程语言\par
- 具备系统管理经验\par

**薪资范围**：根据经验和地区不同，DevOps 工程师的年薪通常在 15-30 万元人民币之间。\par

\subsubsection{2. 自动化工程师}
**职位描述**：自动化工程师专注于设计和实施自动化解决方案，提高 IT 系统的效率和可靠性。\par

**Ansible 相关职责**：\par
- 开发和维护 Ansible Playbook\par
- 设计自动化架构和流程\par
- 与其他团队合作，识别自动化机会\par
- 培训团队成员使用自动化工具\par

**技能要求**：\par
- 精通 Ansible 和相关自动化工具\par
- 了解 Linux 系统管理\par
- 具备脚本编程能力\par
- 良好的问题解决能力\par

**薪资范围**：自动化工程师的年薪通常在 12-25 万元人民币之间。\par

\subsubsection{3. 系统工程师}
**职位描述**：系统工程师负责设计、实施和维护 IT 系统基础设施。\par

**Ansible 相关职责**：\par
- 使用 Ansible 自动化系统配置和管理\par
- 确保系统的安全性和可靠性\par
- 监控系统性能和解决问题\par
- 制定系统管理最佳实践\par

**技能要求**：\par
- 熟悉 Linux/Unix 系统管理\par
- 掌握 Ansible 等自动化工具\par
- 了解网络基础和安全\par
- 具备故障排除能力\par

**薪资范围**：系统工程师的年薪通常在 10-20 万元人民币之间。\par

\subsubsection{4. 云工程师}
**职位描述**：云工程师负责设计、实施和管理云基础设施。\par

**Ansible 相关职责**：\par
- 使用 Ansible 自动化云资源的创建和配置\par
- 实施基础设施即代码（IaC）\par
- 管理多云环境\par
- 优化云资源使用和成本\par

**技能要求**：\par
- 熟悉 AWS、Azure、GCP 等云服务\par
- 精通 Ansible 和其他 IaC 工具\par
- 了解容器和微服务架构\par
- 具备网络和安全知识\par

**薪资范围**：云工程师的年薪通常在 15-35 万元人民币之间。\par

\subsubsection{5. 网络自动化工程师}
**职位描述**：网络自动化工程师专注于网络设备和服务的自动化管理。\par

**Ansible 相关职责**：\par
- 使用 Ansible 自动化网络设备配置\par
- 设计网络自动化架构\par
- 实现网络配置的版本控制\par
- 监控和优化网络性能\par

**技能要求**：\par
- 熟悉网络设备和协议\par
- 精通 Ansible 网络模块\par
- 了解网络自动化最佳实践\par
- 具备网络故障排除能力\par

**薪资范围**：网络自动化工程师的年薪通常在 15-28 万元人民币之间。\par

\subsection{职业发展路径}
\subsubsection{1. 技术专家路径}
**初级自动化工程师** → **中级自动化工程师** → **高级自动化工程师** → **自动化架构师**\par

**发展建议**：\par
- 持续学习 Ansible 新特性和最佳实践\par
- 获得相关认证（RHCE、RHCA）\par
- 参与大型自动化项目\par
- 开发自定义模块和插件\par
- 分享知识，建立专业声誉\par

\subsubsection{2. 管理路径}
**自动化工程师** → **自动化团队负责人** → **DevOps 经理** → **技术总监**\par

**发展建议**：\par
- 提升项目管理能力\par
- 学习团队领导技巧\par
- 了解业务流程和战略\par
- 培养沟通和协调能力\par
- 关注行业趋势和技术发展\par

\subsubsection{3. 咨询路径}
**自动化工程师** → **自动化顾问** → **高级顾问** → **首席顾问**\par

**发展建议**：\par
- 积累多样化的项目经验\par
- 了解不同行业的自动化需求\par
- 提升沟通和演讲能力\par
- 建立行业网络\par
- 持续学习最新技术和方法论\par

\subsection{职业发展策略}
\subsubsection{1. 持续学习}
- **官方文档**：定期查看 Ansible 官方文档和更新\par
- **在线课程**：参加相关的在线培训和认证课程\par
- **社区活动**：参与 Ansible 社区会议和活动\par
- **实践项目**：持续进行个人或开源项目\par
- **技术博客**：撰写技术文章，分享经验\par

\subsubsection{2. 建立专业网络}
- **社交媒体**：在 LinkedIn、Twitter 等平台分享专业内容\par
- **技术会议**：参加本地和全球的技术会议\par
- **社区贡献**：为 Ansible 项目或社区贡献代码和文档\par
- **行业组织**：加入相关的行业组织和用户组\par
- **导师关系**：寻找导师，同时指导他人\par

\subsubsection{3. 提升软实力}
- **沟通能力**：提高技术和非技术人员的沟通能力\par
- **问题解决**：培养系统化的问题解决能力\par
- **项目管理**：学习基本的项目管理技能\par
- **领导力**：发展团队领导和协作能力\par
- **商业意识**：了解技术如何支持业务目标\par

\subsubsection{4. 职业规划}
1. **设定目标**：明确短期和长期职业目标\par
2. **技能差距分析**：识别需要提升的技能\par
3. **学习计划**：制定详细的学习和发展计划\par
4. **定期评估**：定期评估进展，调整计划\par
5. **抓住机会**：积极寻找新的挑战和机会\par

\subsection{行业趋势}
\subsubsection{1. 自动化需求增长}
- **混合云环境**：企业需要管理复杂的混合云基础设施\par
- **DevSecOps**：安全自动化成为关键需求\par
- **边缘计算**：边缘设备的自动化管理\par
- **AI 集成**：人工智能与自动化的结合\par

\subsubsection{2. 技能需求变化}
- **全栈自动化**：需要了解多个技术领域的自动化\par
- **云原生技能**：熟悉容器和微服务的自动化\par
- **安全自动化**：具备安全自动化的专业知识\par
- **业务流程自动化**：将自动化扩展到业务流程\par

\subsubsection{3. 未来机会}
- **自动化架构师**：设计企业级自动化解决方案\par
- **AI 自动化专家**：将 AI 应用于自动化流程\par
- **安全自动化专家**：专注于安全合规的自动化\par
- **行业特定自动化专家**：针对特定行业的自动化解决方案\par

通过持续学习和实践，掌握 Ansible 技能并获取相关认证，你可以在自动化领域建立成功的职业生涯，迎接未来 IT 行业的挑战和机遇。

% 第十三章 参考资源
\chapter{参考资源}
\section{官方文档}
Ansible 的官方文档是学习和使用 Ansible 的最权威、最全面的资源。官方文档涵盖了 Ansible 的所有功能、模块和最佳实践，是你解决问题和深入学习的首选参考资料。\par

\subsection{主要官方文档}
\subsubsection{1. Ansible 文档主页}
**链接**：https://docs.ansible.com/\par

**内容概述**：\par
- Ansible 核心文档的入口点\par
- 包含所有版本的文档链接\par
- 提供快速入门指南和安装说明\par
- 包含模块索引和插件参考\par

\subsubsection{2. Ansible Core 文档}
**链接**：https://docs.ansible.com/ansible/latest/index.html\par

**内容概述**：\par
- Ansible 核心功能的详细文档\par
- 包括安装、配置、基础概念等内容\par
- 提供 Playbook 编写指南和最佳实践\par
- 包含所有内置模块的文档\par

\subsubsection{3. Ansible Galaxy 文档}
**链接**：https://docs.ansible.com/ansible-galaxy/user_guide/index.html\par

**内容概述**：\par
- Ansible Galaxy 的使用指南\par
- 如何发布和使用 Roles\par
- Collections 的管理和使用\par
- Galaxy API 参考\par

\subsubsection{4. Ansible Tower/AWX 文档}
**链接**：https://docs.ansible.com/ansible-tower/\par

**内容概述**：\par
- Ansible Tower（商业版）和 AWX（开源版）的文档\par
- 企业级 Ansible 自动化平台的使用指南\par
- 工作流设计和管理\par
- 权限管理和审计\par

\subsubsection{5. Ansible 网络自动化文档}
**链接**：https://docs.ansible.com/ansible/latest/network/getting_started/index.html\par

**内容概述**：\par
- 网络设备自动化的专门文档\par
- 网络模块的使用指南\par
- 网络设备的配置和管理\par
- 网络自动化最佳实践\par

\subsection{文档导航技巧}
\subsubsection{1. 搜索功能}
- 使用文档站点顶部的搜索栏快速查找内容\par
- 使用关键词组合提高搜索精度\par
- 搜索特定模块时使用完整模块名\par

\subsubsection{2. 版本选择}
- 根据你使用的 Ansible 版本选择相应的文档\par
- 新版本文档通常包含更多功能和改进\par
- 旧版本文档适用于稳定环境\par

\subsubsection{3. 模块文档查看}
- 使用 `ansible-doc` 命令在终端查看模块文档\par
  ```bash
  ansible-doc <module_name>
  ```\par
- 例如：`ansible-doc copy` 查看 copy 模块的文档\par

\subsubsection{4. 示例代码}
- 官方文档包含大量示例代码\par
- 复制示例代码并根据你的需求修改\par
- 注意示例中的注释和说明\par

\section{推荐书籍}
以下是一些关于 Ansible 的高质量书籍，涵盖了从入门到高级的各种主题，可以帮助你系统学习 Ansible。\par

\subsection{入门级书籍}
\subsubsection{1. 《Ansible 入门指南》}
**作者**：Lorin Hochstein\par
**出版社**：O'Reilly Media\par
**内容概述**：\par
- Ansible 的基础概念和快速入门\par
- 适合初学者的实用指南\par
- 包含丰富的示例和练习\par
- 涵盖 Playbook 编写和基本模块使用\par

\subsubsection{2. 《Ansible 实战》}
**作者**：Rene Moser\par
**出版社**：Packt Publishing\par
**内容概述**：\par
- 从基础到高级的 Ansible 实战指南\par
- 包含真实世界的案例和最佳实践\par
- 详细介绍 Playbook、角色和变量\par
- 适合系统管理员和 DevOps 工程师\par

\subsubsection{3. 《Ansible 自动化运维》}
**作者**：刘天斯\par
**出版社**：人民邮电出版社\par
**内容概述**：\par
- 面向中国读者的 Ansible 入门书籍\par
- 结合国内实际运维场景\par
- 包含详细的操作步骤和截图\par
- 适合 Linux 系统管理员学习\par

\subsection{进阶级书籍}
\subsubsection{1. 《Mastering Ansible》}
**作者**：James Freeman, Jesse Keating\par
**出版社**：Packt Publishing\par
**内容概述**：\par
- Ansible 高级特性和最佳实践\par
- 企业级 Ansible 部署策略\par
- 自定义模块和插件开发\par
- 大规模环境的性能优化\par

\subsubsection{2. 《Ansible: Up and Running》}
**作者**：Lorin Hochstein, Rene Moser\par
**出版社**：O'Reilly Media\par
**内容概述**：\par
- Ansible 从入门到精通的全面指南\par
- 包含大量实际示例和最佳实践\par
- 高级主题如网络自动化和云集成\par
- 适合有一定基础的用户深入学习\par

\subsubsection{3. 《Ansible for DevOps》}
**作者**：Jeff Geerling\par
**出版社**：Self-published\par
**内容概述**：\par
- DevOps 视角下的 Ansible 应用\par
- 持续集成和持续部署\par
- 基础设施即代码实践\par
- 包含完整的项目示例\par

\subsection{专业领域书籍}
\subsubsection{1. 《Network Automation with Ansible》}
**作者**：Nicola Moretto\par
**出版社**：O'Reilly Media\par
**内容概述**：\par
- 网络设备自动化的专门指南\par
- 多厂商网络设备的配置管理\par
- 网络自动化架构设计\par
- 网络配置的版本控制和测试\par

\subsubsection{2. 《Ansible for Kubernetes》}
**作者**：Lorin Hochstein\par
**出版社**：O'Reilly Media\par
**内容概述**：\par
- 使用 Ansible 管理 Kubernetes 集群\par
- 容器编排的自动化\par
- Kubernetes 资源的配置管理\par
- 与 CI/CD 流程集成\par

\subsubsection{3. 《Infrastructure as Code with Ansible》}
**作者**：Scott Vintinner\par
**出版社**：Apress\par
**内容概述**：\par
- 基础设施即代码的 Ansible 实现\par
- 云资源的自动化管理\par
- 多环境部署策略\par
- 基础设施的版本控制和测试\par

\section{在线教程与课程}
除了书籍和官方文档外，在线教程和课程也是学习 Ansible 的重要资源。这些资源通常包含视频讲解、交互式练习和实时支持，可以帮助你更直观地学习 Ansible。\par

\subsection{官方培训}
\subsubsection{1. Red Hat 官方培训}
**课程名称**：DO447 - 使用 Ansible 自动化红帽企业 Linux\par
**链接**：https://www.redhat.com/en/services/training/do447-automating-red-hat-enterprise-linux-ansible\par

**内容概述**：\par
- Red Hat 官方认证培训课程\par
- 为 RHCE (EX294) 认证做准备\par
- 由 Red Hat 认证讲师授课\par
- 包含实践实验室和练习\par

**课程目标**：\par
- 掌握 Ansible Playbook 编写\par
- 实现高级 Ansible 功能\par
- 自动化企业级 Linux 系统管理\par
- 准备 RHCE 认证考试\par

\subsubsection{2. Ansible 官方网络研讨会}
**链接**：https://www.ansible.com/resources/webinars-training\par

**内容概述**：\par
- 免费的在线网络研讨会\par
- 涵盖 Ansible 的新特性和最佳实践\par
- 由 Ansible 专家和社区领袖主讲\par
- 可按需观看录制内容\par

\subsection{在线学习平台}
\subsubsection{1. Udemy}
**推荐课程**：\par
- **Ansible for the Absolute Beginner**：适合完全初学者的入门课程\par
- **Mastering Ansible**：涵盖高级特性和企业级应用\par
- **Ansible Automation**：专注于实际自动化场景\par

**特点**：\par
- 视频课程，可终身访问\par
- 包含实践练习和项目\par
- 讲师答疑和社区讨论\par
- 价格实惠，经常有折扣\par

\subsubsection{2. Coursera}
**推荐课程**：\par
- **Ansible 自动化**：由 IBM 提供的专业课程\par
- **DevOps 自动化工具**：包含 Ansible 等多种工具\par
- **云基础设施自动化**：结合云服务和 Ansible\par

**特点**：\par
- 由知名大学和企业提供\par
- 结构化的课程内容\par
- 完成课程可获得证书\par
- 提供实践项目和评估\par

\subsubsection{3. edX}
**推荐课程**：\par
- **Red Hat 系统管理**：包含 Ansible 自动化内容\par
- **DevOps 实践**：涵盖自动化和持续集成\par

**特点**：\par
- 由顶尖大学和机构提供\par
- 部分课程可免费审计\par
- 提供微硕士学位和专业证书\par
- 高质量的教学内容\par

\subsubsection{4. Linux Academy/A Cloud Guru}
**推荐课程**：\par
- **Ansible 基础**：从入门到精通\par
- **Ansible 高级技巧**：企业级应用\par
- **网络自动化与 Ansible**：专注于网络设备\par

**特点**：\par
- 互动式学习平台\par
- 包含动手实验和挑战\par
- 提供学习路径和技能评估\par
- 适合职业发展和认证准备\par

\subsection{免费在线资源}
\subsubsection{1. Ansible 官方 YouTube 频道}
**链接**：https://www.youtube.com/c/AnsibleAutomation\par

**内容概述**：\par
- Ansible 官方视频教程和演示\par
- 包含新品发布和功能介绍\par
- 社区会议和用户分享\par
- 技术深度解析和案例研究\par

\subsubsection{2. GitHub 教程仓库}
**推荐仓库**：\par
- **ansible/ansible-examples**：官方示例代码\par
- **geerlingguy/ansible-for-devops**：实用示例和最佳实践\par
- **davydany/ansible-playbooks**：各种场景的 Playbook 示例\par

**特点**：\par
- 免费的开源代码示例\par
- 真实世界的使用案例\par
- 社区维护和更新\par
- 可直接复制和修改使用\par

\subsubsection{3. 博客和技术网站}
**推荐网站**：\par
- **Ansible 官方博客**：https://www.ansible.com/blog\par
- **Red Hat 官方博客**：https://www.redhat.com/en/blog/topics/ansible\par
- **DevOps.com**：包含大量 Ansible 相关文章\par
- **Medium**：搜索 Ansible 标签获取相关文章\par

**特点**：\par
- 最新的 Ansible 技术动态\par
- 专家分享的经验和技巧\par
- 真实案例分析和解决方案\par
- 定期更新的内容\par

\section{社区与论坛}
Ansible 拥有活跃的社区，通过参与社区活动，你可以获取帮助、分享经验、贡献代码，并与其他 Ansible 用户和专家建立联系。\par

\subsection{主要社区平台}
\subsubsection{1. Ansible 社区论坛}
**链接**：https://forum.ansible.com/\par

**内容概述**：\par
- Ansible 官方社区论坛\par
- 讨论 Ansible 相关问题和解决方案\par
- 分享最佳实践和使用案例\par
- 社区专家和 Ansible 团队成员参与\par

**参与建议**：\par
- 搜索现有问题和答案\par
- 详细描述你的问题和环境\par
- 提供相关代码和错误信息\par
- 遵守社区行为准则\par

\subsubsection{2. GitHub 讨论区}
**链接**：https://github.com/ansible/ansible/discussions\par

**内容概述**：\par
- Ansible 项目的官方讨论区\par
- 讨论功能请求和 bug 报告\par
- 分享代码和贡献\par
- 与 Ansible 核心开发者交流\par

**参与建议**：\par
- 查看贡献指南\par
- 提交有意义的 issue 和 PR\par
- 提供详细的复现步骤\par
- 尊重维护者的时间和努力\par

\subsubsection{3. Stack Overflow}
**标签**：ansible\par
**链接**：https://stackoverflow.com/questions/tagged/ansible\par

**内容概述**：\par
- 问答社区，包含大量 Ansible 相关问题\par
- 由社区成员提供答案和解决方案\par
- 投票系统确保高质量回答\par
- 可搜索历史问题和答案\par

**参与建议**：\par
- 使用正确的标签（ansible, ansible-playbook 等）\par
- 提供最小可复现示例\par
- 接受和点赞有用的回答\par
- 分享你的知识，回答其他问题\par

\subsubsection{4. Reddit}
**子版块**：r/ansible\par
**链接**：https://www.reddit.com/r/ansible/\par

**内容概述**：\par
- Ansible 爱好者的社区\par
- 分享新闻、教程和技巧\par
- 讨论 Ansible 相关话题\par
- 轻松友好的交流氛围\par

**参与建议**：\par
- 遵守子版块规则\par
- 分享有价值的内容\par
- 尊重其他社区成员\par
- 使用搜索功能避免重复问题\par

\subsection{社区活动}
\subsubsection{1. Ansible 社区会议}
**链接**：https://github.com/ansible/community/blob/main/meetings/README.md\par

**内容概述**：\par
- 定期举行的在线社区会议\par
- 讨论 Ansible 的发展和方向\par
- 社区成员分享经验和项目\par
- 可通过视频会议参与\par

**参与方式**：\par
- 查看会议日程和议程\par
- 注册参与在线会议\par
- 提交话题建议\par
- 观看录制的会议内容\par

\subsubsection{2. AnsibleFest}
**链接**：https://www.ansible.com/ansiblefest\par

**内容概述**：\par
- Ansible 官方年度大会\par
- 涵盖 Ansible 的最新发展和趋势\par
- 由 Ansible 团队和社区专家演讲\par
- 包含技术研讨会和 networking 机会\par

**参与方式**：\par
- 注册参加线下或线上会议\par
- 提交演讲提案\par
- 参观展览和演示\par
- 与 Ansible 团队和社区成员交流\par

\subsubsection{3. 本地 Ansible 用户组}
**链接**：https://www.meetup.com/find/?keywords=ansible\par

**内容概述**：\par
- 由本地 Ansible 用户组织的 meetup\par
- 定期举行的线下或线上活动\par
- 分享本地实践和案例\par
- 建立本地专业网络\par

**参与方式**：\par
- 在 Meetup.com 上搜索本地 Ansible 用户组\par
- 注册参加活动\par
- 主动分享你的经验\par
- 帮助组织和推广活动\par

\subsection{贡献社区}
\subsubsection{1. 代码贡献}
**指南**：https://docs.ansible.com/ansible/latest/community/contributing.html\par

**贡献方式**：\par
- 修复 bug 和实现新功能\par
- 改进文档和示例\par
- 开发和维护模块\par
- 参与代码审查\par

**贡献流程**：\par
1. Fork Ansible 仓库\par
2. 创建功能分支\par
3. 提交代码更改\par
4. 运行测试\par
5. 提交 Pull Request\par
6. 参与代码审查\par

\subsubsection{2. 文档贡献}
**指南**：https://docs.ansible.com/ansible/latest/community/documenting.html\par

**贡献方式**：\par
- 修正文档错误\par
- 补充缺失的内容\par
- 改进示例和说明\par
- 翻译文档到其他语言\par

**贡献流程**：\par
1. Fork Ansible 仓库\par
2. 修改文档文件\par
3. 提交更改\par
4. 提交 Pull Request\par
5. 等待审查和合并\par

\subsubsection{3. 社区支持}
**支持方式**：\par
- 在论坛和 Stack Overflow 上回答问题\par
- 分享你的经验和最佳实践\par
- 创建和维护开源 Ansible 项目\par
- 帮助新用户学习 Ansible\par

**价值**：\par
- 提升你的专业声誉\par
- 加深对 Ansible 的理解\par
- 建立专业网络\par
- 为开源社区做出贡献\par

通过利用这些参考资源，你可以全面学习 Ansible，解决实际问题，并与全球 Ansible 社区保持联系。无论是初学者还是经验丰富的专业人士，这些资源都能为你的 Ansible 学习和实践提供有力支持。

% 参考文献
\backmatter

\begin{thebibliography}{99}
    \bibitem{ref1} Ansible 官方文档. https://docs.ansible.com/
    \bibitem{ref2} Red Hat Ansible 认证. https://www.redhat.com/en/services/training/ex294-red-hat-certified-engineer-in-ansible-automation
    \bibitem{ref3} Ansible Galaxy. https://galaxy.ansible.com/
\end{thebibliography}

% 索引
% \printindex

\end{document}


