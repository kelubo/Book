<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.250rem;">
<head><title></title>
<link href="flow0001.css" rel="stylesheet" type="text/css" />
</head>
<body>
<h3 class="p3">13.4.4　doublewrite缓存</h3>
<p class="ziti">如果说change buffer带给InnoDB存储引擎的是性能上的提升，那么doublewrite带给InnoDB存储引擎的则是数据页的可靠性。</p>
<p class="ziti">doublewrite（两次写）缓存是位于系统表空间的存储区域，用来缓存InnoDB的数据页从InnoDB缓存池中flush之后并写入到数据文件之前。所以当操作系统或者数据库进程在数据页写磁盘的过程中崩溃时，InnoDB可以在doublewrite缓存中找到数据页的备份而用来执行crash恢复。</p>
<p class="ziti">数据页写入到doublewrite缓存的动作所需要的IO消耗要小于写入到数据文件的消耗，因为此写入操作会以一次大的连续块的方式写入。</p>
<p class="ziti">在应用（apply）重做日志之前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite。</p>
<p class="ziti">doublewrite缓存示意图如图13-7所示，doublewrite的组成具体如下。</p>
<p class="ziti">内存中的doublewrite buffer，大小为2MB。</p>
<p class="ziti">物理磁盘上共享表空间中连续的128个页，即2个区（extend），大小同样为2MB。</p>
<p class="ziti">对缓冲池的脏页进行刷新时，并不是直接写磁盘，而是通过memcpy()函数将脏页先复制到内存中的doublewrite buffer中，之后通过doublewrite再分两次，每次1MB，顺序地写入共享表空间的物理磁盘上，在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中，此时的写入就是离散的。如果操作系统在将页写入磁盘的过程中发生了崩溃，那么在恢复过程中，InnoDB可以从共享表空间中的doublewrite中找到该页的一个副本，然后将其复制到表空间文件，再应用重做日志。</p>
<div class="pic"><img alt="" src="Image00095.jpg" />
</div>
<p class="middle-img">图13-7　doublewrite缓存示意图</p>
</body>
</html>
