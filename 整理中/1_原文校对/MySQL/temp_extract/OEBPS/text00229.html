<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.250rem;">
<head><title></title>
<link href="flow0001.css" rel="stylesheet" type="text/css" />
</head>
<body>
<h2 class="p2">15.4　MySQL主从复制数据一致性企业级方案</h2>
<p class="ziti">MySQL数据库主从复制延迟是高并发场景中时而会发生的问题，大家除了要注意上述15.3节中提到的6个问题之外，还有如下方法可以应对非预期的主从复制延迟问题。</p>
<p class="p6">1.采用半同步复制方案</p>
<p class="ziti">主从不一致时因为主从复制默认是异步的复制方式，即主库完成后，binlog将数据传输到从库并写到中继日志中，最后在由从库解析执行到从库里。而半同步复制方案实际上就是实时复制方案，即让主库和从库同时写入完毕，再把请求结果返回给用户，这样就可以实现主从是实时一致性的，该方案的详细介绍和实践见本书后文。该方案的优点可以最大限度地保证主从一致，但是，增加了主库写入的时间，超过实时同步设置的超时时间都会转化成异步复制。</p>
<p class="p6">2.当复制发生延迟时让程序改读主库</p>
<p class="ziti">1）当数据写入后，程序在从库读不到该数据时，自动判断并请求主库，这是多年前老男孩曾为公司提供的方案，最终被采纳了（思路很重要，结果导向，倒推方法，解决方法的缺陷和对应的困难），此方案有一个小问题那就是对于新数据没有任何问题，但是对于更新的数据，可能会在从库读到旧的数据，从而不会再读取主库，另外还会增加主库的压力。</p>
<p class="ziti">2）可以部署一个缓存服务器，当数据写入数据库的同时，将更新主库的数据的key、时间戳以及数据超时时间（例如1秒）写入到缓存服务器中，然后在进行读请求访问的时候，先查缓存服务器，如果有对应的key，则表示主库刚写完不到1秒，从库也有可能还没有，所以主动读主库，如果缓存里没有对应的key，则表示更新的主库对应key的数据已经写完超过1秒了，此时从库也应该有了，如果此时从库中还没有，则可以再请求写库。该方案的缺点是逻辑复杂，开发成本很高，并且还会增加主库的压力，最后不管key的超时时间设置的是大还是小，如果复制发生了故障，那么理论上还可能会导致访问到旧的数据。</p>
<p class="ziti">3）在产品程序逻辑上，应尽量延缓（例如1秒）用户访问刚更新过的数据，为数据库主从复制争取同步的时间，例如，自动返回设置3、2、1等，或者增加一个点击按钮，此方案是笔者曾经向公司推荐的方案，可能不是最佳的方案，这里将此方案提出来的目的是提醒读者，很多时候解决问题未必是技术层面的事情，也可以从产品层面解决问题，希望读者们能打开格局，不拘一格做运维。</p>
<p class="ziti">4）采用读写分离工具实现路由数据到主库，一般是大型企业自研，常规读写分离工具会将写请求自动路由到主库，将从请求路由到从库。此时，可以让工具路由在写请求的同时记录写（增加或更新）请求对应的key和更新的时间，若有相同的请求访问这个key对应的读数据，则判断一下这个写请求延续的时间是否超过了指定的时间（例如1-2秒，根据业务需要来指定），如果未超过，则让这个读请求读主库。</p>
<p class="ziti">以上方案的优点各有千秋，缺点也都很明显，最终的选择还是得依靠读者去折中平衡选择。</p>
<p class="ziti">当然，从哲学上来说，最核心的还是主从复制不发生故障或故障自动治愈（14.3节），不发生延迟（15.3节），才是解决数据一致性的最高境界。因此，读者需要在15.3节和14.3节的知识讲解上多下功夫，再加上本节的内容，则可无敌于天下了。</p>
</body>
</html>
