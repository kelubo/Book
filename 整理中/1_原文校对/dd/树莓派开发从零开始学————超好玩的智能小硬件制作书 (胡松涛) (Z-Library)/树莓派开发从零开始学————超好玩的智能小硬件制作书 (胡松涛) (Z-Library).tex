\documentclass{article}
\usepackage{ctex}
\begin{document}
\title{树莓派开发从零开始学————超好玩的智能小硬件制作书 (胡松涛) (Z-Library)}
\maketitle
\section{内容}
内容简介本书以实战开发为出发点，以Raspberry Pi应用开发为主线，通过Python开发简单的树莓派单片机模块，让读者熟悉Raspberry和Python。本书介绍Linux的最常用命令和Python的常用模块，并举实例详细讲解。本书共8章，涵盖的主要内容有Linux和Raspberry简介、Raspberry安装配置、Raspberry开发利器、Raspberry常用服务、Raspberry常用功能、Raspberry GPIO、Raspberry开门报警器实战、Raspberry移动小车实战。本书所有源代码已上传网盘供读者下载使用。本书内容丰富，实例典型，实用性强，适合树莓派初学者、物联网和智能家居开发人员，以及高等院校和培训学校相关专业的师生阅读。 本书封面贴有清华大学出版社防伪标签，无标签者不得销售。  版权所有，翻印必究。举报电话：010-62782989　13501256678　13801310933  图书在版编目（CIP）数据 树莓派开发从零开始学：超好玩的智能小硬件制作书 / 胡松涛编著．—北京：清华大学出版社，2016ISBN 978-7-302-43265-4I． ①树…　Ⅱ．①胡…　Ⅲ．①软件工具—程序设计　Ⅳ．①TP311.56中国版本图书馆CIP数据核字（2016）第044182号 责任编辑： 夏非彼 责任校对： 闫秀华 责任印制：  出版发行： 清华大学出版社 地　　址： 北京清华大学学研大厦A座http://www.tup.com.cn 邮　　编： 100084 社 总 机： 010-62770175 邮　　购： 010-62786544 投稿与读者服务： 010-62776969，c-service@tup.tsinghua.edu.cn 质量反馈： 010-62772015，zhiliang@tup.tsinghua.edu.cn 印 装 者： 清华大学印刷厂 经　　销： 全国新华书店 开　　本： 190mm×260mm 印　　张： 13 字　　数： 333千字 版　　次： 2016年4月第1版 印　　次： 2016年4月第1次印刷 印　　数： 1~3000 定　　价： 69.00元产品编号：067082-01前言随着计算机硬件的急剧微型化和物联网的快速发展，出现了越来越多的微型计算机，而树莓派（Raspberry Pi，本书简称为“Raspberry”）就是其中的佼佼者。Raspberry Pi是一款针对电脑业余爱好者、教师、小学生以及小型企业等用户的迷你电脑，预装Linux系统，体积仅信用卡大小，搭载ARM架构处理器，运算性能和智能手机相仿。Raspberry默认的操作系统还是Linux，其他的微型计算机的操作系统大多也是嵌入式的Linux。目前普通大众对Linux了解不多，即使有好的硬件设备也难以发挥它的功能。网络上讲解Raspberry的帖子不少，要么语言不详，要么因为软硬件的升级而不再适用。本书是以实战为主旨，一步步地从安装系统开始，让读者熟悉Linux、使用Linux、喜欢Linux，并安排了实战项目指导读者对Raspberry进行开发，开发中使用了Python脚本语言，会让读者眼界大开。本书共8章，前面5章是Raspberry开发基础，第6章包括LED呼吸灯、蜂鸣器、超声波模块3个小实例，第7章为智能开门报警器实例，第8章为移动小车实例。没有任何Linux基础的读者，建议从第1章顺次阅读并演练每一个实例。有一定Linux基础的读者，可以根据实际情况有重点地选择阅读各个模块和项目案例。本书特色1．附带全部源代码，提高学习效率为了便于读者理解本书内容，作者已将所有源代码上传到网络，供读者下载使用。读者通过源代码学习开发思路，优化代码。2．涵盖Linux的安装配置和python GPIO的开发本书涵盖Linux和Raspberry简介、Raspberry安装配置、Raspberry开发利器、Raspberry常用服务、Raspberry常用功能、Raspberry GPIO、Raspberry开门报警器实战、Raspberry移动小车实战。3．对GPIO Python开发作了原理上的分析本书在实战开发前对开发原理做出了详细的讲解，便于读者理解思路及代码的运行。4．模块驱动，应用性强本书提供了3个最简单的模块开发以方便读者自学，且这些模块可以组合应用成复杂的实际项目，具有超强的实用性。5．项目案例典型，实战性强，有较高的应用价值本书最后两章提供了2个项目实战案例，具有很高的应用价值和参考性，而且这些实例都是通过前面的基础讲解组合应用，便于读者融会贯通地理解本书所介绍的技术。这些案例稍加修改，便可用于实际项目开发中。本书读者树莓派开发初学者单片机开发初学者物联网开发人员智能家居开发人员高校和培训学校相关专业的师生本书由胡松涛主笔，其他参与编写的有宋士伟、张倩、周敏、魏星、邹瑛、王铁民、殷龙、李春城、张兴瑜、马新原、李柯泉、林龙、赵殿华、牛晓云。代码下载本书源代码下载地址如下： http://pan.baidu.com/s/1nuvxVi5 如果下载有问题，请电子邮件联系booksaga@163.com，邮件主题为“树莓派”。编者2016年1月目录 前言  第1章　Linux和Raspberry的简介  1.1　Linux前世今生  1.1.1　Linux的诞生  1.1.2　Linux的发行版本  1.1.3　Linux的将来  1.2　深度剖析Raspberry  1.2.1　Raspberry Pi的诞生  1.2.2　Raspberry家族  1.3　Raspberry配件选择  1.3.1　Raspberry必要设备  1.3.2　Raspberry非必要设备  1.4　Raspberry OS的选择  1.4.1　Raspberry官网推荐OS  1.4.2　官方推荐的第三方OS  1.4.3　其他的OS  第2章　Raspberry的安装配置  2.1　从零开始安装配置Raspberry  2.1.1　下载Raspberry的系统  2.1.2　Windows下安装RaspBian  2.1.3　Linux下安装RaspBian  2.1.4　Mac OS下安装RaspBian  2.2　RaspBian基本配置  2.2.1　raspi-config配置  2.2.2　网络配置  2.2.3　无线网络配置  2.2.4　其他配置  2.3　远程无密码登录  2.3.1　Windows远程无密码登录  2.3.2　Linux远程无密码登录  2.4　系统备份和还原  2.4.1　tar备份还原  2.4.2　tar增量备份还原  2.4.3　dd备份还原  第3章　Raspberry开发利器  3.1　apt-get  3.1.1　apt-get简介  3.1.2　apt命令用法  3.2　vim  3.2.1　vim简介  3.2.2　安装配置vim  3.2.3　以vim做一个简单的python IDE  3.2.4　vim使用指南  3.3　bash  3.3.1　bash简介  3.3.2　第一个bash脚本Hello world  3.3.3　bash script实例——增量备份脚本  3.4　Python  3.4.1　Python简介  3.4.2　第一个Python脚本Hello world  3.4.3　Python常用模块  3.4.4　Python script实例——touch2py.py  3.4.5　Python进阶实例——getNip.py  3.5　常用工具  3.5.1　正则表达式（RE）  3.5.2　grep  3.5.3　find  3.5.4　sed  3.5.5　awk  3.5.6　其他常用工具  第4章　Raspberry常用服务  4.1　xrdp远程桌面服务  4.1.1　xrdp简介  4.1.2　xrdp安装  4.1.3　登录xrdp  4.2　samba共享服务  4.2.1　samba简介  4.2.2　samba安装  4.2.3　samba配置  4.2.4　登录samba服务器  4.3　miniDLNA共享影音服务  4.3.1　miniDLNA简介  4.3.2　miniDLNA安装  4.3.3　miniDLNA配置  4.4　VSFTP FTP服务  4.4.1　VSFTP简介  4.4.2　VSFTP安装  4.4.3　vsftp配置  4.4.4　登录VSFTP服务器  4.5　Nginx  4.5.1　Nginx简介  4.5.2　Nginx安装  4.5.3　Nginx配置  4.6　LAMP  4.6.1　LAMP简介  4.6.2　LAMP安装  4.6.3　LAMP配置  第5章　Raspberry常用功能  5.1　挂载磁盘  5.1.1　硬件准备  5.1.2　软件设置  5.2　Aria2下载机  5.2.1　安装下载组件  5.2.2　Aria2配置  5.2.3　测试Aria2下载机  5.3　迅雷远程下载  5.3.1　下载迅雷远程下载固件  5.3.2　设置迅雷远程下载  5.4　动态域名解析  5.4.1　神器花生壳  5.4.2　下载安装花生壳  5.4.3　设置花生壳  5.5　无域名访问内网  5.5.1　确定公网IP  5.5.2　端口映射  5.6　实战：Raspberry给自己发短信  5.6.1　方案原理  5.6.2　方案执行  5.7　监控器Motion  5.7.1　安装Motion  5.7.2　配置使用Motion  第6章　实战Raspberry GPIO  6.1　GPIO简介  6.1.1　Raspberry GPIO  6.1.2　物理端口  6.2　实战GPIO——LED呼吸灯  6.2.1　准备实验物品  6.2.2　Python控制  6.3　实战GPIO——蜂鸣器  6.3.1　准备实验物品  6.3.2　Python控制  6.4　实战GPIO——超声波模块  6.4.1　准备实验物品  6.4.2　Python控制  第7章　实战：智能开门报警器  7.1　硬件准备  7.1.1　必需的硬件  7.1.2　可选硬件  7.1.3　组装及原理  7.2　软件准备  7.2.1　创建mylog模块  7.2.2　Python控制  第8章　实战：移动小车（手机控制+网页控制）  8.1　硬件准备  8.1.1　必需的硬件  8.1.2　可选的硬件  8.2　组装及原理  8.2.1　小车组装  8.2.2　电机组装  8.2.3　小车原理  8.3　软件准备  8.3.1　Python控制  8.3.2　Web控制和手机控制  8.3.3　无线设置 第1章　Linux和Raspberry的简介Raspberry Pi（中文名为“树莓派”，简写为RPi，或者RasPi/RPi）是为学生计算机编程教育而设计，只有信用卡大小的卡片式电脑，其系统基于Linux。树莓派由注册于英国的慈善组织“Raspberry Pi基金会”开发，Eben·Upton（埃·厄普顿）为项目带头人。Raspberry外形只有信用卡大小，却具有电脑的所有基本功能。本章主要内容包括：Linux简介了解Raspberry的知识为Raspberry挑选合适的版本 1.1　Linux前世今生在了解Raspberry之前就不得不先了解一下Linux。毕竟Raspberry默认的操作系统就是基于Linux的。本节简单地说明Linux的发展情况、目前流行的Linux版本及特点。 1.1.1　Linux的诞生Linux是一套类Unix系统（Unix-like），是Unix的一种。它控制整个系统基本服务的核心程式Kernel，是由美籍芬兰人Linus Torvalds（2010年入美国籍）于1991年带头开发出来的，Linux这个名称便是以Linus's Minix来命名的。Linus选择用GPL（General Public License）的方式来发行这份程序，这个版权允许任何人以任何形式散发、修改Linux的原始程序。换句话说，Linux实际上是“免费的”。使用者在网络上就可以下载到Linux的原始程序，并随心所欲地散发与更改。在网络上日渐盛行以及Linux开放自由的版权之下，吸引了无数电脑高手投入开发、改善Linux的核心程序，使得Linux的功能日渐强大。今天我们可以在网络上免费下载Linux使用，这都是因为Linux是GPL版权的缘故。Linux实际上只是一份内核程序，它并不是操作系统。我们常说的Linux，例如Debian、CentOS、Fedora、Arch Linux、Gentoo、RHCE、Ubuntu、Deepin Linux、Rad Flag、StartOS等等发行版本都是以Linux kernel为核心，加以必要的应用程序组合而来的。 1.1.2　Linux的发行版本Linux的发行版本很多，无法统计具体数量。每天都有Linux发行版本诞生、消失。它们有很多都用于特殊场合，比如用于自启动光盘的Kanotix Linux，用于教育方面的EduLinux，用于Network检测的Kali Linux（以前叫Back Track）……Linux的发行版本可以大体分为两类：一类是商业公司维护的发行版本，一类是社区组织维护的发行版本。前者以著名的RedHat为代表，后者以Debian为代表。1．RedhatRedhat，应该称为RedHat系列，包括RHEL（RedHat Enterprise Linux，也就是所谓的RedHat Advance Server收费）、Fedora（由原来的RedHat桌面版本发展而来，免费）、CentOS（RHEL的社区克隆版本，免费）。RedHat应该说是在国内使用人群最多的Linux版本，甚至有人将RedHat等同于Linux。这个版本的特点就是使用人群数量大，资料非常多，言下之意就是如果你有什么不明白的地方，很容易找到人来问，而且网络上的一般Linux教程都是以RedHat为例来讲解的。RedHat系列的包管理方式采用的是基于RPM包的YUM包管理方式，包分发方式是编译好的二进制文件。稳定性方面RHEL和CentOS非常好，适合于服务器使用，但是Fedora的稳定性一般，最好只用于桌面应用。2．DebianDebian，或者称Debian系列，包括Debian和Ubuntu等。Debian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。Debian最早由Ian Murdock于1993年创建，分为三个版本分支（Branch）：Stable、Testing和Unstable。其中，Unstable为最新的测试版本，包括最新的软件包，但是也有相对较多的Bug，适合桌面用户。Testing的版本都经过Unstable中的测试，相对较为稳定，也支持了不少新技术（比如SMP等）。而Stable一般只用于服务器，上面的软件包大部分都比较过时，但是稳定性和安全性都非常地高。Debian最具特色的是apt-get /dpkg包管理方式，其实RedHat的YUM也是在模仿Debian的APT方式，但在二进制文件发行方式中，APT应该是最好的了。Debian的资料也很丰富，有很多支持的社区，有问题求教也有地方可去。3．UbuntuUbuntu，严格来说不能算一个独立的发行版本，Ubuntu是基于Debian的Unstable版本加强而来，可以这么说，Ubuntu就是一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的Linux桌面系统。根据选择的桌面系统不同，有三个版本可供选择：基于Gnome的Ubuntu、基于KDE的Kubuntu以及基于Xfce的Xubuntu。特点是界面非常友好，容易上手，对硬件的支持非常全面，是最适合做桌面系统的Linux发行版本。4．GentooGentoo，伟大的Gentoo是Linux世界最年轻的发行版本，正因为年轻，所以能吸取在她之前的所有发行版本的优点，这也是Gentoo被称为最完美的Linux发行版本的原因之一。5．FreeBSD需要强调的是：FreeBSD并不是一个Linux系统！但FreeBSD与Linux的用户群有相当一部分是重合的，二者支持的硬件环境也比较一致，所采用的软件也比较类似，所以可以将FreeBSD视为一个Linux版本来比较。FreeBSD拥有两个分支：Stable和Current。顾名思义，Stable是稳定版，而Current则是添加了新技术的测试版。FreeBSD采用Ports包管理系统，与Gentoo类似，基于源代码分发，必须在本地机器编译后才能运行，但是Ports系统没有Portage系统使用简便，使用起来稍微复杂一些。FreeBSD的最大特点就是稳定和高效，是作为服务器操作系统的最佳选择，但对硬件的支持没有Linux完备，所以并不适合作为桌面系统。 1.1.3　Linux的将来Linux的应用范围很广，可以说人类生活中处处都有Linux。1．服务器最常见的Linux应用是服务器。多年来，Linux一直是超级计算机领域里的王者。在Linux企业级终端用户峰会（Linux Enterprise End-User Summit）上最新一期的世界最快超级计算机排行榜出炉，在世界最快超级计算机500强排行中，Linux不仅占据主导地位，且将对手远远甩在身后。同时它还有将其他对手挤出500强名单之势。在世界上500台最快的计算机里，强劲的开源操作系统Linux占了其中的485个位子，再创新高。换句话说，世界上最快的计算机里97％是基于Linux的。剩下的15台计算机里有13台运行Unix系统。这些计算机均运行IBM Power处理器，运行IBM AIX操作系统。其中最快的是英国的天气预测系统ECMWF，在该榜单里排名第60位。2．嵌入式Linux嵌入式Linux是以Linux为基础的嵌入式作业系统，它被广泛应用在移动电话、个人数字助理（PDA）、媒体播放器、消费性电子产品以及航空航天等领域中。嵌入式Linux是将Linux操作系统进行裁剪修改，使之能在嵌入式计算机系统上运行。嵌入式Linux既继承了Internet上无限的开放源代码资源，又具有嵌入式操作系统的特性。我们使用的Android手机就是基于嵌入式Linux。电视机顶盒基于嵌入式Linux。路由器、交换机基于嵌入式Linux。Play Station基于嵌入式Linux。车载导航系统基于嵌入式Linux……可以说嵌入式Linux在我们周围无处不在。3．Android对，没错。目前最流行的手机操作系统Android同样也是基于Linux系统。虽然它只使用了Linux的内核，并对内核进行了一些必要的裁剪，但毫无疑问Android同样出生于Linux，并依附Linux吸取营养茁壮成长。4．DesktopLinux同样运行于桌面。不可否认Linux桌面使用率很低，但它的优秀同样是无须质疑的。Linux桌面发行版很多，几乎每天都有数个版本诞生、消失。针对不同的用户，不同的使用环境都有相应的发行版本。有针对小存储设备的Tiny Linux，有适合儿童使用的OIMO Linux，有针对中国用户的麒麟Linux，有专门用于网络检测的Kali Linux，它的前身是大名鼎鼎的BackTrack。使用率最高的一般是Debian、Ubuntu、Fedora、SUSE……它们虽然目前的市场占有率不高，但潜力强大不容小窥。注意日常生活中最常用的桌面OS基本都是Windows或IOS，Linux桌面极为少见。对于Linux，大部分人都是只在此山中、云深不知处的感觉。实际上Linux已经深入到我们生活之中不可分割。如果只是使用计算机可以无视Linux，想要了解计算机就不得不了解Linux。 1.2　深度剖析RaspberryRaspberry自2012年发售以来，现在已经是第2代了。升级后的Raspberry性能增强了很多。按照这样的增长速度，有理由相信在不久的将来，Raspberry性能能够追平一般的家用PC。本章简单地介绍Raspberry的硬件配置及配件。 1.2.1　Raspberry Pi的诞生Raspberry由注册于英国的慈善组织“Raspberry Pi基金会”开发，Eben·Upton/埃·厄普顿为项目带头人。2012年3月，英国剑桥大学埃本·阿普顿（Eben Epton）正式发售世界上最小的台式机，又称卡片式电脑，外形只有信用卡大小，却具有电脑的所有基本功能，这就是Raspberry Pi电脑板，中文译名树莓派。这一基金会以提升学校计算机科学及相关学科的教育，让计算机变得以有趣为宗旨。基金会期望这一款电脑无论是在发展中国家还是在发达国家，会有更多的其他应用不断被开发出来，并应用到更多领域。在2006年Raspberry早期概念是基于Atmel的ATmega644单片机，首批上市的10000“台”Raspberry的“板子”，由中国台湾和大陆厂家制造。Raspberry1是一款基于ARM的微型电脑主板，以SD卡为内存硬盘，卡片主板周围有两个USB接口和一个网口，可连接键盘、鼠标和网线，同时拥有视频模拟信号的电视输出接口和HDMI高清视频输出接口，以上部件全部整合在一张仅比信用卡稍大的主板上，具备所有PC的基本功能，只需接通电视机和键盘，就能执行如电子表格、文字处理、玩游戏、播放高清视频等诸多功能。 Raspberry Pi 1 B款只提供电脑板，无内存、电源、键盘、机箱或连线。Raspberry的生产是通过有生产许可的三家公司：Element 14/Premier Farnell、RS Components及Egoman完成。这三家公司都在网上出售Raspberry。Raspberry1配备一枚700MHz博通出产的ARM架构BCM2835处理器，256MB内存（B型已升级到512MB内存），使用SD卡当作储存媒体，且拥有一个Ethernet有线网卡接口，两个USB接口，以及HDMI（支持声音输出）和RCA端子输出支援。Raspberry Pi 1只有一张信用卡大小，体积大概是一个火柴盒大小，可以执行像雷神之锤III竞技场的游戏和进行1080p影片的播放。操作系统采用开源的Linux系统，比如Debian、ArchLinux，自带的Iceweasel、KOffice等软件能够满足基本的网络浏览、文字处理以及计算机学习的需要，分A、B两种型号。 1.2.2　Raspberry家族目前最新的Raspberry是Raspberry2。Raspberry各个型号的参数如表1-1。表1-1　Raspberry参数 短短几年，Raspberry的配置翻了一倍。虽然性能目前无法跟PC相比，但只是做私人服务器、桌面、代码开发、HTPC……家庭应用是足够了。注意Raspberry就相当于（不是等同于）集成了CPU、显卡、内存的微型PC主板，只不过这块主板是Arm构架的。 1.3　Raspberry配件选择独木难成林，光秃秃的一块板子再怎么逆天也是没用的，没有其他配件的配合照样没用。下面我们来熟悉一下Raspberry的外设设备。 1.3.1　Raspberry必要设备虽说最简单的配置只需要一个Raspberry，一个TF卡，一根充电线，一个充电头即可。可这样的“低配版”的实用效果如何那是可想而知了。下面就来说说Raspberry的必要设备及挑选要求。1．TF卡TF卡官方要求的只是4G以上，Class4以上就可以了。品牌未做要求。但现在网上一般都推荐闪迪。我用的其他品牌也没事。为安全起见还是用大家推荐的品牌好了。容量不必太大，8GB~16GB就可以了，4G的TF卡装了系统就不剩什么了。至于速度Class4是最低要求，Class10当然更好。2．充电线Raspberry所需的充电线是Micro USB通用充电线，就是一般android手机的电源线。可以找一根备用的手机充电线来用，但建议还是买一根带开关的充电线。Raspberry没有开关机按钮，只有通过连接/断开电源来开关机。每次都拔充电头比较麻烦。3．充电头充电头也可以用手机充电头，但要求是5V/2A。一般手机充电头都是1.5A的，如果电流不足可能会出现各种问题。所以，如果没有合适的充电头，还是买个符合标准的吧。4．散热片（风扇）散热片是必不可少的设备了。如果不想玩Raspberry正兴奋的时候黑屏，还是给它配上两个吧。只要不是7×24开机，散热片就足矣。也可以用小风扇，可风扇需要接电源，比较麻烦。如果没有特殊要求还是用散热片吧。5．外壳虽说把Raspberry放到桌上或是用个木夹把它夹住也不是不行。但为了美观和安全着想，最好给它配个外壳。配个一般的亚克力外壳就行，避免其他小物件碰到Raspberry而短路。6．HDMI线（HDMI转VGA线）HDMI线可以说是PC的标准配置了，要是不嫌麻烦，就用PC上的那根吧。如果显示器没有HDMI接口，那就只有配一根HDMI转VGA线了。VGA接口几乎每个显示器都有。 1.3.2　Raspberry非必要设备以下这些设备看各自的研究方向和要求选用。1．PC配件免驱USB无线网卡、USB集线器、非PS2接口的键盘鼠标、小型显示器、红外、蓝牙适配器……这些有当然更好，没有也没关系。无非就是方便顺手的问题。2．存储器不管是大容量的硬盘配硬盘盒还是大容量的移动硬盘，来一个吧。光靠TF卡的容量也只能装个系统。如果想让Raspberry发挥更大的作用，还是得加上个大的存储器。当然，如果没有也行。3．各种传感器传感器是扩展Raspberry时需要的。检测烟雾，就得有烟雾气敏传感器。测距避障，就得有超声波传感器。检测光线，就得有光敏传感器。检测温度湿度，就得有温度传感器和湿度传感器……4．面包板，杜邦线如果不想研究硬件，这个是可以略过的。或者可以找别的物品替代。5．其他设备二极管，三极管，电阻……不想研究硬件的可以略过。 1.4　Raspberry OS的选择适合Raspberry的发行版本很多，足以应付不同人群的挑选。本节列出最常见的Raspberry的操作系统，简单说明各个发行版本的适用范围及特点，以便于大家挑选最适合自己的系统。 1.4.1　Raspberry官网推荐OS适合Raspberry的发行版本有很多，很难一一列数，在这里只列出Raspberry官方推荐的几个版本。当然，非官方的Raspberry版本同样优秀。具体需要哪个版本，还要看各自的用途。笔者选择的是RaspBian，也是使用最广泛的Raspberry操作系统。1．NOOBS官方推荐的系统，可以多系统引导（包含RaspBian、Arch、OpenELEC、RaspBMC……），是个非常好用的多系统引导器。它本身就含有操作系统的全部文件，可以完全不依赖网络直接安装系统。只要记得安装完成后更新系统就行。2．NOOBS LITE官方推荐的系统，可以多系统引导。它不含操作系统的文件，纯粹是个引导器，需要依赖网络。如果网络条件非常好的情况下，选它也不错。3．RASPBIANRaspBian是专门用于ARM卡片式计算机Raspberry Pi的操作系统。RaspBian系统是Debian 7.0/wheezy的定制版本，得益于Debian从7.0/wheezy开始引入的带硬件浮点加速的ARM架构（armhf），Debian 7.0在树莓派上的运行性能有了很大提升，RaspBian默认使用LXDE桌面，内置C和Python编译器。RaspBian是Debian为Raspberry定制的版本。基本上和Debian是一模一样的。Debian使用的人数很多，稳定性好，符合POSIX（Portable Operating System Interface）标准，文件系统规范，安全稳定。如果只是日常需要，几乎不需要更新。国内的更新源多，要知道Linux非常依赖网络，软件安装、系统更新都需要网络支持。以国内的网络条件来说，还是选择一个国内源比较多的发行版本比较方便。此外，其他的第三方版本各有侧重的方面，RaspBian可以说是使用最平衡的版本。等RaspBian使用熟练了，需要其他方面支持的时候再换其他的版本。注意Debian可以说是使用跨度最大的Linux版本。它的软件丰富，系统稳定，几乎支持所有的硬件架构。不管是初学者还是资深用户使用Debian都非常顺手，它是最好的社区版Linux。这也许就是Raspberry官方为什么首推RaspBian的原因吧。个人认为国内流行RH系列主要是跟其商业推广有关，如果个人用户还是Debian系列比较合适。 1.4.2　官方推荐的第三方OS第三方的OS都有强烈的自身风格。它们往往对某一方面的支持非常好，但对其他方面就稍微差一点点。如果需要的只是某一方面的功能，那么选择第三方的OS是非常方便的。尤其是由官方推荐的第三方OS，在其特定的功能方面是无须质疑的。1．UBUNTU MATE使用的是Ubuntu的ARM版本，Gnome2桌面。使用过Ubuntu的用户会非常熟悉这个版本。这个版本非常适合做桌面，而且Ubuntu的社区支持非常丰富。不愁有问题没地方问。2．OSMCOSMC是Open Source Media Cente的缩写。一个开源的媒体中心。RaspBian配合XBMC，深度定制，不包含其他意义不大的包，最大程度发挥树莓派的视频处理能力。它默认是英文的版本，有国内开发的Raspbmc，这个更适合国情。如果只是想做HTPC，这个版本是非常合适的。3．Snappy Ubuntu CoreUbuntu的一个版本。Snappy Ubuntu Core是面向智能设备的最新平台，可以运行存储在本地或依赖于云端的相同软件，而后者的最大好处就是可以让使用者避免频繁地定期升级。4．OpenELECOpenELEC是Open Embedded Linux Entertainment Center的缩写，从字面上理解为开源嵌入式Linux娱乐中心，功能没有Raspbmc那么强大，但是对于普通的高清播放来说，这个完全足够用了。5．RISC OSRISC OS不是Linux，但它是一个实时系统。可惜很多软件都只能编译使用，有些不方便，对于有嵌入式开发经验的人士，会有一些注重实时性的应用。非专业人士不推荐使用。 1.4.3　其他的OS除了官方OS和官方推荐的OS外，其他的OS发行方也为Raspberry准备了配套的OS。它们也许没有那么强烈的自身特点，但对那些只使用某个OS的死忠用户而言，它们将是最顺手的选择。1．ArchLinuxARMArchLinuxARM是ArchLinux的ARM版本。以轻量出名，使用pacman可以快速找到自己的软件。ArchLinux也许不是最好的系统，但它一定是最方便的系统。2．PidoraPidora是Fedora的ARM版本。该系统是其专门为树莓派迷你计算机开发的基于Fedora remix的系统，Pidora 18完全基于ARMv6架构的Fedora软件包，几乎所有Fedora软件包都可以在Pidora上通过yum安装。Pidora的包是从Fedora官方资源库直接构建，同时Pidora包含树莓派特定的一些配置模块，包括默认SD卡映像，库和外部硬件设备（GPIO/I2C/SPI接口等）的支持都已包含。Fedora的赫赫威名无须任何宣传，足以在此占领一方。3．Windows 10这个系统只有在Raspberry2才能使用。Windows 10系统的优秀就不用再多介绍了。将Windows系统融入Raspberry可以说是一次里程碑式的进步。虽然说目前它还很难与PC上的Windows 10相媲美。但技术总是不断进步的，不是吗？非常期待Mac OS也能加入Raspberry的大家庭。第2章　Raspberry的安装配置对Raspberry的硬件和操作系统有了一定的了解，下面应该安装系统了。本章的目的是完全从零开始，一步步地下载所需软件，正确地安装配置Raspberry并将其备份还原。让它能发挥自己的作用。本章主要内容包括：下载Raspberry的系统配置RaspBian实现远程无密码登录系统的备份和还原 2.1　从零开始安装配置Raspberry本节将下载安装系统所需的软件和Raspberry的操作系统，演示在不同系统中写入操作系统到SD卡，并做好配置系统前的准备工作。 2.1.1　下载Raspberry的系统鉴于RaspBian的平衡和广泛，这里选择使用RaspBian系统。现在就来下载RaspBian系统。（1）首先我们百度一下“RaspBian官网”，得到RaspBian的官网网址www.raspbian.org。（2）打开这个网站，单击左侧的Images超链接，在raspberry pi foundation Raspbian Images一项中得到了RaspBian的下载页面www.raspberrypi.org/downloads/。（3）选择Raspbian debian weezy下载，大概有1GB左右，请耐心下载。这里，我选择的是http下载，得到Raspbian_latest文件，然后解压缩，得到2015-05-05-raspbian-wheezy.img文件。在这里下载的文件应该是安全的，如果还不放心，下载地址下方有校验码，可以自行校验一下。好了，现在可以开始写入系统了。 2.1.2　Windows下安装RaspBian因为绝大部分人都使用Windows系统，所以我们先从Windows系统开始。Windows系统中使用的写入软件是Win32DiskImager。它的作用是将一个文件写入U盘。如果有其他功能相似的软件都可以使用。当然，既然这个软件可以用来安装RaspBian，同样它也可以用来安装Linux和Windows。具体方法，请咨询百度，下面开始具体操作。（1）先将TF卡插入读卡器中，将读卡器插入电脑的USB接口。打开Win32 Disk Imager窗口，如图2-1所示。 图2-1　Win32 disk Imager窗口（2）在“设备”下面的下拉框选择U盘的盘符。单击文件夹图标，选择刚才下载并解压后得到的img文件。然后单击“写”按钮，进行写入。如果写入失败，没关系。按照刚才的步骤，重新再来一次。如果多次写入不成功，请检查一下TF卡是否损坏，更换TF卡后再次写入。（3）写入完成后，拔出读卡器，取出TF卡，插入Raspberry。 2.1.3　Linux下安装RaspBian前面铺垫了那么多Linux的知识，实际上就是建议大家在Linux下使用Raspberry。这里介绍一下Linux下的安装步骤。（1）先将TF卡插入读卡器，再将读卡器插入电脑的USB接口。进入系统桌面后，打开Terminal（Linux的版本太多，桌面环境也不一样，具体怎样打开Terminal，请自行百度一下）。或者直接按Ctrl + Alt + F2组合键，如图2-2进入控制台。 图2-2　Linux控制台Linux默认情况下有7个控制台，快捷键也就是Ctrl + Alt + F1~F7。一般情况下按Ctrl + Alt + F7组合键进入图形界面。但也有把图形界面放在Ctrl + Alt + F1的，其他的都是Consel字符界面。所以，Ctrl + Alt + F2最安全。输入用户名、密码登录。如果能用root登录，尽量使用root。如果没有root权限，那至少登录用户在sudoers文件中，并且有相应的执行权限。执行命令时，在命令前加上sudo。要知道一般用户是无法使用dd命令来操作磁盘的。在这里用root登录，如图2-3所示。 图2-3　root登录（2）使用ls –l /dev/sd*命令查看TF卡磁盘位置，如图2-4所示。    ls –l /dev/sd* 图2-4　查看TF卡一般的SATA硬盘都是以/dev/sd开头的。如果用的是IDE硬盘，则是以/dev/hd*开头。如果主机只有一块SATA硬盘，那么这块硬盘的标识就是/dev/sda。在此例中，主机只有一块SATA硬盘，所以读卡器中的TF卡被识别为/dev/sdb。sda1是sata硬盘的第一主分区，sda2是sata硬盘的第二主分区。sda5是sata硬盘的第一逻辑分区。同理，sdb1是读卡器中TF 卡的第一主分区。执行命令：    umount /dev/sdb1[MS1]  ~这个命令的作用是卸载读卡器中TF卡的第一主分区。因为有的Linux发行版本默认自动挂载U盘、读卡器等即插即用设备，所以执行umount命令以防万一。挂载了，就把读卡器分区卸载；没挂载，卸载一下也没什么影响，以防万一。在这里，只有/dev/sdb1，所以就只执行了umount /dev/sdb1。如果有sdb2，sdb3……那就得继续执行umount /dev/sdb2 umount /dev/sdb3……（3）卸载了读卡器的分区，现在开始写入RaspBian系统到TF卡。先进入下载文件的分区。执行命令：    cd ~进入如图2-5所示的下载文件所在目录。如果解压出来的2015-05-05-raspbian-wheezy.img在其他的目录，请进入该目录。 图2-5　进入工作目录然后使用dd命令将2015-05-05-raspbian-wheezy.img写入磁盘中去，如图2-6所示，执行命令：    dd bs=4M if=2015-05-05-raspbian-wheezy.img of=/dev/sdb  图2-6　系统写入TF卡注意这里of后面的参数是/dev/sdb，而不是/dev/sdb1，目的是将img文件写入整个磁盘，而不是磁盘的某个分区。【dd命令简介】现在在Linux下，那么我们用man dd来查看一下dd的功能，如图2-7所示，执行命令：    man dd按照man的解释： 图2-7　man dddd命令的功能与Win32DiskImager比较相似，不过功能比Win32DiskImager更强大。dd命令可以把文件写入磁盘、分区、文件，也可以把磁盘、分区、文件写入文件。下面来看下dd命令的常用参数，如图2-8所示： 图2-8　dd –help最常用的选项如下：if =输入文件（或设备名称）of =输出文件（或设备名称）ibs = bytes，一次读取bytes字节，即读入缓冲区的字节数obs = bytes，一次写入bytes字节，即写入缓冲区的字节数bs = bytes，同时设置读/写缓冲区的字节数（等于设置ibs和obs）注意详细的解释请参考man dd。（4）dd命令执行完毕后，拔出读卡器，取出TF卡，插入到Raspberry。 2.1.4　Mac OS下安装RaspBian国内目前苹果电脑也变得越来越流行，所以我们也说一下Mac下的安装。（1）首先还是打开命令行。单击“应用程序菜单”，单击“实用工具”子菜单，单击“终端”选项。（2）Mac OS是类Unix系统，而Linux脱胎继承于Unix。所以，有很多命令都是通用的。不同的是在Linux下磁盘位置是/dev/sd*或者是/dev/hd*，U盘的位置是/dev/sd*。在Mac OS下磁盘位置是/dev/disk*。/dev/rdisk1是原始字符设备，也就是U盘。所以只需要将Linux的dd命令稍微地改装一下就可以了：    dd bs=4M if=2015-05-05-raspbian-wheezy.img of=/dev/rdisk1好了将RaspBian系统写入磁盘后，下面可以开始配置系统了。注意不管是用哪种方法安装RaspBian，实质上都是将文件写入硬盘。所以如果有其他的硬盘写入软件可用，放心大胆地试吧。 2.2　RaspBian基本配置在安装Windows时，需要用户选择安装磁盘，选择时区……（当然这里说的是正常安装Windows的方法，Ghost安装是不需要的。RaspBian做好备份后，再次安装等同于Ghost安装，Windows也可以不需要配置）安装Linux同样也要选择这些。本章目的在于了解RaspBian的安装步骤，熟悉Raspi-config配置选项，正确配置Raspberry。 2.2.1　raspi-config配置将写入完毕的TF卡插入Raspberry中。在USB端口上连接好鼠标键盘（只能选用USB端口的鼠标键盘，我选用的是无线鼠标键盘，好处是占用的端口少），用hdmi线连接到显示器上，插上电源，Raspberry就开始运行了。第一次运行Raspberry时，会自动运行一个程序raspi-config，如图2-9所示。这个程序用来设置Raspberry的基本选项。下面我们就来一一配置。 图2-9　raspi-config主界面1．Expand Filesystem：Ensures that all of the SD card storage is available to the OS扩展文件系统，如图2-10。默认镜像写入TF卡后，根分区不会使用剩余的TF卡空间，也就是说不管你的TF卡有多大，系统只使用了1GB左右。剩下的空间都浪费，运行此选项后会把根分区扩展到整个TF卡，最大效率使用TF卡。如需要扩展，按Enter键确定。如果不需要，按Esc键返回raspi-config主界面。 图2-10　Expand Filesystem2．Change User Password：Change password for the default user（pi）改变默认用户pi的密码，如图2-11所示。按Enter键后输入pi用户的新密码。Raspberry默认的用户名pi的默认密码是raspberry。 图2-11　Change User Password按Enter键，如图2-12所示。 图2-12　连续2次输入密码这里请2次输入新密码。按Enter键，如图2-13所示。 图2-13　修改密码成功显示修改密码成功后，按Enter键，回到raspi-config主界面。3．Enable Boot to Desktop/Scratch：Choose whether to boot into a desktop evironmetn, scratch, or the command-line启动时进入的环境选择，如图2-14所示。 图2-14　启动环境选择Console Text console, requiring login（default）：启动时进入字符控制台，需要进行登录（默认项）。Desktop Log in as user 'pi' at the graphical desktop：启动时以用户pi登录LXDE桌面环境。Scratch Start the Scratch programming environment upon boot：启动时进入Scratch编程环境。一般来说，选择Desktop Log in as user 'pi' at the graphical desktop比较方便。以Up键（上箭头）Down键（下箭头）移动光标，选择好后用Tab键跳至&lt;OK&gt;选项。按Enter键，回到raspi-config主界面。4．Internationalisation Options：Set up language and regional settings to match your location国际化选项，可以更改语言、时区、键盘布局，如图2-15所示。 图2-15　国际化配置主界面I1 Change Locale：语言和区域设置，按Enter键进入选择，如图2-16所示。以Up键（上箭头）Down键（下箭头）移动光标，用空格键选择。选择系统支持的字符编码en_US.UTF-8、zh_CN.UTF-8。有这两个基本上就足够了，如有特殊需要，酌情选择。 图2-16　系统语言选择I2 Change Timezone：设置时区，如果不进行设置，PI的时间就显示不正常。选择Asia（亚洲），如图2-17所示。 图2-17　时区选择I3 Change Keyboard Layout：选择键盘布局，默认的键盘布局是英式的。需要修改一下。但在这里配置修改比较麻烦。可以执行命令：    nano –w /etc/default/keyboard将其内容修改成下面的代码：    XKBMODEL="pc104"    XKBLAYOUT="us"    XKBVARIANT=""    XKBOPTIONS="terminate:ctrl_alt_bksp"        BACKSPACE="guess"按Ctrl + x组合键，保存退出。如果文件被改动，会提示是否保存修改，输入“Y”，按Enter键保存。5．Enable Camera：Enable this Pi to work with the Raspberry Pi Camera启动Pi的摄像头模块，如果想启用，选择Enable，禁用选择Disable就行了。6．Add to Rastrack：Add this Pi to the online Raspberry Pi Map（Rastrack）把你的Pi的地理位置添加到一个全世界开启此选项的地图。7．Overclock：Configure overclocking for your Pi超频，强烈建议不要更改，更改后会失去保修。None不超频，运行在700Mhz，核心频率250Mhz，内存频率400Mhz，不增加电压。Modest适度超频，运行在800Mhz，核心频率250Mhz，内存频率400Mhz，不增加电压。Medium中度超频，运行在900Mhz，核心频率250Mhz，内存频率450Mhz，增加电压2V。High高度超频，运行在950Mhz，核心频率250Mhz，内存频率450Mhz，增加电压6V。Turbo终极超频，运行在1000Mhz，核心频率500Mhz，内存频率600Mhz，增加电压6V。8．Advanced Options：Configure advanced settings高级设置A1 Overscan：是否让屏幕内容全屏显示。A2 Hostname：在网上邻居或者路由器能看到的主机名称。A3 Memory Split：内存分配，选择给GPU多少内存。A4 SSH：是否运行SSH登录，强烈建议开启此选项，方便以后操作Pi，有网络就行，不用开启屏幕了。A5 Device Tree：是否启用Device Tree，略过。A6 SPI：是否默认启动SPI内核驱动，略过。A7 I2C：是否载入I2C总线模块，略过。A8 Serial：是否串行连接内核、shell，略过。A9 Audio：选择声音默认输出到模拟口还是HDMI口。A0 Auto：自动选择。    1 Force 3.5mm（'headphone'） jack强制输出到3.5mm模拟口    2 Force HDMI强制输出到HDMI。    A7 Update把raspi-config这个工具自动升级到最新版本。9．About raspi-config：Information about this configuration tool关于raspi-config的信息。所有设置完毕后按TAB键，单击Finsh按钮后按Enter键保存。 2.2.2　网络配置此时，Raspberry基本上可以运行了。不过革命尚未成功，同志仍需努力。要想方便地使用Raspberry，还有一些地方需要配置。首先我们需要配置的是网络，以有线网络为例。将网线正确地插入到rj45端口，网络参数的配置文件是/etc/network/interfaces。注意Linux下最有名的文字编辑器是nano和vi。几乎所有的Linux至少默认安装了其中的一种。个人推荐使用vi的扩展版本vim。RaspBian只安装vi，没有默认安装vim，不过没关系，暂时先用nano吧。它也挺不错的，跟Windows下的notepad（记事本）很类似。Linux几乎所有的系统配置文件都在/etc下。etc源自于拉丁语中etcetera，有零散的意思。好了，现在我们来设置有线的网络连接。（1）执行命令：    sudo cp /etc/network/interfaces /etc/network/interfaces.bak    sudo nano -w  /etc/network/interfacessudo是super user do的缩写。它在此处的作用是以超级用户的权限来执行命令。第一条命令的作用是，在interfaces的目录下创建一个备份文件，以免文件破坏后无法恢复。第二条命令的作用是，用nano编辑器打开interfaces文件，如图2-18所示。 图2-18　nano编辑interfaces（2）自动运行lo，lo即localhost，就是127.0.0.1。    auto lo（3）回环地址    Iface lo  inet loopback （4）设置网络接口eht0的IP获取方式dhcp。eth0是有线网络的第一个网络接口，第二个就是eth1……wlan0是无线网络的第一个网络接口，第二个就是wlan1。    Iface eth0 inet dhcp（5）再执行命令：    allow-hotplug eth0意思是eth0网络接口允许热插拔，这里主要是配置有线网络，也就是eth0，那么只需要留下系统的回环地址和eth0的配置就可以了。最终接结果如下：    ####    lo是回环配置    auto lo    iface lo inet loopback        ####    eth0是第一个有线网卡    auto eth0    allow-hotplug eth0    #iface eth0 inet manual    iface eth0 inet static    address 192.168.2.11    netmask 255.255.255.0    gateway 192.168.2.1        ####    wlan0是第一个无线网卡    #auto wlan0    #allow-hotplug wlan0    #iface wlan0 inet manual    #wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf        ####    wlan1是第二个无线网卡    #auto wlan1    #allow-hotplug wlan1    #iface wlan1 inet manual注意单行注释只用在行首添加“#”符号。把所有不需要的行前面都添加一个“#”。如果实在是不需要，完全可以把这些注释行删除。    iface eth0 inet static这种是设置eth0获取IP的方式。static是指设置静态IP。另外一种就是dhcp（Dynamic Host Configuration Protocol，动态主机配置协议）是由系统分配IP。如果需要设置成dhcp，应该如下设置：    iface eth0 inet dhcp设置成静态分配IP后，就必须给出网络地址、子网掩码和网关。DHCP就不用了。    address 192.168.2.91    netmask 255.255.255.0    gateway 192.168.2.1最后看最下面的2行，是nano的提示信息，如图2-19所示。 图2-19　nano提示信息按Ctrl + x组合键，保存退出。如果文件被改动，会提示是否保存修改，输入Y，按Enter键保存。好了，如果只需要有线网络，这样设置就足够了。然后重启网络服务，这个设置就生效了。查看修改配置后的结果，如图2-20所示。    sudo /etc/init.d/networking restart    ifconfig  图2-20　ifconfig网络配置成功，可以用ping命令自行检测一下。 2.2.3　无线网络配置如果可以，尽量使用有线网卡。不是Raspberry的无线不给力，而是免驱支持Raspberry的无线网卡实在是不多。为了避免安装驱动的麻烦，还是使用有线网卡方便。如果无线网卡是免驱的或者已经安装好驱动后，RaspBian上配置无线网卡很简单。同样还是使用vim修改/etc/network/interfaces。以下是最后修改好的interfaces代码：    ####    回环地址    auto lo    iface lo inet loopback        ####    第一个有线网卡    auto eth0    allow-hotplug eth0    #iface eth0 inet manual    iface eth0 inet static    address 192.168.2.91    netmask 255.255.255.0    gateway 192.168.2.1        ####    第一个无线网卡    auto wlan0    allow-hotplug wlan0    iface wlan0 inet static    address 192.168.2.92    netmask 255.255.255.0    gateway 192.168.2.1    wpa-ssid yourssid    wpa-psk youpassword重启系统，执行命令：    sudo reboot好了，系统重启后无线网卡将自动连接到wifi上了。可以拔下有线网卡上的网线了。无线连接网络优势在于使用方便，有线连接的优势在于性能优越。根据需要自行选择。注意不管是选择有线连接还是无线连接，建议都是用静态分配IP。这是为了以后Putty连接方便。总不能每次连接Raspberry前都扫描一次内网确定Raspberry的IP吧。 2.2.4　其他配置/etc/hosts文件保存的是与IP对应的主机名。在Raspberry解析网络域名时，它首先就是查询/etc/hosts文件，是否有这个域名存在。如果有，则不查询DNS，直接在本地解析域名的IP。如果没有，则向上一级查询域名。执行命令：    nano –w /etc/hosts在文件末尾添加“192.168.2.91 pi”，按Ctrl+x组合键保存文件，输入Y，确认保存。这里不需要重启服务直接生效。注意如果在这个文件末尾添加了“192.168.2.91 www.baidu.com”会怎么样呢？没错，当你用Raspberry浏览百度网页的时候，实际指向的却是Raspberry的web服务。/etc/resolv.conf，这个文件保存的是DNS信息。执行命令：    nano –w /etc/resolv.conf在百度里搜索一下网络供应商提供的DNS，例如武汉电信的DNS就是202.103.24.68。修改文件内容为“nameserver 202.103.24.68”，按Ctrl+x组合键保存文件，输入Y，确认保存。这里不需要重启服务。下面开始修改Raspberry的更新源，这是最为重要的修改。Raspberry的更新源实际就是一个个服务器的地址。Raspberry默认的更新源都在国外。我们用apt-get安装软件，更新系统速度比较慢。因此，我们要把Raspberry的更新源换成国内的。/etc/apt/sources.list，这个文件保存的就是更新源的信息。到RaspBian的官网查看一下更新源的镜像信息。使用浏览器打开http://www.raspbian.org/RaspbianMirrors。在网页上按Ctrl + f组合键，查找China，如图2-21所示。 图2-21　RaspBian更新源以上都是RaspBian推荐的官方源，实际上还有其他的源可用，比如：中国科学技术大学：RaspBian http://mirrors.ustc.edu.cn/raspbian/raspbian/搜狐源：RaspBian http://mirrors.sohu.com/raspbian/raspbian/但还是官方推荐源用得比较放心。执行命令：    nano –w /etc/apt/sources.list直接先把官方源去掉或者前面加#号注释掉，添入以下源：    deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main contrib non-free rpi按Ctrl + x组合键保存文件，输入Y，确认保存。无须重启服务，设置直接生效，只需要执行命令：    sudo apt-get update    sudo apt-get upgrade第一条命令的作用是更新源列表，第二条命令的作用是更新系统。注意到了这一步，Raspberry基本上已经配置完毕可以使用了。后面的步骤只是为了更方便地使用。 2.3　远程无密码登录大概很少有人专门为Raspberry配块显示器吧。大多数人都是使用远程登录软件，用ssh来连接Raspberry的。但麻烦的是每次登录都得一次次地输入密码。为了使用方便，可以为Raspberry创建一套钥匙。本章将简单说明公钥私钥，使用ssh工具远程无密码登录Raspberry。 2.3.1　Windows远程无密码登录Putty是一个Telnet、SSH、Rlogin、纯TCP以及串行接口连接软件，它支持Windows、Linux、Bsd平台，据说正在开发Mac OS版本的Putty。Putty体积小、功能强，使用方便，是SSH连接工具中的明星软件。本书统一使用Putty来连接Raspberry。1．确定网络首先得确定，Raspberry和正在使用的Windows PC在同一局域网内，或者两者之间能连通。单击“开始”→“附件”→“命令提示符”打开命令窗口，如图2-22所示。 图2-22　测试网络2．登录Raspberry刚配置好的Raspberry的IP设置的是192.168.2.91。我们先打开Putty，如图2-23。 图2-23　Putty在Host Name（or IP address）下面的文本框中输入Raspberry的IP地址，按Save按钮，创建了一个Putty的会话（session），如图2-24所示。 图2-24　输入用户名输入默认的用户名pi，按Enter键，界面如图2-25所示。 图2-25　输入密码输入配置Raspberry时设定的密码后再按Enter键。现在就登录到了Raspberry上了。怎样做到无密码登录呢？这里就先得说说Public Key（公钥）和Private Key（私钥）了。我们暂时可以简单地理解成锁和钥匙的关系。公钥是锁，锁住Raspberry（用在服务端）；私钥是钥匙，用来开锁登录（用在客户端）。实际上当然没这么简单，但在这里，我们也只需要有这个概念就可以了。更复杂详细的解释，请参考百度。在Raspberry上，使用ssh-keygen命令来生成公钥和私钥。先来man一下ssh-kengen命令，如图2-26所示。 图2-26　man ssh-keyenssh-kengen的参数很多，我们只需要知道其中的两个就可以了。-P：提供密码。-t：加密方式，可以使用：rsa1（SSH-1）rsa（SSH-2）dsa（SSH-2）。3．创建公钥、私钥在刚登录的Putty会话中输入命令：    ssh-keygen –t rsa –P “”注意这里的命令不需要加sudo，直接登录用户执行命令。这个命令的作用是，使用ssh-keygen命令来创建一对密钥，加密方式是rsa，密码为空。按Enter键，就会在/home/pi/目录下创建了.ssh目录和.ssh/id_rsa、.ssh/id_rsa.pub文件。其中id_rsa就是私钥，id_rsa_pub就是公钥。4．公钥作用于服务端现在我们把锁（公钥public key）挂到Raspberry的大门上。执行命令：    cat /home/pi/.ssh/id_rsa.pub &gt;&gt; /home/pi/.ssh/authorized_keys5．私钥传至客户端把私钥分发给需要登录Raspberry的主机就可以了。下面使用WinSCP这个软件，将Raspberry上的私钥id_rsa拷贝到Windows下，如图2-27所示。 图2-27　WinSCP在主机名下面的文本框输入Raspberry的IP，用户名下面的文本框输入pi，密码下面的文本框输入Raspberry的密码。单击“登录”按钮，出现如图2-28所示窗口。 图2-28　winscp登录左边窗口显示的是Windows目录，右边窗口显示的是Raspberry的目录。单击id_rsa，将其拖动到左边的目录下。好了，现在id_rsa私钥就被传到Windows目录下了。6．转换私钥Putty并不能直接使用这个私钥，我们还得经过一道手续才行。先在Putty目录创建一个keys文件夹，这个文件夹建在哪里都一样，放到Putty目录下只是为了方便而已。假设目录为c:\putty\。打开Putty目录下的puttygen.exe，如图2-29所示。 图2-29　puttygen单击File菜单中的load private key选项，打开的对话框如图2-30所示。 图2-30　Load private key怎么什么都没有？没关系，单击“取消”按钮上面的下拉框，将其选取成All Files（*.*），现在id_rsa显示出来了。单击id_rsa私钥文件，再单击“打开”按钮，如图2-31所示。 图2-31　Select private key单击“确定”按钮，然后单击Save private key按钮，如图2-32所示。 图2-32　Save private key单击“是（Y）”按钮，出现如图2-33所示界面。 图2-33　保存Putty密钥在文件名后面的文本框中输入密钥名pi，单击“保存”按钮，得到了pi.ppk文件。将pi.ppk文件拷贝到Putty目录中刚创建的keys目录下。7．创建快捷方式在Windows桌面的空白处，右击打开桌面菜单。单击“新建”→“快捷方式”选项，打开的对话框如图2-34所示。 图2-34　创建快捷方式在“请键入对象的位置”下面的文本框输入：     "c:\PUTTY.EXE" -i "c:\putty\key\pi.ppk " pi@192.168.2.91注意这里是假设Putty的目录是c:\putty，可根据自己的实际情况修改。单击“下一步”按钮，出现图2-35所示界面。 图2-35　快捷方式完成在“键入该快捷方式的名称”下的文本框输入Raspberry，单击“完成”按钮，就得到了一个名为Raspberry的Putty快捷方式。现在完成了，双击Raspberry快捷方式，就可以直接登录Raspberry了，如图2-36所示。如果想漂亮一点，可自行下载一个Rasbperry的icon图标，换到这个快捷方式上。 图2-36　Putty无密码登录 2.3.2　Linux远程无密码登录在Linux上用ssh无密码登录，与Windows上的原理是一样的。Raspberry也属于Linux，师出同门就更方便了。1．登录客户端在Linux下，打开Terminal。或者直接按Ctrl + Alt + F2组合键，如图2-37所示进入控制台。 图2-37　Linux控制台2．在客户端创建公钥、私钥输入用户名密码登录后。这里不需要用root登录，一般用户都可以。执行命令：    ssh-keygen –t rsa –P ""按Enter键就会在登录用户的家目录下创建.ssh目录和.ssh/id_rsa、.ssh/id_rsa.pub文件。3．将公钥传至服务端（Raspberry）下面我们要将Linux中创建的公钥id_rsa.pub传输到Raspberry。执行命令：    ssh pi@192.168.2.91输入pi的密码，登录到了Raspberry，如图2-38所示。 图2-38　登录到Raspberry执行命令：    scp loginName@LinuxIP:/home/loginName/.ssh/id_rsa.pub /home/pi/.ssh/linux.pubkey这里需要输入Linux用户的密码。4．公钥作用于服务端把锁挂在大门上，运行命令：    cd .ssh    cat linux.pubkey &gt;&gt; authorized_keys    loginName是Linux用户的登录名。LinuxIP是Linux主机的IP。好了，到这一步就可以了。执行命令：    exit现在又回到了Linux。再次执行命令：    ssh pi@192.168.2.91这里就不再需要输入密码了，可以直接登录到Raspberry上了。注意在Windows登录时使用的是服务端（Raspberry）创建公钥、私钥。在Linux登录时使用的是客户端（Linux）创建公钥、私钥。这两种方式效果是一样的。 2.4　系统备份和还原好不容易安装配置好RaspBian系统，如果因为一个小失误却不得不重装系统，然后再配置一遍。费时费力，那真是让人抓狂。如果在Windows下该怎么办呢？很简单用ghost备份。Linux下同样简单，还是备份。本章将熟悉备份、还原工具，熟练掌握备份、还原系统。Linux的备份有很多方法，这里我们来讲解其中最简单的两种：一种是以tar来压缩，一种是以dd命令来备份。 2.4.1　tar备份还原1．tar备份系统首先来看下tar命令的作用，如图2-39所示。 图2-39　man tartar是一个打包程序。有点类似于Windows下的Winrar。但它没有压缩功能，如果需要压缩，还得配合gzip一起使用。tar的参数有很多。常用的几个参数如下。-c：建立一个压缩文件的参数指令（create的意思）。-x：解开一个压缩文件的参数指令。-t：查看tarfile里面的文件。注意在参数的下达中，c/x/t仅能存在一个！不可同时存在！因为不可能同时压缩与解压缩。-z：gzip压缩/解压缩。-j：bzip2压缩/解压缩。-v：压缩的过程中显示文件。-f：使用文件名，请留意，在f之后要立即接文件名，不要再加参数。例如使用tar -zcvfP tfile sfile就是错误的写法，要写成tar -zcvPf tfile sfile才对。-g：增量备份-p：保留原文件的原来属性。-P：可以使用绝对路径来压缩。-N：比后面接的日期（yyyy/mm/dd）还要新的才会被打包进新建的文件中。--exclude FILE：在压缩的过程中，不要将FILE打包。好了，下面正式开始备份步骤。（1）查看需要备份的目录使用Putty登录Raspberry后执行命令：    ls /查看Raspberry的根目录，如图2-40所示。 图2-40　根目录并不是整个系统都需要备份的，有些目录完全可以略过。lost+found：存放修复或损坏的文件的目录，一般情况下里面没有东西。mnt：一般用来挂载硬盘优盘的目录。proc：目录文件，只存在内存当中，而不占用外存空间。sys：内核信息映射。media：一般用来挂载光盘。tmp：临时文件。也就是说以上的几个目录是可以不打包的。（2）进入备份目录，开始备份原理弄清楚了，下面执行命令：    cd /tmp    tar zcvpf pi_20150718.tar.gz –exclude=/lost+found –exclude=/mnt –exclude=/sys –exclude=/proc –exclude=/media –exclude=/tmp /第一条命令是进入/tmp备份目录下。第二条命令作用是，除了以上几个文件夹外，使用gzip压缩，打包整个系统。压缩文件名为pi_20150718.tar.gz。等命令执行完毕后，找个大容量的优盘挂载到pi上，将pi_20150718.tar.gz转移到优盘保存，或者利用scp命令将该备份文件转移到其他PC上。注意使用tar备份，可以直接在Raspberry上执行。也就是说在本机来备份本机，有点类似于GHOST的备份。刚才的例子里，我是在/tmp目录下进行备份的，优点就是速度快，毕竟只需要在硬盘上读取。缺点是在这里备份的前提条件是/tmp目录下有足够的空间。如果没有，那就找块大容量的移动硬盘或者是优盘，把它挂载到/mnt目录上，再进入/mnt目录来备份整个系统。这样就涉及USB的传输速度什么的了，速度就差了一点点。2．tar还原系统tar还原就简单多了。将备份文件pi_20150718.tar.gz拷贝到/tmp下，执行命令：    tar zxvpf pi_20150718.tar.gz –C /好了，现在系统已经恢复到备份时一样了。 2.4.2　tar增量备份还原tar备份虽好，但是每次备份都得全系统备份未免太浪费空间了。别急，tar还有一个增量备份。除了第一次是备份整个系统外，以后每次备份都只备份比上次多出来的部分。这样就无所谓浪费空间了。1．tar增量备份系统tar的增量备份实际上就是利用了tar的-g参数。第一次还是先备份系统，或者说是基础备份，后面的增量备份都是以这个备份文件为基准的。执行命令：    cd /tmp    sudo tar –g snapshot -zcvpf pi.tar.gz / –exclude=/lost+found –exclude=/mnt –exclude=/sys –exclude=/proc –exclude=/media –exclude=/tmp 第二次就可以进行增量备份了。执行命令：    cd /tmp    sudo tar –g snapshot -zcvpf pi_incremental_1.tar.gz / –exclude=/lost+found –exclude=/mnt –exclude=/sys –exclude=/proc –exclude=/media –exclude=/tmp 第3次、第4次……同样处理。只要将incremental_后面的数字递增就可以了。通过ls –al命令查看递增备份文件的ctime。在还原系统时，甚至可以做到定点还原。注意在创建递增备份文件时，文件名必须是以基础备份文件名开头，后面紧跟着_incremental_，再后面跟着增量备份的次数。2．tar增量还原系统先查看几个增量备份文件的ctime。根据需要定点还原系统，如图2-41所示。 图2-41　备份系统图2-41是系统的增量备份文件。如果想将系统恢复到2015/08/07，图中只有orgin.tar.gz和orgin_incremental_1.tar.gz的ctime是2015/08/07的。那就执行命令：    sudo tar zxvf orgin.tar.gz –C /    sudo tar zxvf orgin_incremental_1.tar.gz –C /如果想恢复到2015/09/29，那就再将ctime为2015/09/29的压缩文件解压缩到根目录下就可以了。 2.4.3　dd备份还原用dd命令来备份还原系统，最简单的方法是硬盘对拷。这是最简单粗暴的备份还原方法了。如果用两个容量一样的硬盘对拷，可以拷贝出完全相同的2份系统。1．dd备份系统Ghost是Windows下备份系统的明星软件。它主要作用是将系统分区打包成*.gho文件备份。或者将*.gho文件还原到分区。dd命令的作用跟它很类似。至于dd命令，我们在安装系统到TF卡的时候已经用过了。既然它可以把一个*.img文件写入磁盘。当然也可以从磁盘备份文件到*.img文件。下面的例子是以Debian 7做操作平台。（1）登录系统先进入Linux的控制台，参考2.1.3小节，如图2-37所示，使用root用户登录。（2）确定备份位置将Raspberry的TF卡卸下来，装入读卡器中，插入到Linux主机的USB接口。使用ls –l /dev/sd*命令查看TF卡磁盘位置，如图2-42所示。    ls –l /dev/sd* 图2-42　查看TF卡（3）备份系统备份有两种方法：直接dd备份系统、dd压缩备份系统。直接dd备份系统。执行命令：    cd    dd if=/dev/sdb of=Raspberry_20150719.img第一条命令是进入root用户的家目录。第二条命令是将/dev/sdb磁盘写入到Raspberry_20150719.img文件中。第二条命令是不是很眼熟？没错，就是我们安装系统时的命令反过来用。但是这样备份有个弊端。就是sdb磁盘有多大，备份用的img文件就有多大。那安装的时候为什么1G+的img系统怎么安装到了大磁盘中的呢？还记得Raspberry的配置选项中有个扩展分区的选项吗？实际上在我们安装系统的时候，也只是用了1GB左右的空间，后来系统占满整块硬盘，是因为我们配置Raspberry时扩展了分区。dd备份系统与tar备份系统不一样，tar备份的时候可以选择哪些文件夹不备份，dd是不能选择的，它只能整体备份还原。dd压缩备份系统为了将整块磁盘备份到一个比较小的文件。我们用gzip将它压缩一下再备份，这样就好多了。执行命令：    dd if=/dev/sdb | gzip -9 &gt; Raspberry_20150719.img.gz2．dd还原系统针对两种备份形式，还原也分两种：dd直接还原系统、dd解压缩还原系统。dd直接还原系统，执行命令：    dd  if=Raspberry_20150719.img of=/dev/sdb跟安装是一模一样的。dd解压缩还原系统，执行命令：    gzip -c -d Raspberry_20150719.img.gz | dd of=/dev/sdb好了，现在再也不用担心我的系统了，开始放心大胆地折腾吧。第3章　Raspberry开发利器工欲善其事，必先利其器。操作系统安装完毕，这只是长征走完第一步。光有系统没有工具的配合，Raspberry能做的事非常有限。下面开始安装Linux工具软件，熟练地使用工具后才能进行其他的项目。Linux中的软件程序很多，但常用的就这么几种：bash、python、vim、nano、sed、awk、grep、find……它们大多都是命令行工具，学习起来可能稍稍困难，但学会了以后的工作就非常简单了。可以说，只要熟练地掌握了这几种工具，应用Linux就基本没什么问题了。介绍这个工具之前，得先学习另一个命令apt-get。只有熟悉了它，才能把程序软件安装到系统上，上章在更换更新源时已经使用过了。本章主要内容包括：掌握apt-get命令学会vim的基本操作学习bash简单学习Python脚本语言 3.1　apt-get在Linux中安装软件一般有两种方式：一种是源代码安装，这种方法的好处是能自行调整参数，特别适合自己的机器（gentoo就是所有的软件都会被重新编译安装，因此gentoo也是所有Linux发行版本中最适合自己机器的版本）。但编译起来比较复杂，而且以现在的机器配置来说似乎也没多大的必要。如果不是非得编译安装的软件，还是用简单的方法吧。另一种就是用包管理器来安装，比如Debian的apt-get和RedHat的yum（目前最新的包管理器是dnf）。这种安装方法简单方便，而且所有的打包软件都经过了发行版本官方的验证，可以保证安全。目前绝大部分的程序软件都可以用这种方法安装，适合初学者使用。 3.1.1　apt-get简介Advanced Package Tool，又名apt-get，是一款适用于UNIX和Linux系统的应用程序管理器。最初于1998年发布，用于检索应用程序并将其加载到Debian Linux系统。apt-get成名的原因之一在于其出色的解决软件依赖关系的能力。它通常使用.deb-formatted文件，但经过修改后可以使用apt-rpm处理红帽的Package Manager（RPM）文件。Apt-get在Linux社区得到广泛使用，成为用来管理桌面、笔记本和网络的重要工具。使用apt-get的主流Linux系统包括Debian和Ubuntu变异版本。大多数情况下，从命令行运行该工具。 3.1.2　apt命令用法想要了解某个命令很简单，使用man command就行了。下面来看一下man apt-get，如图3-1所示。 图3-1　man apt-getPackagename是软件包的名称，具体的命令如下：apt-get update：在修改/etc/apt/sources.list之后运行该命令。此外需要定期运行这一命令以确保您的软件包列表是最新的。apt-get install packagename：安装一个新软件包（参见下文的aptitude）。apt-get remove packagename：卸载一个已安装的软件包（保留配置文档）。apt-get remove --purge packagename：卸载一个已安装的软件包（删除配置文档）。apt-get autoremove packagename：删除包及其依赖的软件包。apt-get autoremove --purge packagname：删除包及其依赖的软件包+配置文件，比上面的要删除的彻底一点。dpkg --force-all --purge packagename：有些软件很难卸载，而且还阻止了别的软件的应用，就能够用这个，但是有点冒险。apt-get autoclean：apt会把已装或已卸的软件都备份在硬盘上，所以假如需要空间的话，能够用这个命令来删除已卸载掉的软件的备份。apt-get clean：这个命令会把安装的软件的备份也删除，但是不会影响软件的使用。apt-get upgrade：可以使用这个命令更新软件包，apt-get upgrade不仅可以从相同版本号的发布版中更新软件包，也可以从新版本号的发布版中更新软件包，尽管实现后一种更新的推荐命令为apt-get dist-upgrade。在运行apt-get upgrade命令时加上-u选项很有用（即apt-get -u upgrade）。这个选项让APT显示完整的可更新软件包列表。不加这个选项，就只能盲目地更新。APT会下载每个软件包的最新更新版本，然后以合理的次序安装它们。注意在运行该命令前应先运行apt-get update更新数据库，更新任何已安装的软件包。apt-get dist-upgrade：将系统升级到新版本。apt-cache search string：在软件包列表中搜索字符串。dpkg -l package-name-pattern列出任何和模式相匹配的软件包。假如不知道软件包的全名，可以使用*package-name-pattern*。aptitude：详细查看已安装或可用的软件包。和apt-get类似，aptitude能够通过命令行方式调用，但仅限于某些命令——最常见的有安装和卸载命令。由于aptitude比apt-get包含更多信息，它更适合用来进行安装和卸载。apt-cache showpkg pkgs：显示软件包信息。apt-cache dumpavail：打印可用软件包列表。apt-cache show pkgs：显示软件包记录，类似于dpkg –print-avail。apt-cache pkgnames：打印软件包列表中任何软件包的名称。dpkg -S file：这个文档属于已安装软件包。dpkg -L package：列出软件包中的任何文档。dpkg –l：列出所有已安装的软件包。apt-get autoclean：定期运行这个命令来清除那些已卸载的软件包的.deb文档。通过这种方式，能够释放大量的磁盘空间。假如需求十分迫切，可以使用apt-get clean以释放更多空间。这个命令会将已安装软件包裹的.deb文档一并删除。大多数情况下不会再用到这些.debs文档，因此假如我们为磁盘空间不足而感到焦头烂额，这个办法也许值得一试。apt-get命令使用方便，功能强大，是学习Linux中必须掌握的命令之一（和rh系列中的yum/dnf作用相同）。虽然现在已经有很多图形化的包管理工具，在我看来它们唯一的优点就是直观。如果熟悉了apt-get命令，相信你会做出正确的选择。注意几乎所有的非商业软件都是可以用apt-get安装的，即使不能用apt-get安装的商业软件，大部分也有deb安装包。 3.2　vimvim是Linux世界中最流行的几种文本编辑器之一，是Linux程序员的挚爱，据说很多Linux技术大牛编程时不用IDE只使用vim。在绝大多数发行版本中它都是默认安装的。很多场合它不仅仅作为文本编辑器，还被配置成一款优秀的IDE。如果说到Linux的明星软件，必定有vim的一席之地。 3.2.1　vim简介vim是一个类似于vi的文本编辑器，不过在vi的基础上增加了很多新的特性，是vi的加强版。vim普遍被推崇为类vi编辑器中最好的一个。vim的原意是visual interface，它是一个所见所得的编辑程序，也就是说可以立即看到操作结果。 3.2.2　安装配置vimRaspBian默认没有安装vim，只是安装了vi。下面先来安装vim。安装vim很简单，在2.3.1中建立了Raspberry无密码登录的Putty的快捷方式。右击该图标，Putty将以默认用户pi登录Raspberry。执行命令：    sudo apt-get  install vim执行效果如图3-2所示。 图3-2　安装vimRaspberry上有个默认的vi，把这个vi链接到vim上。毕竟现在大家所说的vi就是指vim。如图3-3所示，执行命令：    whereis vi    whereis vim    ls –l /usr/bin/vi    sudo rm /usr/bin/vi    sudo ln –s /usr/bin/vim /usr/bin/vi    ls –l /usr/bin/vi 图3-3　链接vim好了，vim安装完毕了。现在开始配置vim。vim有两个配置文件：一个是全局配置文件/etc/vim/vimrc（有的是/etc/vimrc）；另一个是个人配置文件，在家目录下的.vimrc文件。此时用pi用户登录，那么pi用户的vim个人配置文件就是/home/pi/.vimrc。这个文件是不可见的，Linux中文件名的第一个字符是“.”，那么这个文件有点类似于Windows中的隐藏文件。这两个配置文件的优先级是个人配置优先于系统配置。就是说，同一个配置选项，比如/etc/vim/vimrc中设置的是set nu，可显示行号。而/home/pi/.vimrc中设置的是set nonu，不显示行号。那么在pi用户使用vim的时候，就不会显示行号，以pi用户的配置文件为主。如果没有个人配置文件/home/pi/.vimrc，或者个人配置文件中没有的配置选项，当然是以系统配置为主。如果没有特殊需要，建议修改个人的配置文件比较好。vim的配置选项非常多，大概有几百项。以下只列出常用的几项，如表3-1所示。如果对此有兴趣可以百度一下。表3-1 vim的配置选项例子set nocompatible 关闭vi兼容模式 syntax on 自动语法高亮 colorscheme molokai 设定配色方案 set number 显示行号 set cursorline 突出显示当前行 set ruler 打开状态栏标尺 set shiftwidth=4 设定&gt;命令移动时的宽度为4 set softtabstop=4 使得按退格键时可以一次删掉4个空格 set tabstop=4 设定tab长度为4 set nobackup 覆盖文件时不备份 set autochdir 自动切换当前目录为当前文件所在的目录 filetype plugin indent on 开启插件 set backupcopy=yes 设置备份时的行为为覆盖 set ignorecase smartcase 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感 set nowrapscan 禁止在搜索到文件两端时重新搜索 set incsearch 输入搜索内容时就显示搜索结果 set hlsearch 搜索时高亮显示被找到的文本 set noerrorbells 关闭错误信息响铃 set novisualbell 关闭使用可视响铃代替呼叫 set t_vb= 置空错误铃声的终端代码 set showmatch 插入括号时，短暂地跳转到匹配的对应括号 set matchtime=2 短暂跳转到匹配括号的时间 set magic 设置魔术 set hidden 允许在有未保存的修改时切换缓冲区，此时的修改由vim负责保存 set guioptions-=T 隐藏工具栏 set guioptions-=m 隐藏菜单栏 set smartindent 开启新行时使用智能自动缩进 set backspace=indent,eol,start 不设定在插入状态无法用退格键和Delete键删除回车符 set cmdheight=1 设定命令行的行数为1 set laststatus=2 显示状态栏（默认值为1，无法显示状态栏） vim有丰富的插件，配合vim的插件功能，可以将vim改造成一个IDE（for python c/c++ perl ruby ……）。互联网上有详细的教程，按照教程慢慢试验，可配置出最适合自己的vimrc文件。注意vim的赫赫威名在Linux界可以自夸一句天下谁人不识君，即使放到Windows平台，它也不逊色于Windows自带的notepad（记事本）。 3.2.3　以vim做一个简单的python IDE既然说到了IDE，Linux下的IDE非常多，明星软件也不少。但不是来个IDE就能满足个人的需求的。为什么非得要人去适应已经固定的IDE呢？有了vim完全可以配合插件做一个最适合自己的IDE。下面就以vim做一个简单的python IDE。只添加最简单的功能，如需要扩展其他的功能，请参考资料，自行添加插件。（1）首先安装ctags和vim的插件taglist。ctags用于支持taglist，使用ctags可以在变量之间跳跃。执行命令：    sudo apt-get install ctags安装vim插件taglist，先安装vim-scripts，vim-scripts中带有vim-addon-manager，vim-addon-manager是vim的插件管理器之一，用来管理vim插件。通过vim-addon-manager安装taglist。    sudo apt-get install vim-scripts    vim-addons install taglist（2）好了，准备工作已经做好了，现在可以开始设置配置文件了。/etc/vimrc和~/.vimrc都可以，只有一个用户，设置哪个都行。如果系统有其他的用户建议还是设置~/.vimrc比较好。以下是/home/pi/.vimrc的代码：      1 "文件检测功能      2 filetype on      3 "允许加载文件类型插件      4 filetype plugin on      5 "不同的文件定义不同的缩进格式      6 filetype indent on      7      8 "设置颜色，这里有多种颜色可以配置      9 let colors_name = "darkblue"     10     11 syntax enable     12 syntax on     13     14 "打开行标     15 set nu     16     17 "tab长度4个空格     18 set tabstop=4     19     20 set softtabstop=4     21 set shiftwidth=4     22 set noexpandtab     23     24 "设置编码自动识别     25 set fileencodings=utf-8,gbk     26 set ambiwidth=double     27     28 "启动鼠标     29 "set mouse=a     30     31 "不同时显示多个文件的tag，只显示当前文件的     32 let Tlist_Show_One_File=1     33 "如果taglist窗口是最后一个窗口，则退出vim     34 let Tlist_Exit_OnlyWindow=1     35 "在启动vim后，自动打开taglist窗口     36 let Tlist_Auto_Open=1     37     38 "一键运行python     39 map &lt;F5&gt; :!python %（3）保存文件后，来看看效果如何。如图3-4所示，执行命令：    vi  ~/.vimrc 图3-4　vim IDE如果编辑的是一个python脚本，直接按F5键就会执行该脚本。当然，也可以将这种方法扩展到C、C++、bash……上。无穷的思路，无限的可能。只有想不到，没有做不到。这就是vim。注意花点时间再花点心思完全可以配置一个为自己量身定做的IDE。它也许不是最好的，但它一定是最合适的。 3.2.4　vim使用指南如果要详细地解说vim恐怕几本书都说不完，在这里只是简单解说一下vim的基本常用功能。vi有3个模式：插入模式、命令模式、低行模式。插入模式：在此模式下可以输入字符，按Esc键将回到命令模式。命令模式：可以移动光标、删除字符等。低行模式：保存文件、退出vi、设置vi、查找等功能（低行模式也可以看作是命令模式里的）。（1）打开文件、保存文件、关闭文件（vi命令模式下使用）    vi filename        //打开filename文件    :w                 //保存文件    :w vpser.net       //保存至vpser.net文件    :q                 //退出编辑器，如果文件已修改请使用下面的命令    :q!                //退出编辑器，且不保存    :wq                //退出编辑器，且保存文件（2）插入文本或行（vi命令模式下使用，执行下面命令后将进入插入模式，按Esc键可退出插入模式）    a            //在当前光标位置的右边添加文本    i            //在当前光标位置的左边添加文本    A            //在当前行的末尾位置添加文本    I            //在当前行的开始处添加文本（非空字符的行首）    O            //在当前行的上面新建一行    o            //在当前行的下面新建一行    R            //替换（覆盖）当前光标位置及后面的若干文本    J            //合并光标所在行及下一行为一行（依然在命令模式）（3）移动按键（vi命令模式下使用）使用上下左右方向键h向左、j向下、k向上、l向右。空格键向右、Backspace键向左、Enter键移动到下一行首、-键移动到上一行首。（4）删除、恢复字符或行（vi命令模式下使用）    x            //删除当前字符    nx           //删除从光标开始的n个字符    dd           //删除当前行    ndd          //向下删除当前行在内的n行    u            //撤销上一步操作    U            //撤销对当前行的所有操作（5）搜索（vi命令模式下使用）    /vpser       //向光标下搜索vpser字符串    ?vpser       //向光标上搜索vpser字符串    n            //向下搜索前一个搜素动作    N            //向上搜索前一个搜索动作（6）跳至指定行（vi命令模式下使用）    n+           //向下跳n行    n-           //向上跳n行    nG           //跳到行号为n的行    G            //跳至文件的底部（7）设置行号（vi命令模式下使用）    :set  nu        //显示行号    :set nonu       //取消显示行号（8）复制、粘贴（vi命令模式下使用）    yy           //将当前行复制到缓存区，也可以用"ayy 复制，"a 为缓冲区，a也可以替换为a~z的任意字母，可以完成多个复制任务。    nyy          //将当前行向下n行复制到缓冲区，也可以用"anyy 复制，"a 为缓冲区，a也可以替换为a~z的任意字母，可以完成多个复制任务。    yw           //复制从光标开始到词尾的字符。    nyw          //复制从光标开始的n个单词。    y^           //复制从光标到行首的内容。    y$           //复制从光标到行尾的内容。    p            //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用"ap 进行粘贴。    P            //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用"aP 进行粘贴。（9）替换（vi命令模式下使用）    :s/old/new          //用new替换行中首次出现的old    :s/old/new/g        //用new替换行中所有的old    :n,m s/old/new/g    //用new替换从n~m行里所有的old    :%s/old/new/g       //用new替换当前文件里所有的old（10）编辑其他文件    :e otherfilename    //编辑文件名为otherfilename的文件。（11）修改文件格式    :set fileformat=unix        //将文件修改为unix格式，如win下面的文本文件在Linux下会出现^M好了，vim就介绍到这里。vim是个非常有用的文本编辑器，掌握vim是学习Linux的重要一环。注意vim用于局部的搜索、替换、复制、粘贴，非常方便，这是在编写代码时的常用功能。在这方面其他文本编辑器难以比拟。 3.3　bash使用Putty登录Raspberry。登录Raspberry后使用的就是bash。使用其他的Linux PC，开机后登录桌面，桌面也是作用于bash上的。本章将要介绍的就是bash。 3.3.1　bash简介Shell是使用者和Linux内核的中间层。使用者通过Shell与内核（kernel）来沟通，让kernel可以控制硬件工作。Windows、Linux、Mac OS都有shell。Shell的本意是外壳，是包裹内核的壳子的意思。Shell的版本有很多，常见的有GNU bash、C shell、K shell。而常说的Linux bash大多数都是指GNU Bash（GNU Bourne-Again Shell），它是Bourne Shell的增强版本。Bash是一门解释型语言，就是说它的程序不是通过编译后执行的，它是边解释边执行。这种解释型语言的缺点是执行效率比较低，但兼容性比较好。Bash功能强大，虽然不能与python、perl、ruby相比，但尺有所短寸有所长，它胜在简单方便，基本常用问题都可以用bash来解决，所以经久不衰。Bash是GNU计划中重要的工具软件之一，目前也是Linux distributions的标准shell。Bash的优点主要有以下几点。1．命令回溯（history）用户登录系统后可以查看 ~/.bash_history文件来查询上次登录时使用过的命令，也可以利用history [number]命令来查看本次登录使用的命令。例如查看最近执行的10个命令，执行命令：    history 102．命令与文件补全（Tab键补全）Tab键在Linux中是个非常方便的按键。如果有个命令，只记得是以ar开头，不记得全名是什么。不要着急，按几下Tab键，它会把所有以ar开头的命令都显示出来，如图3-5所示。 图3-5　bash命令补全演示1如果想用vim编辑当前目录下以g开头的文件，也很简单，执行命令vi Tree。然后再按几下Tab键，它会列出当前目录下所有以g开头的文件，如图3-6所示。 图3-6　bash命令补全演示23．命令别名（alias）想用vi命令来调用vim，除了把vi命令链接到vim上还有没有其他的方法呢？当然有，这里可以使用命令别名。执行命令：    Alias'vi=vim'有点类似于给命令起个“绰号”，实际上还是同一个命令。但是显然“绰号”更容易记忆。在Linux中alias不光是起个“绰号”的作用，它还可以用于命令合成。例如：我们通常使用ls命令查看文件。但如果想详细查看某个文件，就得使用“ls–l”命令了。这里我们可以合成一个命令ll。展示效果如图3-7所示，执行命令：    alias ll='ls –l' 图3-7　alias演示1如果不喜欢E文的日期显示方式，也可以利用alias将合成的ll命令改成显示中文日期，再来测试一下，如图3-8所示，执行命令：    alias ll='ls --color=auto -l --time-style="+%Y/%m/%d %H:%M:%S"' 图3-8　alias演示24．工作前台后台控制（jobs、fg、bg）在bash中执行的任务可以分为前台、后台的。前台的任务是可见的，后台的任务是隐藏的。使用jobs命令，可以看到后台的任务及编号。然后使用fg number命令，将任务调到前台来执行。也可以将当前执行的前台任务按Ctrl + Z组合键后暂停，再使用bg number命令，将任务调到后台执行。前台任务演示，如图3-9所示。 图3-9　前台任务按Ctrl + Z组合键将未完成的前台任务暂停，如图3-10所示。 图3-10　暂停任务使用bg命令将暂停的任务放入后台执行，如图3-11所示。 图3-11　后台任务使用fg命令将暂停的任务放到前台来执行，如图3-12所示。 图3-12　后台任务调入前台5．通配符（wildcard）&amp;特殊符号在bash的操作环境中还有一个非常有用的功能，那就是通配符（wildcard）。我们利用bash处理数据就更方便了。下面列出一些常用的通配符：*：代表“0个到无穷多个”任意字符。?：代表“一定有一个”任意字符。[]：同样代表一定有一个在括号内的字符（非任意字符）。例如[abcd]代表一定有一个字符，可能是a、b、c、d这4个中的任何一个。[-]：若有减号在中括号内，代表“在编码顺序内的所有字符”。例如[0-9]代表0~9的所有数字，因为数字的语系编码是连续的。^：若中括号内的第一个字符为指数符号（^），表示“反向选择”，例如[^abc]代表一定有一个字符，只要是非a、b、c的其他字符就接受的意思。以下列出bash环境中的特殊符号：#：注释符号，最常使用在script中，视为说明，在后的数据均不运行。\：转义符号，将特殊字符或通配符还原成一般字符。|：管道（pipe），分隔两个管道命令的界定。;：连续命令分隔符，连续性命令的界定（注意，与管道命令并不相同）。~：用户的家目录。$：取用变量前导符，变量之前需要加的变量取代值。&amp;：工作控制（job control），将命令变成后台下工作。!：逻辑运算中的逻辑非，not的意思。/：目录符号，路径分隔的符号'。&gt;，&gt;&gt;：数据流重定向，输出重定向。&lt;，&lt;&lt;：数据流重定向，输入重定向。’：单引号，不具有变量置换的功能。”：具有变量置换的功能。``：两个“`”中间为可以先运行的命令。()：在中间为子shell的起始与结束。{}：在中间为命令区块的组合。创建文件时，尽量不要使用以上的字符做文件名。6．bash script有时完成一些简单的任务，使用python、perl未免有杀鸡用牛刀的感觉，但一些重复性的工作，一条命令一条命令地敲实在是很痛苦的事情，所以还是用bash script吧。bash script实际就是将一条条的bash命令组合起来，然后再一起执行。 3.3.2　第一个bash脚本Hello world几乎所有的编程语言都是以hello world开始的，尊重传统。下面就开始第一个bash脚本hello.sh。1．创建工作平台通过Putty登录Raspberry后，首先创建一个工作目录，执行命令：    mkdir –pv ~/code/bash    cd ~/code/bash第一条命令是在用户家目录下建立工作目录~/code/bash，第二条命令是进入该目录。因为是以默认用户pi登录。所以，建立的目录位置是/home/pi/code/bash/2．使用vim创建hello.shLinux不像Windows那样需要靠后缀名来确定打开文件的程序，所以bash script的后缀名叫什么都可以，只要符合文件名的规则就行。但一般都是把bash script的后缀名设定为sh。以便确认该文件的编译语言。执行命令：    vi hello.sh以下是hello.sh的代码：    1 #!/bin/bash    2    3 echo "Hello world!"    4 printf "This is my first bash script!\n"注意前面的1、2、3、4是vim自动标出的行号，不是代码内容，如果不需要行号，可以按Esc键后，输入：set nonu来取消行号。执行命令sh hello.sh，如图3-13所示。 图3-13　执行脚本这里要说明的是第一行，#!/bin/bash是指明解释器的位置。其中，#!是一个特殊的表示符，其后，跟着解释此脚本的shell路径。也就是说，如果想用ksh、tsh来解释脚本。那么第一行就应该是#!/bin/ksh或者#!/bin/tsh。后面的echo和printf都是打印输出命令。篇幅有限，如果对具体语法有兴趣，请自行参考谷歌百度。再来看一下sh这个命令，在Ubuntu和Debian中sh默认指向的不是/bin/bash，而是/bin/dash。Dash比bash速度更快，语法严格遵守POSIX标准，但功能比bash少很多。一般读者学习的都是bash，写的script脚本也是以bash写的。为了防止一些莫名其妙的错误，解决方法有2个。执行命令的时候直接用bash命令。比如上例中的hello.sh文件，如果将它赋予执行权限，直接运行命令./hello.sh来执行是没问题的。如果非要带上执行的命令，那就运行命令bash hello.sh。将sh的链接指向bash。把sh指向bash，一劳永逸地解决问题。推荐使用这个方法。至于dash简洁方便的优点，以现在计算机的性能来说，实在是不算什么。SO，运行命令：    sudo rm /bin/sh    sudo ln –s /bin/bash /bin/sh注意在一般情况下dash和bash是可以互换使用的，写srcipt时则不行。例如for语句，dash和bash就完全不一样。所以没什么特别缘由还是换成bash吧。 3.3.3　bash script实例——增量备份脚本在上文2.4.2中学习过增量备份系统。但每次都输入命令太麻烦了，而且这还是个重复性的工作，可以交给shell去完成。下面就写一个增量备份的bash脚本backSYS.sh。代码如下：      1 #!/bin/bash      2      3 ### set user variable &lt;&lt;&lt;      4 ### 备份目录，这里设置的是/mnt/disk目录下备份，要先将一块磁盘挂载到/mnt/disk下      5 backDir="/mnt/disk/backup/raspberry/"      6 ### 备份文件名        7 firstName="origin"      8 ### 后缀名           9 endName=".tar.gz"     10 ### 增量名          11 secName="_incremental_"     12 ### 不备份的文件夹       13 notBack=" -–exclude=/proc -–exclude=/lost+found -–exclude=/mnt -–exclude=/sys --exclude=/tmp"     14 ### user variable over &gt;&gt;&gt;     15     16 function createOrigin()     17 {     18     rm ${firstName}${secName}*${endName}     19     rm snapshot     20     echo -e "开始创建初始基准备份文件 \t"$firstName$endName     21     time tar -g snapshot -zcpvf `echo ${firstName}${endName}` / --exclude=/proc --exclude=/lost+found --exclude=/mnt --exclude=/sys --exclude=/tmp     22     echo $?     23     echo -e "初始基准备份文件创建完毕 \t"$firstName$endName     24 }     25     26 function createInc()     27 {     28     echo "开始创建增量备份文件"     29     for i in {1..100};     30     do     31         incName=${firstName}${secName}"${i}"${endName};     32         if [ -f ${incName} ];     33         then     34             echo "${incName} 已存在"     35             continue     36         else     37             echo "创建增量备份文件 ${incName}"     38             time tar -g snapshot -zcpvf `echo ${incName}` /  --exclude=/proc --exclude=/lost+found --exclude=/mnt --exclude=/sys --exclude=/tmp     39             echo $?     40             echo -e "增量备份文件创建完毕\t"${incName}     41             break     42         fi     43     done     44 }     45     46 if [ -d ${backDir} ];     47 then     48     echo -e ${backDir}"\t备份目录已创建"     49 else     50     mkdir -pv ${backDir}     51 fi     52     53 cd ${backDir}     54     55 if [ -f ${firstName}${endName} ];     56 then     57     echo -e ${firstName}${endName}"\t初始基准备份文件已创建"     58     ls -al ${firstName}${endName}     59     createInc     60 else     61     createOrigin     62 fi好了，以后如果想备份系统，就直接运行命令：    sudo sh backSYS.sh它将自动地增量备份系统。如果想添加其他的功能，可以自行添加。经过不断地修正改进，说不定它会成为下一个Ghost for Linux。注意系统的备份是非常有必要的。强烈建议至少在系统安装完成后备份一次，配置完成后再备份一次。 3.4　PythonPython和Perl是目前最流行的脚本语言，它们各有拥趸。比较而言，python更加简单。目前python在国内更加流行，使用者也更多，本章将介绍python语言。 3.4.1　Python简介Python是种解释型语言。也就是说python script是无须编译的。与bash不同的是它功能强大，借助于丰富的标准库和第三方模块，它在功能上毫不逊色于C、C++、Java……老牌编程语言。Python由Guido van Rossum于1989年底发明，第一个公开发行版发行于1991年。Python源代码同样遵循GPL（GNU General Public License）协议。Python语法简洁而清晰，具有丰富和强大的类库。它常被昵称为胶水语言（glue language），能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写。目前Python的主流版本是Python 2.7和Python 3.4。个人感觉Python 2.7编程风格偏向于C面向程序编程。而Python 3.4则偏向于C++面向对象编程。当然，也可以把Python 2.7写成C++风格，把Python 3.4写成C风格，只要语法没错误，随便怎么写都可以。Python 3.4是目前最新的版本，但Python 3.4的中文参考资料还不多。使用者比较少，一般都是使用的Python 2.7。下文中，如果没有特殊说明，所指的Python都是Python 2.7。Python开发总的指导思想是，对于一个特定的问题，只要有一种最好的方法来解决就好了。这在由Tim Peters写的Python格言（称为The Zen of Python）里面表述为：There should be one-- and preferably only one --obvious way to do it。这正好和Perl语言（另一种功能类似的高级动态语言）的中心思想TMTOWTDI（There's More Than One Way To Do It）完全相反。Python的作者有意地设计限制性很强的语法，使得不好的编程习惯（例如if语句的下一行不向右缩进）都不能通过编译。其中很重要的一项就是Python的缩进规则。一个和其他大多数语言（如C）的区别就是，一个模块的界限，完全是由每行的首字符在这一行的位置来决定的（而C语言是用一对花括号{}来明确地定出模块的边界的，与字符的位置毫无关系）。不可否认的是，通过强制程序员们缩进（包括if、for和函数定义等所有需要使用模块的地方），Python确实使得程序更加清晰和美观。Python本身被设计为可扩充的。并非所有的特性和功能都集成到语言核心。Python提供了丰富的API和工具，以便程序员能够轻松地使用C语言、C++、Cython来编写扩充模块。Python编译器本身也可以被集成到其他需要脚本语言的程序内。因此，很多人还把Python作为一种“胶水语言”使用。使用Python将其他语言编写的程序进行集成和封装。在Google内部的很多项目，例如Google Engine使用C++编写性能要求极高的部分，然后用Python或Java/Go调用相应的模块。 3.4.2　第一个Python脚本Hello world还是尊重传统，写第一个Python script，hello.py。Python script的后缀名一般都是.py。至于原因，前文已经说明不再赘述。1．创建工作目录通过Putty登录Raspberry后，首先创建一个工作目录，执行命令：    mkdir –pv ~/code/python/hello    cd ~/code/python/hello2．使用vim创建hello.py使用vim编辑hello.py，执行命令：    vi hello.py以下是hello.py的代码：      1 #!/usr/bin/env python      2 # -*- coding:utf-8 -*-      3 #Author  :hstking      4 #E-mail  :hstking@hotmail.com      5 #Ctime   :2015/08/05      6 #Mtime   :      7 #Version :      8      9     10 def main():     11     print "Hello world\n"     12     13     14 if __name__ == '__main__':     15    main()只有15行，看起来很简单是不是？还是来解释一下。每行前面的数字行标就不解释了。第一行的#!特殊标示符前文3.3.2中也解释过了。还记得bash script吗？#!后面跟的是解释器的位置，这里也是一样的。只是bash的位置总是在/bin/bash里，而Python却不一样。而且，有时需要用Python 3来解释脚本，有时需要用Python 2.7来解释脚本。所以直接使用/usr/bin/env命令，让它自己在环境变量中去寻找用哪个Python来解释。至于这个Python是指的哪个脚本呢？如图3-14所示。 图3-14　Python位置脚本中第2行指定了字符编码。如果没什么特别要求，一般都是指定utf-8。第3行是作者信息。第4行是mail。第5行是创建时间。第6行是最后修改时间。第7行是版本号。第10行定义main函数。第11行是main函数体。第14行是在测试该文件时，当成脚本执行还是当成第三方模块调用。第15行调用main函数。只是打印一个简单的Hello world！居然用了15行。需要这么复杂吗？当然不用，实际上只需要3行就可以达到同样的效果。其他多余的行都是注释，是通过一个简单的python脚本touch2py.py自动创建的。下文再来详细讲解touch2py.py。这里还是先看下最简版本的Hello world脚本h0.py。以下是h0.py的代码：      1 #!/usr/bin/env python      2      3 print "Hello world!\n"加上空行，只需要3行就够了。3．执行结果比较这两个脚本的执行结果，结果如图3-15所示，执行命令：    python hello.py    python h0.py 图3-15　hello.py&amp;h0.py结果完全一样。至于有没有必要加那么多的注释。就是仁者见仁，智者见智了。我的看法是，“不管你觉得需不需要，反正我需要”。注意写代码添加注释，这是一个良好的习惯。如果不想以后绞尽脑汁的回忆这个函数起什么作用，那个变量代表什么。还是留下注释吧。 3.4.3　Python常用模块Python的标准库不多，但加上第三方模块那就多得可怕了。同一种功能可能有多个不同的模块，足够满足生产中的各种问题。如果觉得还不够，也可以自己编写模块加入其中。一般来说下面的模块已经足够使用了。没必要重复地造轮子。1．Python运行时服务copy：copy模块提供了对复合（compound）对象（list，tuple，dict，custom class）进行浅拷贝和深拷贝的功能。pickle：pickle模块被用来序列化python的对象到bytes流，从而适合存储到文件、网络传输或数据库存储。（pickle的过程也称为serializing、marshalling或者flattening，pickle同时可以用来将bytes流反序列化为python的对象）。sys：sys模块包含了与python解析器和环境相关的变量和函数。其他：atexit、gc、inspect、marshal、traceback、types、warnings、weakref。2．数学decimal：python中的float是使用双精度的二进制浮点编码来表示的，这种编码导致了小数不能被精确地表示，例如0.1实际上内存中为0.100000000000000001，还有3*0.1 == 0.3为False。decimal就是为了解决类似的问题的，拥有更高的精确度，能表示更大范围的数字，更精确地四舍五入。math：math模块定义标准的数学方法，例如cos（x）、sin（x）等。random：random模块提供各种方法用来产生随机数。其他：fractions，numbers。3．数据结构、算法和代码简化array：array代表数组，类似于list，与list不同的是只能存储相同类型的对象。bisect：bisect是一个有序的list，其中内部使用二分法（bitsection）来实现大部分操作。collections：collections模块包含了一些有用的容器的高性能实现，各种容器的抽象基类和创建name-tuple对象的函数。例如包含了容器deque、defaultdict、namedtuple等。heapq：heapq是一个使用heap实现的带有优先级的queue。itertools：itertools包含的函数用来创建有效的iterators。所有的函数都返回iterators，或者函数包含iterators（例如generators和generators expression）。operator：operator提供了访问python内置的操作和解析器提供的特殊方法，例如x+y为add（x，y），x+=y为iadd（x，y），a%b为mod（a，b）等等。其他：abc、contextlib、functools。4．string和text处理codecs：codecs模块用来处理不同的字符编码与unicode text io的转化。re：re模块用来对字符串进行正则表达式的匹配和替换。string：string模块包含大量有用的常量和函数用来处理字符串，也包含新字符串格式的类。struct：struct模块用来在python和二进制结构间实现转化。unicodedata：unicodedata模块提供访问unicode字符数据库。5．Python数据库访问关系型数据库拥有共同的规范Python Database API Specification V2.0，MySQL、Oracle等都实现了此规范，然后增加自己的扩展。sqlite3：sqlite3模块提供SQLite数据库访问的接口。SQLite数据库是以一个文件或内存的形式存在的自包含的关系型数据库。DBM-style数据库模块：Python提供大量的modules来支持UNIX DBM-style数据库文件。dbm模块用来读取标准的UNIX-dbm数据库文件，gdbm用来读取GNU dbm数据库文件，dbhash用来读取Berkeley DB数据库文件。所有这些模块提供了一个对象实现基于字符串的持久化的字典，它与字典dict非常相似，但是它的keys和values都必须是字符串。shelve：shelve模块使用特殊的shelf对象来支持持久化对象。这个对象的行为与dict相似，但是所有的其他存储的对象都使用基于hashtable的数据库（dbhash、dbm、gdbm）存储在硬盘。与dbm模块的区别是所存储的对象不仅是字符串，而且可以是任意的与pickle兼容的对象。6．文件和目录处理bz2：bz2模块用来处理以bzip2压缩算法压缩的文件。filecmp：filecmp模块提供函数来比较文件和目录。fnmatch：fnmatch模块提供使用UNIX shell-style的通配符来匹配文件名。这个模块只是用来匹配，使用glob可以获得匹配的文件列表。glob：glob模块返回某个目录下与指定的UNIX shell通配符匹配的所有文件。gzip：gzip模块提供类GzipFile，用来执行与GNUgzip程序兼容的文件的读写。shutil：shutil模块用来执行更高级别的文件操作，例如复制、删除、改名。shutil操作针对一般的文件，不支持pipes、block devices等文件类型。tarfile：tarfile模块用来维护tar存档文件。tar没有压缩的功能。tempfile：tempfile模块用来产生临时文件和文件名。zipfile：zipfile模块用来处理zip格式的文件。zlib：zlib模块提供对zlib库的压缩功能的访问。7．操作系统的服务cmmands：commands模块被用来执行简单的系统命令，命令以字符串的形式传入，且同时以字符串的形式返回命令的输出。但是此模块只在UNIX系统上可用。configParser：configParser模块用来读写Windows的ini格式的配置文件。datetime：datetime模块提供了各种类型来表示和处理日期和时间。errno：定义所有的errorcode对应的符号名字。io：io模块实现各种IO形式和内置的open()函数。logging：logging模块灵活方便地对应用程序记录events、errors、warnings和debuging信息。这些log信息可以被收集、过滤，写到文件或系统log，甚至通过网络发送到远程的机器上。mmap：mmap模块提供内存映射文件对象的支持，使用内存映射文件与使用一般的文件或byte字符串相似。msvcrt：mscrt只可以在Windows系统使用，用来访问Visual C运行时库的很多有用的功能。optparse：optparse模块提供更高级别来处理UNIX style的命令行选项sys.argv。os：os模块对通用的操作系统服务提供可移植（portable）的接口。os可以认为是nt和posix的抽象。nt提供Windows的服务接口，posix提供UNIX（Linux，mac）的服务接口。os.path：os.path模块以可移植的方式来处理路径相关的操作。signal：signal模块用来实现信号（signal）处理，往往跟同步有关。subprocess：subprocess模块包含函数和对象来统一创建新进程，控制新进程的输入输出流，处理进程的返回。time：time模块提供各种时间相关的函数。常用的是time.sleep().winreg：winreg模块用来操作Windows注册表。其他：fcntl。8．线程和并行multiprocessing：multiprocessing模块提供通过subprocess来加载多个任务，通信、共享数据，执行各种同步操作。threading：threading模块提供了thread类的很多同步方法来实现多线程编程。queue：queue模块实现各种多生产者、多消费者队列，用来实现多线程程序的信息安全交换。其他：Coroutines and Microthreading。9．网络编程和套接字（sockets）asynchat：asynchat模块通过封装asyncore来简化应用程序的网络异步处理。ssl：ssl模块用来使用secure sockets layer（SSL）包装socket对象，从而实现数据加密和终端认证。python使用openssl来实现此模块。socketserver：socketserver模块提供类型简化了TCP、UDP和UNIX领域的socket server的实现。其他：asyncore，select。10．internet应用程序编程ftplib：ftplib模块实现ftp的client端协议。此模块很少使用，因为urllib提供了更高级的接口。httplib：httplib包含http client和server的实现和cookies管理的模块。smtplib：smtplib包含smtp client的底层接口，用来使用smtp协议发送邮件。urllib：urllib包提供高级的接口来实现与http server、ftp server和本地文件交互的client。xmlrpc：xmlrpc模块被用类实现XML-RPC client。11．Web编程cgi：cgi模块用来实现cgi脚本，cgi程序一般被webserver执行，用来处理用户在form中的输入，或生成一些动态的内容。当与cgi脚本有关的request被提交，webserver将cgi作为子进程执行，cgi程序通过sys.stdin或环境变量来获得输入，通过sys.stdout来输出。webbrowser：webbrowser模块提供平台独立的工具函数来使用web browser打开文档。其他：wsgiref/WSGI（Python Web Server Gateway Interface）。12．internet数据处理和编码base64：base64模块提供base64、base32、base16编码方式，用来实现二进制与文本间的编码和解码。base64通常用来对编码二进制数据，从而嵌入到邮件或http协议中。binascii：binascii模块提供低级的接口来实现二进制和各种ASCII编码的转化。csv：csv模块用来读写comma-separated values（CSV）文件。email：email包提供大量的函数和对象来使用MIME标准表示、解析和维护email消息。hashlib：hashlib模块实现各种secure hash和message digest algorithms，例如MD5和SHA1。json：json模块用于类序列化或反序列化Javascript object notation（JSON）对象。xml：xml包提供各种处理xml的方法。这么多的模块，一般来说是足够满足需要的了。如果不够，百度一下吧，还有很多第三方模块没有列入其中。如果还不够，那就只有自行建立合适的模块了。浏览器打开https://docs.python.org/2.7/py-modindex.html，这是Python 2.7的官方标准库的列表，显示了所有官方模块的详细信息。注意如果不是要满足特别奇怪的要求就不需要自行建轮子了。网络上有大把的先行者写的优秀模块，直接拿来借用就可以了。只要善用谷歌百度就行。 3.4.4　Python script实例——touch2py.py创建一个Python脚本，有时要加入一些脚本信息。这些脚本信息基本都是一样的。每次重复性输入是件很痛苦的事情。幸好Python可以解决这个问题。上文已经简单介绍了一些Python模块。现在就通过这些模块来创建一个简单的Python脚本touch2py.py。执行命令：    mkdir –pv ~/code/python/touch2py    cd ~/code/python/touch2py    vi touch2py.py以下是tuoch2py.py的代码：      1 #!/usr/bin/env python      2 # -*- coding:utf-8 -*-      3      4 import sys      5 import os      6 import time      7      8 def creatFile（name）:      9     f = open（name,'w'）     10     for head in pyHead:     11         f.write（head）     12         f.write（'\n'）     13     f.write（'\n'）     14     f.close()     15     16     17     18 if __name__ == '__main__':     19     global pyHead     20     pyHead = [     21 '#!/usr/bin/env python',     22 '# -*- coding:utf-8 -*-',     23 '#Author  :hstking',     24 '#E-mail  :hstking@hotmail.com',     25 '#Ctime   :' + time.strftime（"%Y/%m/%d"）,     26 '#Mtime   :',     27 '#Version :',     28 '\n\n\n\n',     29 "if __name__ == '__main__':"     30 ]     31     32     if len（sys.argv） == 1:     33         print '请输入文件名\n'     34     35     fileNames = sys.argv[1:]     36     for name in fileNames:     37         if （os.path.isfile（name） or os.path.isdir（name） or os.path.islink（name））:     38             print name,"已经存在"     39         else:     40             creatFile（name）最后讲一下第4、5、6行的导入模块。Python导入模块有两种方式。比如该脚本中的time.strftime函数的导入。如下所示：import time：这种导入是将整个time模块一起导入到脚本中，导入后想使用time.strftime函数，就得带入模块名。就如touch2py.py中的使用方法time.strftime()。from time import strftime：这种导入只导入了模块中的某个函数。导入后想使用time.strftime函数，就直接用函数名就可以了，如strftime()。实际上还有一种导入模块的方法：内建函数__import__()，只是这种写法比较少。就不多做说明了。好了，touch2py.py已经完成了。再来完善一下，把它写进PATH，以后就可以直接将touch2py.py当命令执行了。执行命令：    sudo ln –s /home/pi/code/python/touch2py/touch2py.py /usr/local/bin/touch2py将touch2py.py做了一个链接。以后直接使用命令touch2py就可以调用touch2py.py脚本了。还原刚才的hello.py，这个脚本是怎么建立的呢？执行命令：    touch2py hello.py    vi hello.py此时hello.py的代码如下：      1 #!/usr/bin/env python      2 # -*- coding:utf-8 -*-      3 #Author  :hstking      4 #E-mail  :hstking@hotmail.com      5 #Ctime   :2015/08/05      6 #Mtime   :      7 #Version :      8      9     10     11     12 if __name__ == '__main__':好了，相应的位置再插入3行，就和3.4.2中的hello.py一模一样了。这样是不是简单了很多呢？在实际生产中，只要是重复性的工作，都可以想办法让Python去完成。它就擅长干这个。一劳永逸，何乐而不为。注意嵌入时间、个人信息是为了便于交流。还可以添加更多的信息，自行发挥吧。 3.4.5　Python进阶实例——getNip.py本节的目的是通过Python取得自己的Nip。也就是本机的网络ip地址。最常用的取Nip的方法是什么呢？我都是直接在百度中输入IP，然后单击“百度一下”，直接看第一个结果就可以了。用Python怎么取得这个结果呢？就和刚才的查询过程一样，无非就是用python去取，无须自己动手而已。1．创建工作台    cd    mkdir –pv code/python/getNip    cd $_    touch2py getNip.py    vi getNip.py2．编写代码可以开始编写代码了。getNip.py的代码如下：      1 #!/usr/bin/env python      2 # -*- coding:utf-8 -*-      3 #Author  :hstking      4 #E-mail  :hstking@hotmail.com      5 #Ctime   :2015/08/27      6 #Mtime   :      7 #Version :      8      9 import urllib2     10 import re     11 import os     12     13     14 ####  定义GetNip类     15 class GetNip():     16 ####  定义构造函数，可以用于定义类变量     17     def __init__（self）:     18         self.logPath = os.path.expanduser（'~'） + os.sep + 'log'     19         self.nipFile = self.logPath + os.sep + 'Nip.txt'     20         self.Nip = None     21     22         self.getNip()     23         self.writeNip()     24     25 ####  从网络取得本地的公网IP     26     def getNip（self）:     27         urls = 'http://1111.ip138.com/ic.asp'     28         if urllib2.urlopen（urls）.geturl() == urls:     29             rawString = urllib2.urlopen（urls）.read()     30             self.Nip = re.search（b'\d+\.\d+\.\d+\.\d+',rawString）.group()     31             print（"Nip = %s"%self.Nip）     32         else:     33             print（"未取得本机NIP"）     34     35 ####  将取得的公网IP写入指定文件中     36     def writeNip（self）:     37         if os.path.isdir（self.logPath）:     38             pass     39         else:     40             os.makedirs（self.logPath）     41         with open（self.nipFile,'w'） as FP:     42             FP.write（self.Nip）     43     44     45 ####  以下是脚本的主程序     46 if __name__ == '__main__':     47     nip = GetNip()3．运行结果运行脚本，验证执行结果。结果如图3-16所示，执行命令：    python getNip.py 图3-16　getNip.py演示基本达到了设计结果。初学者在写Python script时，首要是做到满足设计需求，然后再来精简代码，简化过程。注意这个script只是满足了最基本的设计需求，还有改进空间。个人觉得对一些小的功能，一个功能就写成一个script，使用时再一次性调用。非常方便。 3.5　常用工具Python的确无所不能，可寸有所长，尺有所短，有些时候还有一些特定的工具更加方便。毕竟Python追求的是广而博，而特定的工具追求的是专而精。 3.5.1　正则表达式（RE）在介绍这些工具之前不得不先说说正则表达式了。不只是下面的几个工具支持正则。在Linux中很多地方都与正则息息相关。正则表达式，又称正规表示法、常规表示法（Regular Expression，在代码中常简写为regex、regexp或RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。不管是在Windows还是Linux中都是有正则表达式的。而且两者还比较相近，但没能统一实在是令人遗憾。正则表达式由一些普通字符和一些元字符（metacharacters）组成。普通字符包括大小写的字母和数字，而元字符则具有特殊的含义。以下列出了所有元字符及描述。\：将下一个字符标记为一个特殊字符或一个原义字符或一个向后引用或一个八进制转义符。例如，“\\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\（”则匹配“（”。即相当于多种编程语言中都有的“转义字符”的概念。^：匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。$：匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。*：匹配前面的子表达式任意次。例如，zo*能匹配“z”、“zo”以及“zoo”。*等价于{0,}。+：匹配前面的子表达式一次或多次（大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。?：匹配前面的子表达式零次或一次。例如，“do（es）?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。{n}：n是一个非负整数，匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。{n,}：n是一个非负整数，至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”，“o{0,}”则等价于“o*”。{n,m}：m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前3个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。?：当该字符紧跟在任何一个其他限制符（*、+、?、{n}、{n,}、{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少地匹配所搜索的字符串，而默认的贪婪模式则尽可能多地匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。.：匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。（pattern）：匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\（”或“\）”。（?:pattern）：匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用“或”字符（|）来组合一个模式的各个部分时很有用。例如“industr（?:y|ies）”就是一个比“industry|industries”更简略的表达式。（?=pattern）：正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows（?=95|98|NT|2000）”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。（?!pattern）：正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows（?!95|98|NT|2000）”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。（?&lt;+pattern）：反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“（?&lt;=95|98|NT|2000）Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。（?&lt;!pattern）：反向否定预查，与正向否定预查类似，只是方向相反。例如“（?&lt;!95|98|NT|2000）Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。X|y：匹配x或y。例如，“z|food”能匹配“z”或“food”或“zood”（此处请谨慎）。“（z|f）ood”则匹配“zood”或“food”。[xyz]：字符集合。匹配所包含的任意一个字符。例如，[abc]可以匹配“plain”中的“a”。[^xyz]：负值字符集合。匹配未包含的任意字符。例如，[^abc]可以匹配“plain”中的“plin”。[a-z]：字符范围。匹配指定范围内的任意字符。例如，[a-z]可以匹配“a”到“z”范围内的任意小写字母字符。注意：只有连字符在字符组内部时，并且出现在两个字符之间时，才能表示字符的范围；如果出现在字符组的开头，则只能表示连字符本身。[^a-z]：负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。\b：匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。\B：匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。\cx：匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。\d：匹配一个数字字符。等价于[0-9]。\D：匹配一个非数字字符。等价于[^0-9]。\f：匹配一个换页符。等价于\x0c和\cL。\n：匹配一个换行符。等价于\x0a和\cJ。\s：匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。\S：匹配任何可见字符。等价于[^ \f\n\r\t\v]。\t：匹配一个制表符。等价于\x09和\cI。\v：匹配一个垂直制表符。等价于\x0b和\cK。\w：匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的“单词”字符使用Unicode字符集。\W：匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。\xn：匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。\num：匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“（.）\1”匹配两个连续的相同字符。\n：标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。\nm：标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。\nml：如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。\un：匹配n，其中n是一个用4个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&amp;copy;）。\&lt;\&gt;：匹配词（word）的开始（\&lt;）和结束（\&gt;）。例如正则表达式\&lt;the\&gt;能够匹配字符串"for the wise"中的"the"，但是不能匹配字符串"otherwise"中的"the"。注意：这个元字符不是所有的软件都支持的。\（\）：将\（和\）之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用\1到\9的符号来引用。|：将两个匹配条件进行逻辑“或”（Or）运算。例如正则表达式（him|her）匹配"it belongs to him"和"it belongs to her"，但是不能匹配"it belongs to them."。注意：这个元字符不是所有的软件都支持的。+：匹配1或多个正好在它之前的那个字符。例如正则表达式9+匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。?：匹配0或1个正好在它之前的那个字符。注意：这个元字符不是所有的软件都支持的。{i}{ij}：匹配指定数目的字符，这些字符是在它之前的表达式定义的。例如正则表达式A[0-9]{3}能够匹配字符"A"后面跟着正好3个数字字符的串，例如A123、A348等，但是不匹配A1234。而正则表达式[0-9]{4,6}匹配连续的任意4个、5个或者6个数字。再来看下简单的实例。1．验证用户名和密码    "^[a-zA-Z]\w{5,15}$"正确格式："[A-Z][a-z]_[0-9]"组成，并且第1个字必须为字母6~16位。2．验证电话号码    "^（\\d{3,4}-）\\d{7,8}$"正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx3．验证手机号码    "^1[3|4|5|7|8][0-9]\\d{8}$"4．验证身份证号（15位或18位数字）    "\\d{14}[[0-9],0-9xX]"5．验证Email地址    "^\\w+（[-+.]\\w+）*@\\w+（[-.]\\w+）*\.\\w+（[-.]\\w+）*$"6．只能输入由数字和26个英文字母组成的字符串    "^[A-Za-z0-9]+$"7．整数或者小数    “^[0-9]+（[.][0-9]+）{0,1}$”8．只能输入数字    "^[0-9]*$"9．只能输入n位的数字    "^\\d{n}$"。10．只能输入至少n位的数字    "^\\d{n,}$"11．只能输入m~n位的数字    "^\\d{m,n}$"12．只能输入零和非零开头的数字    "^（0|[1-9][0-9]*）$"13．只能输入有两位小数的正实数    "^[0-9]+（.[0-9]{2}）?$"14．只能输入有1~3位小数的正实数    "^[0-9]+（\.[0-9]{1,3}）?$"15．只能输入非零的正整数    "^\+?[1-9][0-9]*$"16．只能输入非零的负整数    "^\-[1-9][0-9]*$"17．只能输入长度为3的字符    "^.{3}$"18．只能输入由26个英文字母组成的字符串    "^[A-Za-z]+$"19．只能输入由26个大写英文字母组成的字符串    "^[A-Z]+$"20．只能输入由26个小写英文字母组成的字符串    "^[a-z]+$"21．验证是否含有^%&amp;',;=?$\"等字符    "[^%&amp;',;=?$\x22]+"22．只能输入汉字    "^[\u4e00-\u9fa5]{0,}$"23．验证URL    "^http://（[\\w-]+\.）+[\\w-]+（/[\\w-./?%&amp;=]*）?$"24．验证一年的12个月    "^（0?[1-9]|1[0-2]）$"    正确格式为："01"～"09"和"10"～"12"。25．验证一个月的31天    "^（（0?[1-9]）|（（1|2）[0-9]）|30|31）$"    正确格式为："01"～"09"、"10"～"29"和“30”~“31”。26．获取日期正则表达式    "\\d{4}[年|\-|\.]\\d{\1-\12}[月|\-|\.]\\d{\1-\31}日? "注意可用来匹配大多数年月日信息。27．匹配双字节字符（包括汉字在内）    " [^\x00-\xff] "注意可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）。28．匹配空白行的正则表达式    "\n\s*\r"注意可以用来删除空白行。29．匹配HTML标记的正则表达式    "&lt;（\S*?）[^&gt;]*&gt;.*?&lt;/&gt;|&lt;.*? /&gt;"注意网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力。30．匹配首尾空白字符的正则表达式    "^\s*|\s*$"注意可以用来删除行首行尾的空白字符（包括空格、制表符、换页符等等），非常有用的表达式。31．匹配网址URL的正则表达式    " [a-zA-z]+://[^\s]* "注意网上流传的版本功能很有限，上面这个基本可以满足需求。32．匹配账号是否合法（字母开头，允许5~16B，允许字母数字下划线）    "^[a-zA-Z][a-zA-Z0-9_]{4,15}$"注意表单验证时很实用。33．匹配腾讯QQ号    " [1-9][0-9]{4,} "注意腾讯QQ号从10000开始。34．匹配中国邮政编码    " [1-9]\\d{5}（?!\d）"注意中国邮政编码为6位数字。35．匹配ip地址    "（[1-9]{1,3}\.）{3}[1-9]"注意提取ip地址时有用。36．匹配MAC地址    "（[A-Fa-f0-9]{2}\:）{5}[A-Fa-f0-9] "正则表达式的应用范围很广，sed、awk、Python、PHP、Perl……都支持正则表达式。熟练掌握正则后，使用Linux时会方便很多。 3.5.2　grepLinux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。UNIX的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小差异。egrep是grep的扩展，支持更多的re元字符，fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示其自身的字面意义，不再特殊。Linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。1．参数简介先来看下man grep是怎么说的吧，如图3-17所示。 图3-17　man grepgrep命令的参数-a：将binary文件以text文件的方式搜寻数据；-c：计算找到'搜寻字符串'的次数；-i：忽略大小写的不同，所以大小写视为相同；-n：顺便输出行号；-v：反向选择，亦即显示出没有“搜寻字符串”内容的那一行；--color=auto：可以将找到的关键词部分加上颜色显示；-E：也就是egrep，grep的基础上扩展了正则功能；-F：也就是fgpre，将所有的字符当成元字符来过滤，不识别正则。因此速度较快。2．实例测试grep –c测试，如图3-18所示。 图3-18　grep –c测试grep -i测试，如图3-19所示。 图3-19　grep –i测试grep -n测试，这个在使用vi敲代码的时候特别有用，如图3-20所示。 图3-20　grep –n测试grep –v测试，查找不含()的非空行，如图3-21所示。 图3-21　grep –v测试grep –E测试，grep查询时包含正则，如图3-22所示。 图3-22　grep –E测试grep –F测试，grep查询时当成元字符，如图3-23所示。 图3-23　grep –F测试grep功能强大，在文本内搜索效率非常高，可以说是Linux中最常用的几个命令。 3.5.3　findLinux下find命令提供了相当多的查找条件，功能很强大。find命令在目录结构中搜索文件，并执行指定的操作。由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统（NFS），find命令在该文件系统中同样有效，具有相应的权限。在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间（这里是指30GB以上的文件系统）。1．参数简介先来看下man find，如图3-24所示。 图3-24　man findLinux中find常见用法：    find  path  -option  [  -print ]  [ -exec  -ok  command ]  {} \;find命令的参数：pathname find：所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。-print find：将匹配的文件输出到标准输出。-exec find：对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' { } \;，注意{ }和\；之间的空格。注意在使用find命令的-exec选项处理匹配到的文件时，find命令将所有匹配到的文件一起传递给exec执行。不幸的是，有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。此时就该xargs命令大显身手了，xargs与find命令一起使用。find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像- exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高；而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。-ok和-exec：作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。-name filename：查找名为filename的文件。-perm：按执行权限来查找。-user username：按文件属主来查找。-group groupname：按组来查找。-mtime -n +n：按文件更改时间来查找文件，-n指n天以内，+n指n天以前。-atime -n +n：按文件访问时间来查GIN: 0px"&gt;。-ctime -n +n：按文件创建时间来查找文件，-n指n天以内，+n指n天以前。-nogroup：查找无有效属组的文件，即文件的属组在/etc/groups中不存在。-nouser：查找无有效属主的文件，即文件的属主在/etc/passwd中不存在。-newer f1 !f2：查找文件，-n指n天以内，+n指n天以前。-type b/d/c/p/l/f：查找块设备、目录、字符设备、管道、符号链接、普通文件。-size n[c]：查找长度为n块[或n字节]的文件。-depth：使查找在进入子目录前先行查找完本目录。-mount：查找文件时不跨越文件系统mount点。-follow：如果遇到符号链接文件，就跟踪链接所指的文件。-cpio %;：查找位于某一类型文件系统中的文件，这些文件系统类型通常可在/etc/fstab中找到。-prune：忽略某个目录。这么多的参数看上去是不是很复杂？实际上常用的参数并不多，最常用的就是-name了。参考下文的几个实例就明白了，其实find很简单。2．实例测试这里只展示几个最常用的find用法，如图3-25所示。 图3-25　find实例find用于查找符合条件的文件，效率比Windows下的“查找”高很多，功能也远比“查找”强大。注意find有独特的exec参数可以配合处理查找结果（也可以配合xargs命令）。有时Linux的日志文件或是其他的文件在未做限制的情况下会增长到让人瞠目结舌，这时候就是find大显身手的时候，只需一个find就可以让系统恢复正常，非常方便。 3.5.4　sedsed是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非使用重定向存储输出。sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。1．参数简介先来看看man sed，如图3-26所示。 图3-26　man sed下面是sed命令的参数的常用选项：-n：使用安静（silent）模式。在一般sed的用法中，所有来自STDIN的资料一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行（或者动作）才会被列出来。-e：直接在指令列模式上进行sed的动作编辑。-f：直接将sed的动作写在一个档案内，-f filename则可以执行filename内的sed动作。-r：sed的动作支援的是延伸型正规表示法的语法。（预设是基础正规表示法语法）。-i：直接修改读取的档案内容，而不是由屏幕输出。常用命令：a：新增，a的后面可以接字串，而这些字串会在新的一行出现（目前的下一行）。c：取代，c的后面可以接字串，这些字串可以取代n1与n2之间的行。d：删除，因为是删除，所以d后面通常不接任何内容。i：插入，i的后面可以接字符串，而这些字符串会在新的一行出现（目前的上一行）。p：列印，即将某个选择的资料印出。通常p会与参数sed -n一起运作。s：取代，可以直接进行取代的工作。通常这个s的动作可以搭配正规表示法。2．创建测试环境下面来实战演练一下，先建立一个演示用的文本，执行命令：    echo "aaaa" &gt; /tmp/test.txt    echo "bbbb" &gt;&gt; /tmp/test.txt    echo "cccc" &gt;&gt; /tmp/test.txt    echo "1111" &gt;&gt; /tmp/test.txt    echo "2222" &gt;&gt; /tmp/test.txt    echo "3333" &gt;&gt; /tmp/test.txt建立好演示用文本/tmp/test.txt，如图3-27所示。 图3-27　创建演示文本3．实例测试使用sed删除功能，如图3-28所示。 图3-28　sed删除注意sed只有在使用-i参数时才会对文件进行真正的修改。使用sed搜索或替换特定字符（如果仅仅是搜索，这个功能与grep很相似），如图3-29所示。 图3-29　sed搜索、替换使用sed添加字符或添加行，如图3-30所示。 图3-30　sed添加字符、行使用sed删除字符或删除行，如图3-31所示。 图3-31　sed删除字符、行使用sed –i直接修改文件，如图3-32所示。 图3-32　sed –i直接修改文件与vim不同的是vim需要打开文件才能编辑内容，而sed命令配合-i选项可以不打开文件直接编辑。虽然vim也有查找、搜索、替换的功能，但少一道工序不是更好吗？除了以上展示的例子外，sed还有很多强大的功能待挖掘。熟悉了sed，在以后的文本编辑中会方便很多。注意大部分情况下，sed脚本无论多长都能写成单行的形式（通过`-e'选项和`;'号）——只要命令解释器支持，所以这里说的单行脚本除了能写成一行还对长度有所限制。因为这些单行脚本的意义不在于它们是以单行的形式出现，而是让用户能方便地在命令行中使用这些紧凑的脚本。 3.5.5　awkawk（其名称得自于它的创始人Alfred Aho 、Peter Weinberger和Brian Kernighan姓氏的首个字母）是一种优良的文本处理工具。它不仅是Linux中，也是任何环境中，现有的功能最强大的数据处理引擎之一。awk提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。实际上awk的确拥有自己的语言：awk程序设计语言，3位创建者已将它正式定义为“样式扫描和处理语言”。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。最简单地说，awk是一种用于处理文本的编程语言工具。awk在很多方面类似于shell编程语言，尽管awk具有完全属于其本身的语法。它的设计思想来源于SNOBOL4、sed、Marc Rochkind设计的有效性语言以及语言工具yacc和lex，当然还从C语言中获取了一些优秀的思想。在最初创造awk时，其目的是用于文本处理，并且这种语言的基础是，只要在输入数据中有模式匹配，就执行一系列指令。该实用工具扫描文件中的每一行，查找与命令行中所给定内容相匹配的模式。如果发现匹配内容，则进行下一个编程步骤。如果找不到匹配内容，则继续处理下一行。1．参数简介先来看看man awk，如图3-33所示。 图3-33　man awk有3种方式调用awk：命令行方式    awk [-F  field-separator]  'commands'  input-file（s）其中，commands是真正awk命令，[-F域分隔符]是可选的。input-file（s）是待处理的文件。在awk文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。shell脚本方式将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，通过键入脚本名称来调用。相当于shell脚本首行的：#!/bin/sh可以换成：#!/bin/awk将所有的awk命令插入一个单独文件，然后调用：    awk -f awk-script-file input-file（s）其中，-f选项加载awk-script-file中的awk脚本，input-file（s）跟上面的是一样的。在这里只介绍命令行方式，如对其他方式有兴趣，请自行参考谷歌百度。awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出了最常用的一些变量。    ARGC 命令行变元个数     ARGV 命令行变元数组     FILENAME 当前输入文件名     FNR 当前文件中的记录号     FS 输入域分隔符，默认为一个空格     RS 输入记录分隔符     NF 当前记录里域个数     NR 到目前为止记录数     OFS 输出域分隔符     ORS 输出记录分隔符 2．创建测试环境下面来实战演练一下，先建立一个演示用的文本，执行命令：    echo "aaa bbb:ccc ddd" &gt; /tmp/test.txt    echo "111 222:333 444" &gt;&gt; /tmp/test.txt    echo "AAA BBB:CCC DDD" &gt;&gt; /tmp/test.txt    echo "[[[ ]]]:{{{ }}}" &gt;&gt; /tmp/test.txt建立好演示用文本/tmp/test.txt，如图3-34所示。 图3-34　演示用文本3．实例测试使用awk显示第2~4行，如图3-35所示。 图3-35　awk显示指定行使用awk演示输入\输出记录分隔符，如图3-36所示。 图3-36　awk记录分隔符使用awk演示输入\输出域分隔符，如图3-37所示。 图3-37　awk域分隔符使用awk演示NR、NF、FNR，如图3-38所示。 图3-38　awk演示内置变量awk和sed都是用来处理文本文件的，它们的用途各有侧重点，也有部分功能重合。个人认为awk在处理有规律的文本时更加方便。还有更多功能待发掘。这里只是简单介绍，如有兴趣可参考谷歌百度。注意awk功能极其强大的，它可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。具备了一个完整的语言所应具有的几乎所有精美特性。实际上，awk的确拥有自己的语言：awk程序设计语言，awk的3位创建者已将它正式定义为样式扫描和处理语言。 3.5.6　其他常用工具1．sortsort顾名思义，这个命令就是用来排序的。（1）参数简介首先还是看看man sort，如图3-39所示。 图3-39　man sortsort命令的常用参数如下：-f：忽略大小写的差异，例如A与a视为编码相同；-b：忽略最前面的空格符部分；-M：以月份的名字来排序，例如JAN、DEC等等的排序方法；-n：使用“纯数字”进行排序（默认是以文字型态来排序的）；-r：反向排序；-u：就是uniq，相同的数据中，仅出现一行代表；-t：分隔符，默认是用Tab键来分隔；-k：以哪个区间（field）来进行排序的意思。（2）创建测试环境下面来看具体的实例。先构建测试文件/tmp/1.txt，如图3-40所示，执行命令：    echo "1 2 3 4:d" &gt; /tmp/1.txt    echo "2 3 4 1:C" &gt;&gt; /tmp/1.txt    echo "3 4 1 2:a" &gt;&gt; /tmp/1.txt    echo "4 1 2 3:B" &gt;&gt; /tmp/1.txt    cat /tmp/1.txt 图3-40　实例文件（3）实例测试测试sort –k命令，如图3-41。 图3-41　sort –k测试测试sort –r命令，如图3-42所示。 图3-42　sed –r测试测试sort –t命令，如图3-43所示。 图3-43　sed –t测试在文本处理中，排序是很常见的。sort命令也是必须掌握的命令。2．uniquniq命令可以去除排序过的文件中的重复行，因此uniq经常和sort合用。也就是说，为了使uniq起作用，所有的重复行必须是相邻的。（1）参数简介先看看man uniq，如图3-44所示。 图3-44　man uniquniq常用的选项如下：-i：忽略大小写字符的不同。-c：进行计数。-u：只显示唯一的行。（2）创建测试环境建立测试文件，执行命令：    echo "hello" &gt; /tmp/1.txt    echo "HELLO" &gt; /tmp/1.txt    echo "####" &gt;&gt; /tmp/1.txt    echo "aaaa" &gt;&gt; /tmp/1.txt    echo "aaaa" &gt;&gt; /tmp/1.txt效果如图3-45所示。 图3-45　实例文件（3）实例测试测试uniq，如图3-46所示。 图3-46　uniq测试测试uniq –i，如图3-47所示。 图3-47　uniq –i测试测试uniq –c，如图3-48所示。 图3-48　uniq –c测试uniq一般和sort配合使用，先用sort排序，uniq去除相邻的重复行。功能强大，速度快，非常方便。注意杀鸡无须用牛刀，当uniq+sort能满足要求的时候就不要麻烦awk了。而且在处理小文本时，uniq+sort的效率更高。第4章　Raspberry常用服务想不想拥有一台个人的服务器？Raspberry完全可以做到，它能完善绿色环保私人定制，一旦拥有别无所求。Raspberry的操作系统RaspBian和Debian几乎没有什么区别。所以在Debian上有的服务在RaspBian上几乎都有。本章讲解在RaspBian上安装配置Linux最常用的服务。本章主要内容包括：xrdp远程桌面服务samba共享服务miniDLNA共享影音服务vsftp FTP服务Nginx和LAMP服务 4.1　xrdp远程桌面服务计算机组成网络，第一步通常是远程连接。紧接着的一定是远程控制了。远程控制的明星软件很多，比如最出名的TeamViewer。那的确是非常好的软件，即使在Linux下表现同样出色，可是杀鸡何须用牛刀。也许还有更合适的选择。 4.1.1　xrdp简介远程桌面不管是在Linux还是Widows，使用都非常频繁。Xrdp是Linux的远程桌面服务，一般常用的Linux远程桌面是VNC，但是在Windows上连接Linux的VNC还得下载专用的工具。VNC的服务端口是5900+x，与常用的Windows远程桌面端口3389不一样。所以还是选择xrdp服务吧，实际上xrdp服务也是依赖VNC服务的。 4.1.2　xrdp安装在RaspBian上安装xrdp服务非常简单，用Putty以默认用户pi登录到Raspberry后，执行命令：    sudo apt-get install xrdp安装完毕后，也无须配置，只要每次使用前启动xrdp服务就可以了。执行命令：    sudo /etc/init.d/xrdp start    sudo update-rc.d xrdp defaults第一条命令是启动xrdp服务，第二条命令是将xrdp服务加入系统默认启动服务中。重启系统后就不需要再次执行第一条命令了。 4.1.3　登录xrdpxrdp服务启动后，可以在其他的远程主机上连接Raspberry的桌面。1．Windows登录在Windows 7下远程桌面连接Raspberry。（1）单击“开始”菜单，输入mstsc，运行mstsc.exe。如图4-1所示。 图4-1　Windows远程连接工具（2）打开Windows远程桌面连接，输入Raspberry的IP，如图4-2所示。 图4-2　Windows远程桌面连接（3）单击“连接”按钮，得到Raspberry的登录界面，如图4-3所示。 图4-3　登录Raspberry（4）输入用户名，密码。单击OK按钮，得到了Raspberry的远程桌面，如图4-4所示。 图4-4　Windows 7登录Rasbperry远程桌面2．Linux登录在Linux下远程连接Raspberry。Linux下的远程桌面工具是rdesktop，如果未安装rdesktop，su到root执行命令：    apt-get install rdesktop（1）命令简介先看下man rdesktop，如图4-5所示： 图4-5　man rdesktoprdesktop的常用参数如下：-f：全屏。-a：16位色。-u：登录用户，可选。-p：登录密码，可选。-r：clipboard:PRIMARYCLIPBOARD重要，剪贴板可以与远程桌面交互。-a：16颜色，可选，不过最高就是16位。-z：压缩，可选。-g：1024×768分辨率，可选，默认是一种比当前本地桌面低的分辨率。-P：缓冲，可选。-r：disk:wj=/home/magicgod映射虚拟盘，可选，会在远程机器的网上邻居里虚拟出一个映射盘，功能很强，甚至可以是软盘或光盘。-r：sound:off关闭声音，当然也可以把远程发的声音映射到本地来。（2）实验测试使用rdesktop远程连接Raspberry桌面，如图4-6所示，执行命令：    rdesktop -f 192.168.2.91 -u pi 图4-6　rdesktop连接输入密码后，单击OK按钮，如图4-7所示。 图4-7　Linux登录Raspberry远程桌面利用xrdp服务连接Raspberry的优点是效果直观，缺点是速度较慢。Raspberry所有的操作都是可以使用命令行的。一般使用ssh连接足矣，Xrdp服务只作为补充，了解了解就可以了。注意在Linux上，ssh可以完成99.99％的工作。即使想浏览网页，也有lynx浏览器、w3m浏览器……可供挑选（无法浏览图片）。在熟悉Linux后，xrdp功能的存在感会变得很低很低。 4.2　samba共享服务得益于目前硬件的价格越来越便宜，在同一局域网内可能有Windows主机、Linux主机、Mac主机甚至可能有Unix主机。在这么多不同的系统之间，怎么共享文件呢？首选方案samba，万能的samba。 4.2.1　samba简介samba是一套使用SMB（Server Message Block）协议的应用程序，通过支持这个协议，samba允许Linux服务器与Windows系统之间进行通信，使跨平台的互访成为可能。samba采用C/S模式，其工作机制是让NetBIOS（Windows网上邻居的通信协议）和SMB两个协议运行于TCP/IP通信协议之上，并且用NetBEUI协议让Windows在“网上邻居”中能浏览Linux服务器。 4.2.2　samba安装samba可以说是Linux上最常用的一个服务了。得益于Debian良好的包管理系统apt-get，在RaspBian上安装samba服务很简单。用Putty以默认用户pi登录到Raspberry，执行命令：    sudo apt-get install sambasamba安装完毕。 4.2.3　samba配置Raspberry中samba服务的配置文件是/etc/samba/smb.conf，在配置samba服务之前先说明一下samba的安全等级。samba有4种安全等级：security=share：用户访问samba服务器不需要提供用户名和口令，安全性能较低。security=user：samba服务器默认的安全等级，每一个共享目录只能被一定的用户访问，并由samba服务器负责检查账号和密码的正确性。security=server：服务器安全级别，依靠其他Windows NT/2000或samba服务器来验证用户的账号和密码，是一种代理验证。此种安全模式下，系统管理员可以把所有的Windows用户和口令集中到一个NT系统上，使用Windows NT进行samba认证，远程服务器可以自动认证全部用户和口令，如果认证失败，samba将使用用户级安全模式作为替代的方式。security=domain：域安全级别，使用主域控制器（PDC）来完成认证。因为是个人使用，家庭用户直接选用share就可以了。如果有其他的用途，请自行参考配置。好了，先看下最简单的smb.conf是怎么设置的。顺便复习一下上章学习的grep命令，执行命令：    cd /etc/samba/    grep –v ^\; smb.conf | grep –v ^# | grep –v ^$第二条命令的作用是将smb.conf中的注释行、空行去除，剩下的就是有用的设置了。结果如图4-8所示。 图4-8　grep smb.conf以上的设置有很多都不是必需的，而且少了最重要的security项。下面来配置一个最简单的smb.conf试试看。备份smb.conf后，利用smb.conf的有效设置，稍微修改一下。执行命令：    cd /etc/samba    sudo cp smb.conf smb.conf.old    sudo sed -i -e '/^#/d' smb.conf  -e '/^\;/d' -e '/^$/d' -e '/homes/,$d'使用sed去除了空行、注释行，并把homes以下的设置都去除了。在global中添加security选项，再仿照[homes]选项做一个[pi]的选项。以下是/etc/smb.conf的代码：      1 [global]      2    workgroup = WORKGROUP      3    server string = %h server      4    dns proxy = no      5    log file = /var/log/samba/log.%m      6    max log size = 1000      7    syslog = 0      8    panic action = /usr/share/samba/panic-action %d      9    encrypt passwords = true     10    passdb backend = tdbsam     11    obey pam restrictions = yes     12    unix password sync = yes     13    passwd program = /usr/bin/passwd %u     14    passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .     15    pam password change = yes     16    map to guest = bad user     17    usershare allow guests = yes     18     19     20     21 ####  用户自行添加     22 ##安全级别share     23    security = share     24    guest account = pi     25    directory mask = 0700     26    create mask = 0700     27     28 [pi]     29 ## samba注释     30    comment = User pi Home Directories     31 ## 共享目录     32    path = /home/pi     33    browseable = yes     34    writable = yes     35    public = yes     36    valid users = pi     37    read only = no     38    available = yes     39    guest ok = yes这里有两个地方一定要注意，guest account是一定要有的，guest ok这个也是一定要有的。否则，即使设置的security=share，在使用Windows登录时系统依然会提示要求输入密码，而且不管输入什么密码都无法登录到samba服务器。在debian中，有个testparm命令，可以测试smb.conf文件是否配置正确。可惜RaspBian没有这个命令，所以请再三检查smb.conf文件，避免犯一些低级错误。配置完毕后，重启samba服务，并将samba服务添加到系统默认启动的服务中去。执行命令：    sudo /etc/init.d/samba start    sudo update-rc.d samba defaults使用smbclient命令查看smb服务，执行命令：    smbclient –L //192.168.2.91提示输入密码，无须输入，直接按Enter键，得到的结果如图4-9所示。 图4-9　smbclient –L //192.168.2.91samba服务配置完毕，基本上这样就可以使用了。美中不足的是磁盘比较小。如果已经挂载了大容量硬盘，将它加入smb.conf中共享起来，一个私人的文件服务器就建立好了。 4.2.4　登录samba服务器1．Windows环境登录samba服务器samba服务器已经设置完毕了，现在可以在Windows环境登录samba服务器了。在桌面上双击“网络”图标，如图4-10所示。 图4-10 Windows网络显示在workgroup工作组里有三台主机，其中RASPBERRYPI就是刚才设置了samba服务器的那台Raspberry。双击RASPBEYPI的图标，如图4-11所示。 图4-11　samba共享目录显示在Raspberry主机上的共享目录，也就是刚才在smb.conf里设置的共享文件夹pi。双击pi图标，如图4-12所示。 图4-12　samba共享文件夹使用xrdp服务，连接到Raspberry主机，看看pi用户的家目录，比较一下。如图4-13所示。 图4-13　Raspberry samba对比一下，完全一致。samba配置成功。2．Linux环境登录samba服务器Linux的桌面环境很多，这里只测试Gnome classic环境。单击桌面左上方的“位置”图标，单击“连接到服务器”选项，如图4-14所示。 图4-14　Linux Gnome在“类型”下拉框中选择“Windows共享”，在“服务器”文本框中填入Raspberry的IP地址，因为samba主机设置的安全级别是share，所以这里除了IP外，其他的什么都不需要填。如图4-15所示。 图4-15　Gnome连接samba单击“连接”按钮，出现如图4-16所示界面： 图4-16　Gnome浏览共享目录双击pi文件夹，出现如图4-17所示界面。 图4-17　Gnome浏览共享文件好了，最后连接到xrdp服务器上比较一下，如图4-18所示。 图4-18　Gnome sambasamba服务器演示完毕。这里只演示了最简单的samba服务器配置，家庭、个人使用是没问题的。如有其他的用途，请自行调节安全级别。注意使用samba服务器再加上rsync可以建立自己的私有云。这个小项目并不复杂。稍微运作一下就可以了。 4.3　miniDLNA共享影音服务samba安装配置好后，在局域网内共享文件已经不是问题了。但在局域网播放影音文件却不是samba所擅长的。这里就要用到miniDLNA了。 4.3.1　miniDLNA简介DLNA的全称是DIGITAL LIVING NETWORK ALLIANCE（数字生活网络联盟），其宗旨是Enjoy your music、photos and videos，anywhere anytime。DLNA由索尼、英特尔、微软等发起成立，旨在解决个人PC、消费电器、移动设备在内的无线网络和有线网络的互联互通，使得数字媒体和内容服务的无限制的共享和增长成为可能，目前成员公司已达280多家。而miniDLNA按照man minidlnad的解释是minidlnad——lightweight DLNA/UPnP-AV server。将miniDLNA安装好后，就可以在手机、平板等移动设备上播放mniDLNA服务器上的影音文件，无须再次下载。速度比使用samba的播放快很多。 4.3.2　miniDLNA安装使用Putty登录Raspberry，执行命令：    sudo apt-get install minidlnaminiDLNA安装完毕。 4.3.3　miniDLNA配置miniDLNA的配置文件是/etc/minidlna.conf。这个文件配置起来很简单，先来看看默认的有效配置，如图4-19所示。 图4-19　miniDLNA默认配置先将它备份一下，执行命令：    sudo cp /etc/minidlna.conf /etc/minidlna.conf.bak创建dlna的家目录：    sudo mkdir –pv /mnt/disk/dlna/audio    sudo mkdir –pv /mnt/disk/dlna/video将配置文件稍微修改一下，以下是修改好的/etc/minidlan.conf。    ####  音频文件夹    media_dir=A,/mnt/disk/dlna/audio    ####  视频文件夹    media_dir=V,/mnt/disk/dlna/video    port=8200    serial=12345678    model_number=1    album_art_names=Cover.jpg/cover.jpg/AlbumArtSmall.jpg/albumartsmall.jpg/AlbumArt.jpg/albumart.jpg/Album.jpg/album.jpg/Folder.jpg/folder.jpg/Thumb.jpg/thumb.jpg然后重启minidlna服务，将它添加到启动服务中去，执行命令：    sudo /etc/init.d/minidlna restart    sudo update-rc.d minidlna defaults好了，miniDLNA服务器配置完毕了。以后就可以用支持dlna的播放器直接播放服务器上的影音文件了。注意目前DLNA默认支持的图像格式是jpg、png、gif、tiff。音频格式是mp3、aac、ac-3、atrac-3+、wma9。视频格式是mpeg-1、mpeg-2、mpeg-4、avc、wmv9。没有流行的rmvb，也没有高清的mkv。如果想添加新的格式，得自行DIY。看来革命尚未成功，同志仍需努力啊。另外就是在iOS上支持dlna的播放器不多，即使有也是收费版的。在这点Android平台做得不错。 4.4　VSFTP FTP服务在局域网内共享文件，除了samba外还有FTP服务器。在Linux下首屈一指的FTP服务器就要数VSFTP了。它是一个老牌的明星软件，时间证明了实力。 4.4.1　VSFTP简介VSFTP是一个基于GPL发布的类Unix系统上使用的FTP服务器软件，它的全称是Very Secure FTP。从此名称可以看出来，编制者的初衷是代码的安全。安全性是编写VSFTP的初衷，除了这与生俱来的安全特性以外，高速与高稳定性也是VSFTP的两个重要特点。在速度方面，使用ASCII代码的模式下载数据时，VSFTP的速度是Wu-FTP的两倍，如果Linux主机使用2.4.*的内核，在千兆以太网的下载速度可达86MB/S。在稳定方面，VSFTP就更加地出色，VSFTP在单机（非集群）上支持4000个以上的并发用户同时连接，根据Red Hat的FTP服务器的数据，VSFTP服务器可以支持15000个并发用户。仅作为个人服务器，VSFTP是完全合格的。 4.4.2　VSFTP安装VSFTP很小，但功能强大。在配置好apt-get源后，安装其他软件就很方便了。这里安装VSFTP只需要一条命令就可以了。执行命令：    sudo apt-get install vsftpd 4.4.3　vsftp配置vsfptd服务的配置文件是/etc/vsftpd.conf。为避免破坏文件，还是将该配置文件做个备份。执行命令：    sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.bak    sudo vi /etc/vsftpd.conf下面是修改后的vsftpd.conf。      1 # Example config file /etc/vsftpd.conf      2 #      3 # The default compiled in settings are fairly paranoid. This sample file      4 # loosens things up a bit, to make the ftp daemon more usable.      5 # Please see vsftpd.conf.5 for all compiled in defaults.      6 #      7 # READ THIS: This example file is NOT an exhaustive list of vsftpd options.      8 # Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd's      9 # capabilities.     10 #     11 #     12 # Run standalone?  vsftpd can run either from an inetd or as a standalone     13 # daemon started from an initscript.     14 listen=YES     15 #     16 # Run standalone with IPv6?     17 # Like the listen parameter, except vsftpd will listen on an IPv6 socket     18 # instead of an IPv4 one. This parameter and the listen parameter are mutually     19 # exclusive.     20 #listen_ipv6=YES     21 #     22     23     24 # Allow anonymous FTP? （Beware - allowed by default if you comment this out）.     25 #*-------   是否允许匿名用户登录     26 #anonymous_enable=YES     27 anonymous_enable=NO     28     29     30 # Uncomment this to allow local users to log in.     31 #*-------  是否允许本地用户登录，在这里本地用户只有pi     32 #local_enable=NO     33 local_enable=YES     34     35     36 # Uncomment this to enable any form of FTP write command.     37 #*------  是否允许本地用户对FPT服务器有写入权限     38 #write_enable=NO     39 write_enable=NO     40     41     42     43 # Default umask for local users is 077. You may wish to change this to 022,     44 # if your users expect that （022 is used by most other ftpd's）     45 #*------  本地用户的文件掩码     46 #local_umask=022     47 local_umask=022     48     49     50     51 # Uncomment this to allow the anonymous FTP user to upload files. This only     52 # has an effect if the above global write enable is activated. Also, you will     53 # obviously need to create a directory writable by the FTP user.     54 #*------  是否允许匿名用户上传文件     55 #anon_upload_enable=YES     56 anon_upload_enable=NO     57     58     59 #     60 # Uncomment this if you want the anonymous FTP user to be able to create     61 # new directories.     62 #*------  是否允许匿名用户创建新文件夹     63 #anon_mkdir_write_enable=YES     64 anon_mkdir_write_enable=NO     65     66     67 # Activate directory messages - messages given to remote users when they     68 # go into a certain directory.     69 #*------  是否显示欢迎信息     70 dirmessage_enable=YES     71     72     73 #     74 # If enabled, vsftpd will display directory listings with the time     75 # in  your  local  time  zone.  The default is to display GMT. The     76 # times returned by the MDTM FTP command are also affected by this     77 # option.     78 use_localtime=YES     79 #     80 # Activate logging of uploads/downloads.     81 xferlog_enable=YES     82 #     83 # Make sure PORT transfer connections originate from port 20 （ftp-data）.     84 #*------  设定ftp服务数据端口     85 connect_from_port_20=YES     86     87     88 #     89 # If you want, you can arrange for uploaded anonymous files to be owned by     90 # a different user. Note! Using "root" for uploaded files is not     91 # recommended!     92 #*------  是否允许修改上传文件的属主     93 #chown_uploads=NO     94 chown_uploads=YES     95 #*------  如果允许，输入该属主的用户名     96 #chown_username=whoever     97 chown_username=pi     98     99    100 #    101 # You may override where the log file goes if you like. The default is shown    102 # below.    103 #*------  设置日志文件    104 #xferlog_file=/var/log/vsftpd.log    105 xferlog_file=/home/pi/log/vsftpd.log    106    107    108 #    109 # If you want, you can have your log file in standard ftpd xferlog format.    110 # Note that the default log file location is /var/log/xferlog in this case.    111 #*------  设置log文件格式为标准xferlog    112 #xferlog_std_format=YES    113 xferlog_std_format=YES    114    115    116 #    117 # You may change the default value for timing out an idle session.    118 #*------  设置数据传输中断间隔时间    119 #idle_session_timeout=600    120 idle_session_timeout=600    121    122    123 #    124 # You may change the default value for timing out a data connection.    125 #*------ 设置数据连接超时时间    126 #data_connection_timeout=120    127 data_connection_timeout=120    128    129    130 #    131 # It is recommended that you define on your system a unique user which the    132 # ftp server can use as a totally isolated and unprivileged user.    133 #nopriv_user=ftpsecure    134 #    135 # Enable this and the server will recognise asynchronous ABOR requests. Not    136 # recommended for security （the code is non-trivial）. Not enabling it,    137 # however, may confuse older FTP clients.    138 #async_abor_enable=YES    139 #    140 # By default the server will pretend to allow ASCII mode but in fact ignore    141 # the request. Turn on the below options to have the server actually do ASCII    142 # mangling on files when in ASCII mode.    143 # Beware that on some FTP servers, ASCII support allows a denial of service    144 # attack （DoS） via the command "SIZE /big/file" in ASCII mode. vsftpd    145 # predicted this attack and has always been safe, reporting the size of the    146 # raw file.    147    148    149 # ASCII mangling is a horrible feature of the protocol.    150 #*------  选择用ASCII方式上传下载    151 #ascii_upload_enable=YES    152 #ascii_download_enable=YES    153 ascii_upload_enable=YES    154 ascii_download_enable=YES    155    156    157 #    158 # You may fully customise the login banner string:    159 #ftpd_banner=Welcome to blah FTP service.    160 #    161 # You may specify a file of disallowed anonymous e-mail addresses. Apparently    162 # useful for combatting certain DoS attacks.    163 #deny_email_enable=YES    164 # （default follows）    165 #banned_email_file=/etc/vsftpd.banned_emails    166 #    167 # You may restrict local users to their home directories.  See the FAQ for    168 # the possible risks in this before using chroot_local_user or    169 # chroot_list_enable below.    170 #chroot_local_user=YES    171 #    172    173    174 # You may specify an explicit list of local users to chroot() to their home    175 # directory. If chroot_local_user is YES, then this list becomes a list of    176 # users to NOT chroot().    177 # （Warning! chroot'ing can be very dangerous. If using chroot, make sure that    178 # the user does not have write access to the top level directory within the    179 # chroot）    180 #chroot_local_user=YES    181 #chroot_list_enable=YES    182 # （default follows）    183 chroot_list_file=/etc/vsftpd.chroot_list    184 #    185 # You may activate the "-R" option to the builtin ls. This is disabled by    186 # default to avoid remote users being able to cause excessive I/O on large    187 # sites. However, some broken FTP clients such as "ncftp" and "mirror" assume    188 # the presence of the "-R" option, so there is a strong case for enabling it.    189 #ls_recurse_enable=YES    190 #    191 # Customization    192 #    193 # Some of vsftpd's settings don't fit the filesystem layout by    194 # default.    195 #    196 # This option should be the name of a directory which is empty.  Also, the    197 # directory should not be writable by the ftp user. This directory is used    198 # as a secure chroot() jail at times vsftpd does not require filesystem    199 # access.    200 secure_chroot_dir=/var/run/vsftpd/empty    201 #    202 # This string is the name of the PAM service vsftpd will use.    203 pam_service_name=vsftpd    204 #    205 # This option specifies the location of the RSA certificate to use for SSL    206 # encrypted connections.    207 rsa_cert_file=/etc/ssl/private/vsftpd.pem    208    209    210 #*------  设置本地用户登录目录    211 local_root=/home/pi/ftp好了，配置文件修改完毕，如果去除掉空行和注释行，这个配置并不多。创建ftp服务的家目录，执行命令：    mkdir –pv ~/ftp    sudo /etc/init.d/vsftpd start    sudo update-rc.d samba defaults将vsftpd设置成开机启动服务。 4.4.4　登录VSFTP服务器1．Windows环境下登录VSFTP服务器Windows环境下登录FTP的软件很多，这里选择以secureFX为例，如图4-20所示。 图4-20　secureFX协议选择FTP协议，主机名文本框填入Raspberry的IP地址（192.168.2.91），用户名文本框中填入Raspberry默认的用户名，最后在密码文本框中填入pi用户的密码。单击“连接”按钮后，如图4-21所示。 图4-21　secureFx登录ftp2．Linux环境下登录VSFTP服务器在Linux下也有FTP的图像化客户端，例如filezilla之类的软件。它们登录FTP服务器的方法与Windows很相似。这里只演示用FTP命令登录FTP服务器。（1）参数简介首先还是来看man ftp，如图4-22所示。 图4-22　man ftpftp常用参数：-4: use IPv4 addresses only-6: use IPv6, nothing else-p: enable passive mode (default for pftp)-i: turn off prompting during mget-n: inhibit auto-login-e: disable readline support, if present-g: disable filename globbing-v: verbose mode-t: enable packet tracing [nonfunctional]-d: enable debugging（2）实战测试使用Putty登录Linux(Debian)环境或者直接登录Linux。使用FTP命令登录服务端。如图4-23所示。 图4-23　ftp命令登录服务端操作完毕后。使用bye命令退出。使用FTP命令登录到服务端，使用命令来上传、下载、创建、删除文件。这里就不多做介绍了，有兴趣的可以自行谷歌百度。本来还应该将登录用户设置成无法chroot到其他目录的。但Raspberry上的vsftpd略有瑕疵，再加上个人用户无须如此麻烦，暂时就只能这样了。如果想追求完美，请自行下载VSFTP，编译安装后配置。注意存在即为合理，FTP服务器能够经久不衰，时间已证明了它的强大。 4.5　Nginx在网络上使用率最高的服务还是www服务，而www服务最出名的两个明星就要数Nginx和Apache了。先来看Nginx吧。 4.5.1　Nginx简介Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占有内存少，并发能力强，事实上Nginx的并发能力确实在同类型的网页服务器中表现较好。如果建站只要求静态网页，还是建议使用Nginx。相比Apache而言，它更加小巧，性能稳定，非常适合Raspberry使用。 4.5.2　Nginx安装安装Nginx一条命令足矣，执行命令：    sudo apt-get install nginx就这样Nginx已经安装完毕了。 4.5.3　Nginx配置Nginx的配置文件是/etc/nginx/nginx.conf，在http服务上基本是不需要配置什么的，可以直接使用。但对于自建的www站点倒是可以配置一下。www站点的配置文件是/etc/nginx/sites-available/default.bak。首先还是先备份该配置文件，执行命令：    cd /etc/nginx/sites-available    sudo cp default default.bak    mkdir ~/www以下是default的源文件：      1 # You may add here your      2 # server {      3 #   ...      4 # }      5 # statements for each of your virtual hosts to this file      6      7 ##      8 # You should look at the following URL's in order to grasp a solid understanding      9 # of Nginx configuration files in order to fully unleash the power of Nginx.     10 # http://wiki.nginx.org/Pitfalls     11 # http://wiki.nginx.org/QuickStart     12 # http://wiki.nginx.org/Configuration     13 #     14 # Generally, you will want to move this file somewhere, and start with a clean     15 # file but keep this around for reference. Or just disable in sites-enabled.     16 #     17 # Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.     18 ##     19     20 server {     21     #listen   80; ## listen for ipv4; this line is default and implied     22     #listen   [::]:80 default_server ipv6only=on; ## listen for ipv6     23     24     root /usr/share/nginx/www;     25     index index.html index.htm;     26     27     # Make site accessible from http://localhost/     28     server_name localhost;     29     30     location / {     31         # First attempt to serve request as file, then     32         # as directory, then fall back to displaying a 404.     33         try_files $uri $uri/ /index.html;     34         # Uncomment to enable naxsi on this location     35         # include /etc/nginx/naxsi.rules     36     }     37     38     location /doc/ {     39         alias /usr/share/doc/;     40         autoindex on;     41         allow 127.0.0.1;     42         allow ::1;     43         deny all;     44     }     45     46     # Only for nginx-naxsi used with nginx-naxsi-ui : process denied requests     47     #location /RequestDenied {     48     #   proxy_pass http://127.0.0.1:8080;     49     #}     50     51     #error_page 404 /404.html;     52     53     # redirect server error pages to the static page /50x.html     54     #     55     #error_page 500 502 503 504 /50x.html;     56     #location = /50x.html {     57     #   root /usr/share/nginx/www;     58     #}     59     60     # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000     61     #     62     #location ~ \.php$ {     61     #      62     #location ~ \.php$ {     63     #   fastcgi_split_path_info ^（.+\.php）（/.+）$;     64     #   # NOTE: You should have "cgi.fix_pathinfo = 0;" in php.ini     65     #     66     #   # With php5-cgi alone:     67     #   fastcgi_pass 127.0.0.1:9000;     68     #   # With php5-fpm:     69     #   fastcgi_pass unix:/var/run/php5-fpm.sock;     70     #   fastcgi_index index.php;     71     #   include fastcgi_params;     72     #}     73     74     # deny access to .htaccess files, if Apache's document root     75     # concurs with nginx's one     76     #     77     #location ~ /\.ht {     78     #   deny all;     79     #}     80 }     81     82     83 # another virtual host using mix of IP-, name-, and port-based configuration     84 #     85 #server {     86 #   listen 8000;     87 #   listen somename:8080;     88 #   server_name somename alias another.alias;     89 #   root html;     90 #   index index.html index.htm;     91 #     92 #   location / {     93 #       try_files $uri $uri/ =404;     94 #   }     95 #}     96     97     98 # HTTPS server     99 #    100 #server {    101 #   listen 443;    102 #   server_name localhost;    103 #    104 #   root html;    105 #   index index.html index.htm;    106 #    107 #   ssl on;    108 #   ssl_certificate cert.pem;    109 #   ssl_certificate_key cert.key;    110 #    111 #   ssl_session_timeout 5m;    112 #    113 #   ssl_protocols SSLv3 TLSv1;    114 #   ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv3:+EXP;    115 #   ssl_prefer_server_ciphers on;    116 #    117 #   location / {    118 #       try_files $uri $uri/ =404;    119 #   }    120 #}这么长的配置文件，实际上需要修改的只有21、24两行。将其修改为：     21     listen   80; ## listen for ipv4; this line is default and implied     22     23     24     root /home/pi/www;这样就可以了。然后在www站点的根目录，也就是/home/pi/www下建立一个index.html文件。或者将/usr/share/nginx/www/index.html复制过来，稍微修改一下，与原文件稍有区别即可。执行命令：    cp /usr/share/nginx/www/index.html /home/pi/www/    sed –I s    sed -i 's/nginx!/&amp; I am raspberry pi!/g' index.html    sudo /etc/init.d/nginx    sudo /etc/init.d/nginx start好了，现在打开浏览器，输入Raspberry的ip 192.168.2.91，与index.html比较一下，如图4-24所示。 图4-24　Nginx服务器好了，比较结果没有问题。Nginx对静态网页的效果是非常不错的。如果只是需要一个html的网页，无须ASP、PHP、数据库的网站，选择Nginx非常合适。如果是建立动态网页的网站，那还是选择Apache吧。注意除了大名鼎鼎的LAMP外，Nginx也有相应的套件LNMP。它们只是在侧重点有所不同，在功能上LNMP毫不逊色。 4.6　LAMPNginx介绍完毕，下面该说道Apache了。在Linux下Apache往往不会单独出现，和它一起出现的是一个著名的套装LAMP。 4.6.1　LAMP简介LAMP是Linux+Apache+MySQL+PHP的简称，是一组常用来搭建动态网站或者服务器的开源软件，本身都是各自独立的程序，但是因为常被放在一起使用，拥有了越来越高的兼容度，共同组成了一个强大的Web应用程序平台。在上一节曾说过，静态网页最好的选择是Nginx。但动态网页还是使用LAMP，它不仅配置简单方便，而且功能强大，资料众多，非常合适建设动态网站。 4.6.2　LAMP安装安装LAMP实际上就是分别把Linux、Apache、MySQL、PHP安装起来。再配合相应的联合软件，将它们组合到一起。执行命令：    sudo apt-get install apache2    sudo apt-get install php5    sudo apt-get install mysql-server只需要安装主程序，其他依赖程序会自动安装。在安装mysql-server时，会要求设定MySQL的root用户密码，如图4-25所示。 图4-25　设置MySQL密码再次输入MySQL的root用户密码，按Enter键，如图4-26所示。 图4-26　确认MySQL密码好了，稍等片刻，MySQL就安装完毕了。安装软件将它们粘合起来。执行命令：    sudo apt-get install php5-mysql到了这里LAMP就已经安装完毕了。下面开始配置LAMP。 4.6.3　LAMP配置LAMP中，可以配置的只有Apache2，MySQL和PHP都不需要配置了。首先要配置的是Web站点的端口。众所周知Web服务的端口是80，但有时候80端口被占用或者不希望使用80端口时，那就只有修改Apache2的默认端口了。Apache2端口配置文件是/etc/Apache2/ports.conf。执行命令：    cd /etc/Apache2    ls –l ports.conf    cp ports.conf ports.conf.bak    grep –v '#' ports.conf | grep –v ^$ 得到有效的配置，如图4-27所示。 图4-27　Apache端口设置修改端口，只需要修改第1行和第2行就可以了。例如，想把Web服务端口修改成8080，执行命令：    sudo sed –i ‘s/80/8080/g’ ports.conf最终的ports.conf代码如下：      1 # If you just change the port or add more ports here, you will likely also      2 # have to change the VirtualHost statement in      3 # /etc/Apache2/sites-enabled/000-default      4 # This is also true if you have upgraded from before 2.2.9-3 （i.e. from      5 # Debian etch）. See /usr/share/doc/Apache2.2-common/NEWS.Debian.gz and      6 # README.Debian.gz      7      8 NameVirtualHost *:8080      9 ####  Listen是监听的端口，默认的http端口是80     10 Listen 8080     11 &lt;IfModule mod_ssl.c&gt;     12     # If you add NameVirtualHost *:443 here, you will also have to change     13     # the VirtualHost statement in /etc/Apache2/sites-available/default-ssl     14     # to &lt;VirtualHost *:443&gt;     15     # Server Name Indication for SSL named virtual hosts is currently not     16     # supported by MSIE on Windows XP.     17     Listen 443     18 &lt;/IfModule&gt;     19     20 &lt;IfModule mod_gnutls.c&gt;     21     Listen 443     22 &lt;/IfModule&gt;     23下一个要修改的是Web站点的主目录，默认情况下Web站点的主目录是/var/www。这样的缺点是/var/www目录必须有特殊的权限才能修改、添加、删除文件，非常不方便。一般Raspberry都是个人使用单用户登录，可以将Web站点的主目录移动到pi用户的主目录下。如果觉得Raspberry空间小，也可以挂载一块大容量的移动硬盘到/mnt下，然后将Web站点的主目录移动到新磁盘里。查看Apache2站点的配置文件/etc/Apache2/sites-available/default的有效配置，如图4-28所示，执行命令：    cd /etc/Apache2/sites-available    sudo cp default default.bak    grep –v '#' default 图4-28　Apache有效配置只需要将‘/var/www’替换成‘/home/pi/www’，将80替换成8080就可以了。执行命令：    sudo sed -i 's/\/var\/www/\/home\/pi\/www/g' default    sudo sed –i 's/80/8080/g' default修改完毕后，/etc/Apache2/sites-available/default的代码如下：      1 &lt;VirtualHost *:8080&gt;      2     ServerAdmin webmaster@localhost      3      4     DocumentRoot /home/pi/www      5     &lt;Directory /&gt;      6         Options FollowSymLinks      7         AllowOverride None      8     &lt;/Directory&gt;      9     &lt;Directory /home/pi/www/&gt;     10         Options Indexes FollowSymLinks MultiViews     11         AllowOverride None     12         Order allow,deny     13         allow from all     14     &lt;/Directory&gt;     15     16     ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/     17     &lt;Directory "/usr/lib/cgi-bin"&gt;     18         AllowOverride None     19         Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch     20         Order allow,deny     21         Allow from all     22     &lt;/Directory&gt;     23     24     ErrorLog ${APACHE_LOG_DIR}/error.log     25     26     # Possible values include: debug, info, notice, warn, error, crit,     27     # alert, emerg.     28     LogLevel warn     29     30     CustomLog ${APACHE_LOG_DIR}/access.log combined     31 &lt;/VirtualHost&gt;在上一节中，曾将/home/pi/www作为Nginx的主目录，这里就不修改了。直接借用Nginx的index.html。所有配置完毕，下面启动Apache2服务、MySQL服务。执行命令：    sudo /etc/init.d/Apache2 start    sudo /etc/init.d/MySQL start现在打开浏览器，输入Raspberry的ip 192.168.2.91:8080，与index.html比较一下，如图4-29所示。 图4-29　Apache2服务器好了，比较结果没有问题。最后来测试一下PHP，执行命令：    cd /home/pi/www    echo "&lt;?PHP PHPinfo() ; ?&gt;" &gt; PHPinfo.PHP打开浏览器，打开http://192.168.2.91:8080/PHPinfo.PHP。如图4-30所示。 图4-30　PHPinfo.PHP好了，PHP测试通过。再来测试MySQL，先看MySQL服务是否启动，如图4-31所示。 图4-31　查看服务再检查MySQL服务的端口是否正常，如图4-32所示。 图4-32　扫描端口最后登录MySQL，测试用户名和密码是否正确，如图4-33所示。 图4-33　登录MySQLMySQL测试完毕。最后，如果需要开机启动Apache2和MySQL，执行命令：    sudo update-rc.d apache2 defaults    sudo update-rc.d mysql defaults这样以后就不需要每次重启Raspberry后再输入命令启动服务了。有了这个完善的LAMP平台，再也不同担心没有试验平台学习PHP了。注意LAMP是目前最流行的WWW建站套件。最流行的不一定是最好的，但它一定是最方便，适应性最广泛的。第5章　Raspberry常用功能如果仅仅把Raspberry当成一个微型服务器用未免有些浪费了。配以合适的软件，它能发挥更大的作用。本章主要介绍Raspberry一些有趣的使用方法。从软件方面充分挖掘Raspberry的潜能。本章主要内容包括：如何挂载磁盘如何利用Aria2下载机下载如何使用迅雷远程下载如何解析动态域名如何让Raspberry给自己发短信如何监控摄像头 5.1　挂载磁盘装完RaspBian系统后，TF卡的容量也剩下不了多少了。巧妇难为无米之炊，想干点别的都会捉襟见肘，还是先给Raspberry挂载一个大容量的移动硬盘，或者是硬盘盒吧。 5.1.1　硬件准备如果可以，尽可能选择带电源的移动硬盘或者是硬盘盒。Raspberry的电源一般选择5V+2A足矣。但是想它带动大容量的移动硬盘就有点勉强了。所以尽量选择自带电源的大容量移动硬盘吧。将移动硬盘连好电源后，插入Raspberry的USB接口（Raspberry的USB接口也可以作为电源输入口，但不建议这样做，还是让它们各司其职比较好）。 5.1.2　软件设置启动Raspberry，使用Putty远程登录Raspberry，如图5-1所示。 图5-1　Putty登录Raspberry1．命令简介先来学习fdisk命令。用man fdisk看看，如图5-2所示。 图5-2　man fdisk2．检测硬盘，确定目标fdisk是Linux下管理磁盘的工具。它的功能非常强大，完全不逊于大名鼎鼎的PQmagic。fdisk可以对磁盘进行添加、删除、转换等等。几乎每个Linux发行版本都会默认安装fdisk。缺点就是没有GUI界面，只能在命令行下操作，不太友好，如图5-3所示。执行命令：    sudo fdisk –l 图5-3　fdisk -l将大容量移动硬盘插入Raspberry的USB接口。再次执行命令，如图5-4所示。    sudo fdisk –l 图5-4　fdisk显示磁盘从上图中可以看出多出了一个/dev/sda的设备，容量是16GB（这里只是用U盘做测试，实际应用时可以使用500GB，甚至更大的移动硬盘）。3．使用fdisk磁盘分区下面开始对这个添加的移动硬盘进行分区、转换、格式化。执行命令：    sudo fdisk /dev/sda使用fdisk命令，对设备/dev/sda（刚插入USB的设备）进行操作。是/dev/sda不是/dev/sda1。要说明的是在Linux下插入的磁盘是IDE接口的，系统默认它的名字是/dev/hda、/dev/hdb……如果磁盘是STAT接口的，将被认为是/dev/sda、/dev/sdb……USB磁盘也被认为是/dev/sd*。/dev/sda是插入的磁盘设备，而/dev/sda1则是磁盘设备的第一个分区，那么第二个分区毫无疑问就是/dev/sda2了，依次类推。所以，要操作整块磁盘，应该执行的命令是sudo fdisk /dev/sda，而不是/dev/sda1。如图5-5所示。 图5-5　sudo fdisk /dev/sda来看一下这些命令的功能（常用的注有中文，其他的功能不常用）。a：toggle a bootable flagb：edit bsd disklabel，编辑bsd磁盘列表c：toggle the dos compatibility flagd：delete a partition，删除分区l：list known partition types，列出分区的类型m：print this menu，显示帮助菜单n：add a new partition，添加一个新分区o：create a new empty DOS partition table，创建一个新的DOS磁盘列表p：print the partition table，列出现有的分区列表q：quit without saving changes，不保存修改，退出。s：create a new empty Sun disklabel，创建一个新的Sun磁盘列表t：change a partition's system id，修改磁盘分区类型（fat32，ext3……）u：change display/entry unitsv：verify the partition tablew：write table to disk and exit，写入磁盘列表，保存退出。x：extra functionality（experts only），扩展应用，专家模式。选择p查看现有的分区列表，如图5-6所示。 图5-6　fdisk显示分区可以看到已经有一个分区/dev/sda1了。下面使用fdisk完整地将磁盘操作一次。首先是删除现有的磁盘，选择d，如图5-7所示。 图5-7　fdisk删除分区因为只有一个磁盘分区，所以就无须选择删除哪个分区了。如果有多个分区，则先选择d进行删除，然后再来选择删除哪个分区。一步步将所有分区都删除掉。再输入p显示现有的分区。如图5-8所示。 图5-8　fdisk显示分区现在显示磁盘没有分区了。下一步给磁盘划分新的分区，选择n，如图5-9所示。 图5-9　fdisk新建分区fdisk提示选择新分区是主分区还是扩展分区，主分区选择p，扩展分区选择e，默认选择是主分区。选择完毕后，再选择分区的起始位置，默认是2048MB的位置开始，按Enter键确认。再选择分区的结束位置。默认是磁盘末尾，也就是整块磁盘，按Enter键确认。如果只需要一个分区，到这里就可以了。如果想分多个分区，则输入磁盘的大小。例如需要的新分区是10GB，则输入+10GB；如果需要新分区是100MB，则输入+100MB；然后再次输入n，为第二个分区选择主分区，扩展分区，分区大小等等。在这里，这块磁盘只是用来存储文件，弥补Raspberry磁盘容量的不足，所以只需要一个分区就可以了。输入p显示现在的磁盘列表，如图5-10所示。 图5-10　fdisk显示分区看新分区的Id项，显示的是83。现在输入l，列出分区的类型，来看一下83代表什么，如图5-11所示。 图5-11　fdisk分区格式列表从图中可以看出83代表的是Linux分区。如果该移动硬盘只在Raspberry上使用，无须更改，这样就可以了。再选择w保存退出就可以了。如果该移动硬盘还需要放到Windows上使用，Linux分区在Windows中是无法直接识别的，那就需要选择t，改变分区类型，如图5-12所示。 图5-12　fdisk修改分区格式再输入b，选择win95 fat32类型。再选择w保存退出。这样fat32格式可以被Windows和Linux识别。我在这里选择是的83，仅在Linux下使用。注意fdisk是非常优秀的分区工具。除了没有图形界面这个不是缺点的缺点外，它远比明星软件PQ强大。如果在使用PQ无法解决问题，那就使用Linux启动，挂载硬盘后使用fdisk吧。相信它是不会让人失望的。4．格式化磁盘分区完毕后，使用mkfs命令对新分区格式化。如图5-13所示，执行命令：    sudo mkfs.ext4 /dev/sda1 图5-13　mkfs格式化磁盘ext4是一种Linux的分区格式。当然Linux还有其他的几种分区格式，但是最流行的还是ext。如果没有特殊要求，选择ext4是最安全的做法。5．挂载磁盘到系统磁盘已经分区格式化完毕，但还不能使用。系统虽然已经识别了磁盘分区，但还没有把磁盘分区加入到系统中去。最后要把磁盘分区挂载到系统中去。Linux系统中，挂载磁盘一般是在/mnt或/media目录中。执行命令：    sudo mkdir /mnt/disk    sudo mount –t ext4 –o user,defaults /dev/sda1 /mnt/disk好了，现在已经把磁盘分区挂载到/mnt/disk目录中了。但这种挂载是临时的挂载，Raspberry重启后，又得重新执行挂载命令。修改/etc/fstab文件，一劳永逸解决这个问题。使用vi /etc/fstab，在/etc/fstab的最后加上一行：    /dev/sda1           /mnt/disk               ext4            defaults,user           0 06．测试挂载现在已经将磁盘完全挂载到Raspberry上了。此时/mnt/disk的属主是root，将它修改成pi，以便与pi用户也可以读写。如图5-14所示，执行命令：    sudo chown pi:pi /mnt/disk    ls –l /mnt/disk    touch /mnt/disk/abc.txt    ls –l /mnt/disk/abc.txt    rm /mnt/disk/abc.txt 图5-14　添加pi用户权限现在pi用户也可以自由地读写新添加的硬盘了。Raspberry的空间已经扩容完毕。想扩展Raspberry的功能，干点别的吗？Do it。 5.2　Aria2下载机Aria2是一个命令行下运行、多协议、多来源、多平台下载工具（HTTP/HTTPS、FTP、BitTorrent、Metalink），比Linux下默认的下载工具Wget更加强大，如果只是将它单纯地作为一个命令行下载工具，那就有点浪费了。它的缺点是Linux下软件的通病，没有漂亮的GUI。不过没关系，配合yaaw作为Web前台，可以将Raspberry改造成一台下载机。 5.2.1　安装下载组件Aria2下载机功能强大，但需要的组件不多，只要安装Aria2和yaaw即可，再配合Web服务器（这里我用的是Apache2）就组合成了功能强大的下载机。先来下载这两个软件。Aria2已经在Debian的官方源里了。所以只需要执行命令：    sudo apt-get instrall aria2安装就是这么简单，来看看man aria2c，如图5-15所示。 图5-15　man aria2熟悉下Aria2常用的命令行参数：-v：--version，显示版本号-h：--help，显示帮助信息-l：--log=LOG，设置日志-d：--dir=DIR，设置存储下载文件的目录-o：--out=FILE，设置存储下载文件的文件名-s：--split=N，分段下载基本上和Wget相差不大，比Wget强的方面是支持JSON-RPC，所以可以使用YAAW作为它的Web前台。YAAW是Yet Another Aria2 Web Frontend的缩写。顾名思义，YAAW完全是为了Aria2而开发的。YAAW的首页/demo: http://github.com/binux/yaaw/、GitHub: https://github.com/binux/yaaw。虽然YAAW非常不错，但都是E文，看起来还是很碍眼的。幸好有好心人汉化了YAAW放到了Github上了，所以想下载中文版本的YAAW，请自行搜索一下。这里还是使用原版的YAAW输入命令：    cd /home/pi/www  #这个是前面web服务的主目录。    git clone https://github.com/binux/yaawYAAW下载好了。现在使用浏览器打开http://192.168.2.91:8080/yaaw（前面配置Apache2时设置的端口是8080），如图5-16所示。 图5-16　浏览YAAW提示有错误。没关系，那是没有配置好。配置一下就没问题了。 5.2.2　Aria2配置先编写Aria2的配置文件/etc/aria2.conf，系统本身没有这个文件，需要自行创建。执行命令：    sudo touch /etc/aria2.conf    sudo mkdir –pv /mnt/disk/download    touch /mnt/disk/download/.aria2.sessionAria2的配置项很多，这里只需要最简单的方案。/etc/aria2.conf的代码如下：      1 dir=/mnt/disk/download      2 disable-ipv6=true      3 enable-rpc=true      4 rpc-allow-origin-all=true      5 rpc-listen-all=true      6 rpc-listen-port=6800      7 continue=true      8 input-file=/mnt/disk/download/.aria2.session      9 save-session=/mnt/disk/download/.aria2.session     10 max-concurrent-downloads=3完了后运行命令：    aria2c –-conf-path=/etc/aria2.conf测试看看有没有错误，如果没有错误的话，按Ctrl + C组合键终止程序，继续下一步；如果有错误的话，会提示你conf文件哪里错误。创建aria2c，将Aria2做成系统的服务，让它随系统一起启动。    sudo vi /etc/init.d/aria2c/etc/init.d/aria2c的代码如下：      1 #!/bin/sh      2 ### BEGIN INIT INFO      3 # Provides:          aria2      4 # Required-Start:    $remote_fs $network      5 # Required-Stop:     $remote_fs $network      6 # Default-Start:     2 3 4 5      7 # Default-Stop:      0 1 6      8 # Short-Description: Aria2 Downloader      9 ### END INIT INFO     10     11 case "$1" in     12 start）     13     14 echo  -n "Starting aria2c "     15 echo     16 aria2c --conf-path=/etc/aria2.conf -D     17 ;;     18 stop）     19     20 echo  -n "Shutting down aria2c "     21 echo     22 killall aria2c     23 ;;      24 restart）     25     26 echo  -n "restart aria2c "     27 echo     28 killall aria2c     29 aria2c --conf-path=/etc/aria2.conf -D     30 ;;     31 esac     32 exit测试服务是否可以启动，然后将Aria2添加到系统启动服务中去，如图5-17所示。 图5-17　添加启动服务现在用浏览器打开http://192.168.2.91:8080/yaaw，如图5-18所示。 图5-18　浏览yaawAria2下载机安装配置完毕。 5.2.3　测试Aria2下载机测试一下这个下载机，以下载Debian的rom为例。单击Add按钮，将debian-live-8.2.0-amd64-gnome-desktop.iso的下载地址输入Upload Torrent按钮前面的文本框内，在File Name后面的文本框内输入保存的文件名，如图5-19所示。 图5-19　添加下载任务单击Add按钮，开始任务下载。如图5-20所示。 图5-20　任务下载中这个下载速度取决于宽带的速度和提供下载的服务器的速度。一般来说，国内的服务器是可以达到满带宽下载的。就算是国外的服务器不能满带宽下载也没关系。Raspberry极其省电，完全可以24×7开机，输入下载的地址后就可以任其自行下载，绿色环保，安全方便。好了，不要管它了，任其发挥，自由下载吧。实际上yaaw还可以配合迅雷离线下载，使用迅雷离线下载助手插件，这是个Chrome上的插件。它可以将迅雷离线下载好的文件通过yaaw下载回来。如果有国外站点文件下载速度比较慢，可以通过这种方法快速地将其下载回来。注意Chrome和Firefox都有相应的插件可配合迅雷离线使用yaaw。这种方法唯一的缺陷就是必须是迅雷会员才能使用。 5.3　迅雷远程下载既然说到了下载工具，就不得不提起迅雷。在国内迅雷可谓是当之无愧的行业大佬，可惜的是迅雷没有合适的Linux版本。好在迅雷给Linux留下了一个小口子，迅雷远程下载。 5.3.1　下载迅雷远程下载固件迅雷远程下载固件主要是为嵌入式设计的，既然可以用于嵌入式，比嵌入式更强大的Raspberry当然也可以用了。迅雷的固件的下载地址是http://luyou.xunlei.com/thread-15167-1-1.html?_t=1443319618。Xware为了适应多种设备，开发的版本很多，如图5-21所示。 图5-21　迅雷固件列表应该挑选哪个版本的Xware呢？已有热心的网友做好了测试，只需要按图索骥就可以了。打开http://g.xunlei.com/thread-208-1-1.html，然后在网页搜索raspberry，如图5-22所示。 图5-22　迅雷固件选择选择Xware_armel_v5te_glibc版本就可以了。也就是图5-21中的 Xware3.0.32.253_armel_v5te_    glibc.zip。 5.3.2　设置迅雷远程下载已经取得了相应的固件，下面开始安装。1．解压固件将Xware3.0.32.253_armel_v5te_glibc.zip下载到pi用户的主目录下。执行命令得到的结果如图5-23所示。    mkdir xunlei    mv Xware3.0.32.253_armel_v5te_glibc.zip ./xunlei/    cd xunlei/    unzip Xware3.0.32.253_armel_v5te_glibc.zip 图5-23　安装前准备2．修改配置文件查看迅雷固件的配置文件，如图5-24所示。 图5-24　配置文件修改这个配置文件，将/mnt/disk/download/加入配置文件，修改后的配置文件thunder_mounts.cfg代码如下：      1 #过滤与第二列相同的挂载路径      2 invalid_mounts      3 {      4     rootfs /      5 }      6      7 #仅接受以下列路径开头的挂载路径      8 available_mounts      9 {     10     /tmp/usbmounts/     11     /tmp/HDD/     12     /mnt/USB/     13     /mnt/HardDisk/     14 ###这里是自行添加的下载目录     15     /mnt/disk/     16 }     17     18 #下列目录被认为是分区，并在程序运行期间不变     19 virtual_mounts     20 {     21 }3．获取激活码配置文件修改完毕后，开始安装迅雷远程下载，执行命令得到的结果如图5-25所示。    sh xware_bash.sh 图5-25　取得激活码4．绑定激活码这里要留意的是下载目录的配置文件和激活码。浏览器打开http://yuancheng.xunlei.com，输入用户名，密码登录，如图5-26所示。 图5-26　登录迅雷远程在“绑定”前面的文本框中输入刚才得到的6位数激活码，单击“绑定”，如图5-27所示。 图5-27　绑定激活码完成后，单击铅笔图形的编辑按钮，修改设备名，如图5-28所示。 图5-28　修改设备名修改完毕后单击“确定”按钮，如图5-29所示。 图5-29　保存修改设备名好了，现在可以使用迅雷远程下载了。打开迅雷登录，单击远程设备，得到刚才添加的远程设备，如图5-30所示。 图5-30　显示远程设备图片中显示的下载目录C:/TDDOWNLOAD文件夹其实就是Raspberry的/mnt/disk/TDDOWNLOAD文件夹，需要自行创建，执行命令：    sudo mkdir –pv /mnt/disk/TDDOWNLOAD最后，将远程设备的启动命令添加到/etc/rc.local中去，执行命令：    sudo vi /etc/rc.local修改完毕后，结果如图5-31所示。 图5-31　添加到开机启动大功告成，以后启动Raspberry后，就可以直接用迅雷远程下载下载文件了。这里要注意的是，外挂的磁盘必须挂载到刚才修改的配置文件thunder_mounts.cfg中设定的几个目录。可以是系统本身默认的/mnt/USB/，也可以是/mnt/HardDisk/，当然自行添加的/mnt/disk更没问题（在6.1节中已经将磁盘挂载到/mnt/disk了，就无须在此再挂载一次了）注意迅雷远程固件可以在Raspberry上使用，也支持x86_32的PC，就是不支持x86_64。 5.4　动态域名解析做好了服务器，如果只能在内网使用，那未免也太无趣了。独乐乐，与人乐乐，孰乐？好东西要分享。本章将把建立好的Web服务器放到公网上去，让大家可以通过公网域名访问放在Raspberry上的个人服务器。 5.4.1　神器花生壳一般网络服务商分配给人的都是动态的IP，也就是过一段时间就变换一次IP地址。这样一来，如果想将域名与IP对应起来，就不得不使用动态域名解析。而国内最好用的动态域名解析软件就是花生壳。花生壳是一个动态域名解析软件。利用花生壳无论在任何地点、任何时间、使用任何线路，均可利用花生壳建立拥有固定域名和最大自主权的互联网主机。“花生壳动态域名解析软件”支持的线路包括普通电话线、ISDN、ADSL、有线电视网络、双绞线到户的宽带网和其他任何能够提供互联网真实IP的接入服务线路，而无论连接获得的IP属于动态还是静态，甚至服务器藏于内网，都可以使用花生壳穿透内网。 5.4.2　下载安装花生壳花生壳在Windows下的客户端就不说了，那必定是丰富多彩的。在Linux下也有客户端，可是最新的客户端不支持Raspberry，所以只能下载老版本的花生壳。执行命令如图5-32所示。    wget http://download.oray.com/peanuthull/phddns-2.0.2.16556.tar.gz     tar zxvf phddns-2.0.2.16556.tar.gz    cd phddns-2.0.2.16556 图5-32　下载花生壳编译安装花生壳，执行命令结果如图5-33所示。    aclocal\    autoconf    automake    ./configure    make –j2 图5-33　安装花生壳现在已成功地将花生壳安装到了/home/pi/phddns-2.0.2.16556/src下了。 5.4.3　设置花生壳使用花生壳前必须在花生壳的官网注册了账号，至少有一个域名，不管是免费域名还是购买的域名。1．配置花生壳执行命令：    cd /home/pi/phddns-2.0.2.16556/src    mkdir /home/pi/etc    mkdir /home/pi/bin    ./phddns    输入服务器地址，如无特殊情况可使用默认值    Enter server address（press ENTER use phLinux3.oray.net）:        输入您的Oray账号名称    Enter your Oray account:yourname        对应的Oray账号密码    Password:**********        选择绑定的网卡，如无特殊，默认即可    Network interface（s）:    eth0:192.168.2.91    lo:127.0.0.1    Choose one（default eth0）:eth0        选择日志保存到哪个文件    Log to use（default /var/log/phddns.log）:/home/pi/log/phddns.log        保存配置文件，选择yes则直接保存到/etc/phLinux.conf，输入other可以指定文件    Save to configuration file （/etc/phLinux.conf）?（yes/no/other）:other    Enter configuration filename（/etc/phLinux.conf）:/home/pi/etc/phLinux.conf        接下来程序将以交互模式开始运行    192.168.2.91    NIC bind success    OnStatusChanged okConnecting    OnStatusChanged okDomainListed    OnDomainRegistered skyvense22.gicp.net    OnStatusChanged okDomainsRegistered    UserType: 0    看到上面这些就表示登录成功，这个时候可以按Ctrl+C组合键先退出程序执行命令：    cp  /home/pi/phddns-2.0.2.16556/src/phddns /home/pi/bin/    /home/pi/bin/phddns –c /home/pi/etc/phLinux.conf –d    sudo echo "/home/pi/bin/phddns –c /home/pi/etc/phLinux.conf –d" &gt;&gt; /etc/rc.local现在已经将本机绑定到了花生壳账户上了。然后登录花生壳官网，查看域名管理，如图5-34所示。 图5-34　花生壳域名管理2．验证花生壳绑定了花生壳后，验证是否绑定成功。在浏览器里输入注册的域名，如图5-35所示。 图5-35　通过域名访问站点花生壳的效果验证完毕。动态域名解析软件还有很多，花生壳是最常见的也是最方便的，如果有免费域名，用花生壳是最方便的。而且它可以直接穿透内网，无须再进行端口映射，省了很多的麻烦。注意目前国内市面上流行的路由器基本上都原生态地支持花生壳。也就是说可以直接在路由器上登录花生壳账号。如果使用路由器登录花生壳，就必须使用端口映射将服务器的端口映射到路由器上。 5.5　无域名访问内网花生壳是很好，但有人没有花生壳的免费域名怎么办？也很简单，只要找到本地的公网IP，使用公网IP也行，只要做一个端口映射就可以了。 5.5.1　确定公网IP如何确定自己的公网IP？通常我的做法就是打开www.baidu.com，然后在搜索文本框中输入IP，单击“百度一下”后，直接看第一个搜索结果就是了。仔细看一下，得到的这个IP是由www.ip138.com返回的。打开www.ip138.com，查看它的源代码，发现这个IP地址是由http://1111.ip138.com/ic.asp返回的。行了，思路出来了。直接用python脚本去访问1111.ip138.com/ic.asp这个网页，然后在返回的结果中查找需要的IP就可以了。使用Putty登录Raspberry，执行命令：    mkdir –pv code/python/getNip    cd $_    touch2py getNip.py    vi getNip.py最终的getNip.py的代码如下：      1 #!/usr/bin/env python      2 # -*- coding:utf-8 -*-      3 #Author  :hstking      4 #E-mail  :hstking@hotmail.com      5 #Ctime   :2015/08/27      6 #Mtime   :      7 #Version :      8      9 import urllib2     10 import re     11 import os     12     13     14 ####  定义GetNip类     15 class GetNip():     16 ####  定义构造函数，可以用于定义类变量     17     def __init__（self）:     18         self.logPath = os.path.expanduser（'~'） + os.sep + 'log'     19         self.nipFile = self.logPath + os.sep + 'Nip.txt'     20         self.Nip = None     21     22         self.getNip()     23         self.writeNip()     24     25 ####  从网络取得本地的公网IP     26     def getNip（self）:     27         urls = 'http://1111.ip138.com/ic.asp'     28         if urllib2.urlopen（urls）.geturl() == urls:     29             rawString = urllib2.urlopen（urls）.read()     30             self.Nip = re.search（b'\d+\.\d+\.\d+\.\d+',rawString）.group()     31             print（"Nip = %s"%self.Nip）     32         else:     33             print（"未取得本机NIP"）     34     35 ####  将取得的公网IP写入指定文件中     36     def writeNip（self）:     37         if os.path.isdir（self.logPath）:     38             pass     39         else:     40             os.makedirs（self.logPath）     41         with open（self.nipFile,'w'） as FP:     42             FP.write（self.Nip）     43     44     45 ####  以下是脚本的主程序     46 if __name__ == '__main__':     47     nip = GetNip()测试一下，执行命令得到的结果如图5-36所示。    python getNip.py 图5-36　getNip.py执行结果就这样很简单地取得了本地的公网IP。网络上返回本地IP的站点很多。这里只是选择最常用的一个。如果想增强Script的健壮性，可以多添加几个站点做后备。注意这种Script仅在电信的网络上测试过。如果使用别的网络服务无法取得IP，没关系。原理清楚了使用哪种方法并不重要。 5.5.2　端口映射在上节中已经取得了本地的公网IP。可取得了公网IP后，在互联网环境下还是不能访问本地内网的HTTP服务器。通常的做法是在网关上做个端口映射，将内网的HTTP服务端口映射到网关上。这样就可以通过网关（modem）来访问内网的HTTP服务器。鉴于目前糟糕的网络环境，个人是无法自由地选择Modem的，只能使用网络服务商提供的专用Modem。而网络服务商提供的Modem经过一些修改、裁剪，无法进行正常的端口映射（这里以中国电信提供的光猫中兴F460为例，下文中未特殊说明的Modem都是指中兴F460）。所以，只有自己动手，才能丰衣足食了。另外，这种方法只适合有公网IP的用户。如果连公网IP都没有的（比如长城、鹏博士），那还是去用花生壳吧。这种程度的端口映射是不能穿透内网中的内网中的内网中……1．原理电信版中兴F460这款光猫应用范围很广，而且自带WIFI功能，效果也还不错。可讨厌的地方是无法进行任何设置。Web网页设置时需要输入超级密码，个人用户是没有这个密码的，即使通过技术手段得到了这个密码，进入了Web设置页面，也无法设置端口映射和DMZ主机。所以想设置端口映射还得另想办法。几乎所有的Modem都是以嵌入式Linux（openwrt）为基础改编的。中兴F460这款Modem当然也不例外。使用nmap扫描一下这个光猫。执行命令：    nmap –sT –O 192.168.1.1得到的结果如图5-37所示 图5-37　nmap modem可以看到除了http端口开放外，还开放了telnet端口。既然开放了telnet端口，那就说明可以远程登录。如果能登录，那就可以直接以iptables来设置端口映射。telnet的用户名是root，密码多试几次就出来了，密码还是root。现在只需要用Python脚本登录Modem的telnet服务，调用iptables将Raspberry的端口转发到Modem上就可以了。2．实际操作首先要说明的是笔者的拓扑结构，光钎入户连接光猫中兴F460（192.168.1.1）。光猫的LAN口连接TP-LINK路由器（192.168.2.1）的WAN口。TP-LINK路由器的LAN口连接到Raspberry（192.168.2.91）和PC。拓扑图如图5-38所示。 图5-38　拓扑图（1）从主机到路由器的映射先将Raspberry的http端口映射到TP-LINK路由器上。这里我使用的是DMZ主机，如图5-39所示。 图5-39　DMZ主机设置查看TP-LINK在modem上的IP，如图5-40所示。 图5-40　路由器外网IP（2）路由器到光猫的映射编写portmap.py，将公网IP的8080端口映射到TP-LINK路由器（192.168.1.90）的8080端口上，间接地将端口映射到Raspberry（192.168.2.91）。现在开始来编写portmap.py，使用Putty登录到Raspberry上，执行命令：    cd    mkdir –pv code/python/portmap    cd $_    touch2py portmap.py    vi portmap.pyportmap.py的代码如下：      1 #!/usr/bin/env python      2 # -*- coding:utf-8 -*-      3 #Author  :hstking      4 #E-mail  :hstking@hotmail.com      5 #Ctime   :2015/09/09      6 #Mtime   :      7 #Version :      8      9 import logging     10 import os     11 import telnetlib     12 import urllib2     13 import re     14 import time     15     16     17 ####  定义GetNip类     18 class GetNip():     19 ####  GetNip类的构造函数     20     def __init__（self）:     21         self.logPath = os.path.expanduser（'~'） + os.sep + 'log'     22         self.nipFile = self.logPath + os.sep + 'Nip.txt'     23         self.Nip = None     24     25         self.getNip()     26         self.writeNip()     27     28 ####  从网络取得本地的公网IP     29     def getNip（self）:     30         urls = 'http://1111.ip138.com/ic.asp'     31         if urllib2.urlopen（urls）.geturl() == urls:     32             rawString = urllib2.urlopen（urls）.read()     33             self.Nip = re.search（b'\d+\.\d+\.\d+\.\d+',rawString）.group()     34             print（"Nip = %s" %self.Nip）     35         else:     36             print（"未取得本机NIP"）     37     38 ####  将取得的公网IP写入文件     39     def writeNip（self）:     40         if os.path.isdir（self.logPath）:     41             pass     42         else:     43             os.makedirs（self.logPath）     44         with open（self.nipFile,'w'） as FP:     45             FP.write（self.Nip）     46     47     48 ####  定义PortMap类     49 class PortMap（object）:     50 ####  PortMap类的构造函数     51     def __init__（self）:     52         self.tn = None     53         self.gn = GetNip()     54         self.nip = self.gn.Nip     55         self.ml = MyLog()     56 ####  定义本地的环境变量     57         self.dict1 = {     58                 'modemIp':'192.168.1.1',     59                 'mapIp':'192.168.1.90',     60                 'user':b'root',     61                 'password':b'root',     62                 'finish':b'/ # '}     63 ####  iptables命令列表，清除iptables环境，以便于之后的设置     64         self.portmap_clear = [     65                 'iptables -t nat -F myPREROUTING',     66                 'iptables -t nat -D PREROUTING -j myPREROUTING',     67                 'iptables -t nat -X myPREROUTING',     68                 'iptables -t nat -F myPREROUTING',     69                 'iptables -t nat -F myPOSTROUTING',     70                 'iptables -t nat -D POSTROUTING -j myPOSTROUTING',     71                 'iptables -t nat -X myPOSTROUTING']     72 #### iptables命令列表，设置iptables，将Route上的8080端口映射到Modem的8080端口上     73         self.portmap_set = [     74                 'iptables -t nat -N myPREROUTING',     75                 'iptables -t nat -A myPREROUTING -d ' + self.nip + ' -p tcp -m tcp --dport 8080 -j DNAT --to-destination ' + self.dict1['mapIp'] + ':8080',     76                 'iptables -t nat -A PREROUTING -j myPREROUTING',     77                 'iptables -t nat -N myPOSTROUTING',     78                 'iptables -t nat -A myPOSTROUTING -d ' + self.dict1['mapIp'] + ' -p tcp -m tcp --dport 8080 -j SNAT --to-source ' + self.dict1['modemIp'],     79                 'iptables -t nat -A POSTROUTING -j myPOSTROUTING']     80         self.set_iptables()     81     82 ####  该函数用于设置iptables     83     def set_iptables（self）:     84         self.ml.info（u'开始设置 iptables ......'）     85         self.conn_telnet()     86         cmd = None     87         for cmd in self.portmap_clear:     88             self.tn.write（'%s \n' %cmd）     89             self.ml.info（'Run command : "%s" successfull' %cmd）     90             time.sleep（2）     91         self.ml.info（u'iptables 清除完毕'）     92         cmd = None     93         for cmd in self.portmap_set:     94             self.tn.write（'%s \n' %cmd）     95             self.ml.info（'Run command : "%s" successfull' %cmd）     96             time.sleep（2）     97         self.ml.info（u'iptables 设置完毕 ......'）     98         self.disconn_telnet()     99    100 ####  该函数用于连接Modem上的telnet服务    101     def conn_telnet（self）:    102         self.tn = telnetlib.Telnet（self.dict1['modemIp']）    103         self.tn.read_until（b'Login: '）    104         self.tn.write（self.dict1['user'] + b'\n'）    105         self.tn.read_until（b'Password: '）    106         self.tn.write（self.dict1['password'] + b'\n'）    107         self.tn.read_until（self.dict1['finish']）    108         self.ml.info（u"telnet 连接成功"）    109    110 ####  该函数用于断开Modem上的telnet服务    111     def disconn_telnet（self）:    112         self.tn.close()    113         self.ml.info（u"telnet 断开"）    114    115    116 ####  定义一个MyLog类    117 class MyLog（object）:    118     def __init__（self）:    119         self.logger = logging.getLogger（'pi'）    120         self.logFile = '/home/pi/log/' + os.path.basename（__file__）[0:-3] + '.log'    121         self.logger.setLevel（logging.DEBUG）    122         self.formatter = logging.Formatter（'%（asctime）-12s %（levelname）-8s %（name）-10s %（message）-12s'）    123    124         self.logHand = logging.FileHandler（self.logFile）    125         self.logHand.setLevel（logging.DEBUG）    126         self.logHand.setFormatter（self.formatter）    127    128         self.logHandSt = logging.StreamHandler()    129         self.logHandSt.setLevel（logging.DEBUG）    130         self.logHandSt.setFormatter（self.formatter）    131    132    133         self.logger.addHandler（self.logHand）    134         self.logger.addHandler（self.logHandSt）    135    136 ####  这里只定义了一个info，实际上还可以有bug,error……    137     def info（self,msg）:    138         self.logger.info（msg）    139    140    141 if __name__ == '__main__':    142     portMap = PortMap()好了，现在执行命令，执行结果如图5-41所示。    python portmap.py 图5-41　端口映射（3）映射验证最后来验证一下，如图5-42所示。 图5-42　公网访问内网好了，现在无须花生壳也可以从公网访问内网的服务了。用同样的方法也可以将FTP服务、ssh服务……将服务器端口都映射到光猫上。注意在Linux中的端口映射，实质上就是iptables的转发。 5.6　实战：Raspberry给自己发短信上节已经将内网的http服务端口映射到公网上了。现在的问题是，如果身处内网没必要知道公网的IP，可以直接通过内网IP访问http服务。如果身处外网又无法执行getNip.py得到外网的IP，似乎陷入死循环了。我的解决方案是通过sendMess.py给自己的手机发送外网的IP，这样就可以通过内网的公网IP来访问内网的http服务。 5.6.1　方案原理怎样才能让Python给自己的手机发短信呢？方案有两个，第一是通过飞信的接口给自己发短信。可这种方案极不稳定，说不定哪天飞信的接口就被封了。那就只有选择第二种方案了，给特定的邮箱发邮件。邮箱会将邮件内容发送到绑定的手机上。目前这种邮箱很多，如163.mail，139.mail……我选择的是139邮箱。如果实在是找不到免费手机提醒功能的邮箱，那就设置成QQ邮件吧，QQ邮箱收到邮件后会通知微信，这样也能凑合。这个脚本的本质上就是自动发送邮件。注意使用Raspberry直接发短信也是可以的，那需要添加其他的模块。 5.6.2　方案执行可以将上节的脚本都用上。首先是提取Nip.txt中保存的nip，然后利用getNip.py获取当前公网IP。比较获取的公网IP和提取保存的nip，相同则什么都不需要做，不同则将获取的公网IP发送到邮箱。使用Putty登录Raspberry，执行命令：    cd    mkdir –pv code/python/sendMsg    cd $_    touch2py sendMsg.py    cp ../getNip/getNip.py ./    vi sendMsg.pysengMsg.py的代码如下：      1 #!/usr/bin/env python      2 # -*- coding:utf-8 -*-      3 #Author  :hstking      4 #E-mail  :hstking@hotmail.com      5 #Ctime   :2015/09/11      6 #Mtime   :      7 #Version :      8      9 import smtplib     10 import email.utils     11 from email.mime.text import MIMEText     12 import getNip     13     14 ####  定义SendMail类     15 class SendMail（object）:     16 ####  定义SendMail的构造函数     17     def __init__（self,subject,content）:     18         self.subject = subject     19         self.content = content     20 ####  self.mailList是接收邮件的地址列表     21         self.mailList = ['139********@139.com','33*******@qq.com']     22 ####  self.fromMail是发送邮件的地址     23         self.fromMail = 'hst****@163.com'     24 ####  self.mi是发送邮件的用户名密码     25         self.mi = {'user':'hst****','password':'*************'}     26     27         self.sendMail（self.subject,self.content）     28     29 ####  sendMail函数用于发送邮件     30     def sendMail（self,subject,content）:     31         for mL in self.mailList:     32             msg = MIMEText（content）     33             msg['To'] = email.utils.formataddr（（mL[:mL.index（'@'）],mL））     34             msg['From'] = email.utils.formataddr（（self.fromMail[:self.fromMail.index（'@'）],self.fromMail））     35             msg['Subject'] = subject     36             try:     37                 s = smtplib.SMTP()     38                 s.set_debuglevel（1）     39                 s.connect（'smtp.' + self.fromMail[self.fromMail.index（'@'） + 1:]）     40                 s.login（self.mi['user'],self.mi['password']）     41                 s.sendmail（self.fromMail,mL,msg.as_string()）     42             except EOFError,e:     43                 print str（e）     44             finally:     45                 s.quit     46     47     48 ####  定义SendMsg类     49 class SendMsg（object）:     50 ####  定义SendMsg的构造函数     51 ####  通过getNip.GetNip()函数取得本地的公网IP，将取得的公网Ip与之前保存的Ip比较     52 ####  如果保存文件不存在或保存的IP与取得的Ip不同，则发送邮件     53     def __init__（self）:     54         nipFile = '/home/pi/log/Nip.txt'     55         with open（nipFile,'r'） as fp:     56             self.nip = fp.read()     57         Nip = getNip.GetNip()     58         if  self.nip == Nip.Nip:     59             pass     60         else:     61             sMsg = SendMail（'IP',self.nip）     62     63     64 if __name__ == '__main__':     65     SMSG = SendMsg()好了，现在可以使用这个脚本向手机上发送私人服务器的公网IP了。这个脚本中，import不光载入Python的标准模块，还使用import getNip将getNip.py当成模块载入脚本中使用。使代码能够重复利用，避免重复地造轮子。当前Raspberry默认的编辑器是nano，先将它改成vi。执行命令：    export EDITOR=vi    crontab -e开始编辑例行性任务crontab，crontab里面以#开头的都是注释，可以全部删除。在最后一行添加：    5 * * * * python /home/pi/code/python/sendMsg/sendMsg.py保存退出，使用crontab –l检查结果，如图5-43所示。 图5-43　例行性任务crontab中，第一个5是指每5分钟，第二个*是指每小时，第三个*是指每天，第四个*是指每月，第五个*是指每周。这样就设置了一个例行性任务，每5分钟获取一次Nip，将得到的Nip和之前保存的Nip比较。相同则什么都不做，如果不同，就发送邮件到指定的邮箱。然后由邮箱发送短信到手机上。    crontab是Linux例行性命令。 5.7　监控器MotionMotion是一个相当轻量级，但却能够在Linux上运行监控摄像头的应用。它可以和任何支持Linux的摄像头一起工作，包括所有V4L（Video4Linux，Linux内核中关于视频设备的API接口）网络摄像头、许多IP网络摄像头和Axis摄像头。Motion还能够控制云台功能。Motion以JPEG、PPM和MPEG格式存储影像和快照。由于Motion内置了http服务器，我们可以在网络浏览器中进行远程观看。虽然Motion支持MySQL和PostgreSQL数据库，但是它仍然可以在不需要数据库的情况下，将图片文件存储在你选择的目录。在Debian及其衍生版本上安装Motion非常容易，因为它本身已经包含了所有必需的软件库。因此我们所需要的仅仅是运行apt-get install motion，还需要libav-tools，它是一个ffmpeg分支。Debian用libav-tools取代了ffmpeg。 5.7.1　安装MotionRaspBian的官方源里包含了Motion，只需要执行命令：    sudo apt-get install motion    sudo apt-get install libav-tools 5.7.2　配置使用Motion将摄像头插入Raspberry的USB接口。用Putty登录Raspberry。执行命令：    lsusb查看摄像头是否能被Raspberry识别。如果能被自动识别，结果如图5-44所示。 图5-44　显示设备上图中Bus 001 Device 004就是刚插入的USB摄像头。如果不能被识别，就去找合适的驱动安装驱动，或者查看摄像头芯片后编译内核，将合适的驱动编入内核或模块。Motion的配置文件在/etc/motion/motion.conf，下面开始修改Motion的配置文件。登录Raspberry，执行命令：    cd /etc/motion    sudo cp motion.conf motion.conf.bak    sudo sed –i ‘s/^daemon on/daemon off/g’ motion.conf    sudo sed –i ‘s/no/yes/g’ /etc/default/motion    sudo sed –i ‘s/webcam_localhost on/webcam_localhost off/g’ motion.conf第一个和第二个sed修改的是确认Motion以后台模式运行。第三个sed修改的是解除Motion只能在本机下查看的限制。启动Motion服务，执行命令：    sudo /etc/init.d/motion restart好了，现在Motion已经可以使用了。Motion默认使用8081端口，用nmap查看一下，如图5-45所示。 图5-45　扫描确认端口打开Firefox浏览器，在地址栏输入http://192.168.2.91:8081。不要使用Chromium和IE。Chromium不支持，IE效果不太好。在Raspberry上连接一个网络摄像头，然后将8081端口也映射到公网上，就可以将它当成一个远程监控器来使用。    Raspberry使用远程摄像头也有其他的选择，但Motion是最简单的，也是可扩展性最好的。第6章　实战Raspberry GPIORaspberry可以通过扩展控制其他的电子元件、模块。那Raspberry是怎么控制电子元件、模块的呢？这里就不得不说道GPIO了。本章通过学习GPIO了解简单的电子模块。为复杂的应用做基本的技术储备。本章主要内容包括：认识GPIO控制LED二极管闪烁驱动蜂鸣器驱动超声波模块 6.1　GPIO简介General Purpose Input Output（通用输入/输出）简称为GPIO，或总线扩展器，利用工业标准I2C、SMBus或SPI接口简化了I/O口的扩展。当微控制器或芯片组没有足够的I/O端口，或当系统需要采用远端串行通信或控制时，GPIO产品能够提供额外的控制和监视功能。 6.1.1　Raspberry GPIORaspberry2采用的是40pin的GPIO，GPIO的编号方法有些混乱，不同的API（如wiringPi，RPi.GPIO等）对GPIO的端口号编号并不一样。wiringPi：有Perl、PHP、Ruby、Node.JS和Golang的扩展，支持wiringPi Pin和BCM GPIO两种编号。RPi.GPIO：Python，支持Board Pin和BCM GPIO两种编号。Webiopi：Python，使用BCM GPIO编号。WiringPi-Go：Go语言，支持以上三种编号。这里采用了官方推荐的RPi.GPIO，也顺便选择了资料最丰富的BCM GPIO编号。GPIO端口编号如图6-1所示。 图6-1　GPIO编号BCM2835编号方式侧重CPU寄存器。 wiringPi编号方式侧重实现逻辑，把扩展GPIO端口从0开始编号，这种编号方便编程。 6.1.2　物理端口Raspberry GPIO物理端口顺序是从上到下，从左到右。再来看看这些端口的用途。这些端口大致可以分成三类。第一类是电源物理端口，看Name项中，它被标注为3.3v、0v、5v的，要么就是直流电源的火线，要么就是groud地线。第二类是GPIO的控制端口，看Name项中，名字是GPIO.*的都是GPIO的控制端口，我们就是通过python控制这些端口的高电平，低电平来控制使用模块功能的。第三类是剩下的那些端口了。如Name项中标注成RxD、TxD、SDA、SCL……这些端口稍微高端一点，RxD、TxD是Receive Data、Transmit Data的意思。RxD为接收数据的引脚，TxD为发送数据的引脚。SDA是双向数据线，SCL是时钟线。在I2C总线上传送数据，首先送最高位，由主机发出启动信号，SDA在SCL高电平期间由高电平跳变为低电平，然后由主机发送一个字节的数据。数据传送完毕，由主机发出停止信号，SDA在SCL高电平期间由低电平跳变为高电平。目前暂时用不上，就不在此详细介绍了。 6.2　实战GPIO——LED呼吸灯控制GPIO端口，可以用C、Python、Go……个人认为Python是最简单的，而且Python支持多平台，可以在不同的系统下执行。这是别的语言无法比拟的。所以这里选择用Python来控制GPIO端口。本节将使用Python编程，通过GPIO端口来控制一盏LED二极管闪烁。初步了解Raspberry从软件到硬件的过程。这是一个最简单的GPIO实验。 6.2.1　准备实验物品既然是Raspberry控制LED二极管，Raspberry和LED二极管那是必需的了，LED发光二极管的颜色任选，如图6-2所示。 图6-2　LED二极管Raspberry pi2扩展板，在上面有BCM的端口编号，还是很方便的，如图6-3所示。不必须，但是如果有，肯定会方便很多。 图6-3　Raspberry pi2扩展板40pin的排线，如果不想频繁地开Raspberry的盖子，它还是值得拥有的，如图6-4所示。 图6-4　40pin排线面包板，电子实验必备工具。在这里要是没有也行，无非就是麻烦点，如图6-5所示。 图6-5　面包板好了，把这些实验用品按照图6-6所示安装好。 图6-6　组装设备LED二极管的管脚一长一短。长管脚接正极，短管脚接负极。这里是准备将长管脚接入扩展板上标有数字的端口，短管脚接入GND端口。所以这里可选择5,6,12,13,16,17,18,19,20,21,22,23,24,25,26,27这几个端口。因为LED二极管的短脚要接入GND端口，所以尽量选择GND端口相邻的控制端口。这里我选择的是扩展板上标注为12的控制端口，如图6-7所示。 图6-7　LED呼吸灯实验硬件的准备工作已经完毕了，下面只需要专心Python控制就可以了。 6.2.2　Python控制这里选用的是RPi.GPIO编程，好在RaspBian已经默认安装好了RPi.GPIO。不用费心思去下载，直接使用就可以了。这个实验的原理很简单，就是通过编程来控制某个端口的电平。当高电平时，LED二极管就亮了，低电平时二极管就熄了。由此推彼，用Raspberry的GPIO连接其他的设备，也只是控制电平的高低而已。执行命令：    cd    mkdir –pv code/python/light    cd code/python/llight    touch2py light.py    vi light.pylight.py代码如下：      1 #!/usr/bin/env python      2 # -*- coding:utf-8 -*-      3 #Author  :hstking      4 #E-mail  :hstking@hotmail.com      5 #Ctime   :2015/08/30      6 #Mtime   :      7 #Version :      8      9 import RPi.GPIO as GPIO     10 import time     11 import sys     12 import string     13     14     15 ####  定义Light类     16 class Light（object）:     17 ####  定义Light类的构造函数     18     def __init__（self,pin）:     19         self.pin = pin     20 ####  self.pins是可以使用的端口列表     21         self.pins = [5,6,12,13,16,17,18,19,20,21,22,23,24,25,26,27]     22         self.up_time = 0.5     23         self.down_time = 0.5     24         self.check_pin（pin）     25         self.run()     26     27     def run（self）:     28         self.setup（self.pin）     29         try:     30             self.loop（self.pin）     31         except KeyboardInterrupt:     32             self.destroy（self.pin）     33     34 ####  check_pin函数负责检测输入的端口是否符合要求     35     def check_pin（self,pin）:     36         if pin in self.pins:     37             print（"%d 是有效编号"%pin）     38         else:     39             print（"只能输入以下有效的pin编号"）     40             for i in self.pins:     41                 print i,     42             exit()     43     44 ####  setup函数将端口初始化     45     def setup（self,pin）:     46         #初始化GPIO口     47         #采用BCM编号     48         GPIO.setmode（GPIO.BCM）     49         #设置GPIO为输出状态，输入低电平     50         GPIO.setup（pin,GPIO.OUT）     51         GPIO.output（pin,GPIO.LOW）     52     53 ####  loop函数将LED灯循环点亮     54     def loop（self,pin）:     55         for i in xrange（1,10）:     56             GPIO.output（pin,GPIO.HIGH）     57             print（"light up"）     58             time.sleep（self.up_time）     59             GPIO.output（pin,GPIO.LOW）     60             print（"light down"）     61             time.sleep（self.down_time）     62     63     64 ####  恢复GPIO口状态     65     def destroy（self,pin）:     66         GPIO.output（pin,GPIO.LOW）     67         GPIO.setup（pin,GPIO.IN）     68     69 if __name__ == '__main__':     70     light = Light（12）好了，软硬件都准备好了。直接在light.py目录下执行命令sudo python light.py就可以看到结果了。注意这个实验是GPIO最简单的应用。先把这个实验弄懂，后面的实验才会事半功倍。 6.3　实战GPIO——蜂鸣器从上节的实验中可以大致了解Raspberry通过控制GPIO端口间接地控制其他电子原件、模块的过程和原理。本节的目的是初步了解蜂鸣器模块，使用Python编程驱动蜂鸣器，为后面的Raspberry报警器做前期技术储备。 6.3.1　准备实验物品这次的实验物品与LED二极管差不多，只是多了一个有源蜂鸣器模块，如图6-8所示。 图6-8　蜂鸣器模块该模块采用S8050三极管驱动，工作电压3.3V-5V，当I/O口输入高电平时，蜂鸣器发声。VCC针脚外接3.3V-5V电压，GND针脚外接GND，I/O针脚外接Raspberry的gpio控制端口。其次需要的是杜邦线，这个是做一般电子实验必须的物品。蜂鸣器模块的3个针脚这么近，不太可能在面包板上找到合适的位置，所以使用杜邦线是唯一的选择了。杜邦线的接头选择公对母的，如图6-9所示。 图6-9　杜邦线所有实验物品到位后，按照图6-10安装起来，在这里我选择的GPIO控制端口是18号端口。 图6-10　蜂鸣器模块实验硬件准备工作完毕，下面准备Python控制。 6.3.2　Python控制实际上，蜂鸣器的控制脚本跟LED二极管的控制脚本非常相似。或者说，几乎所有的模块都很相似。因为都是用Python来控制某个端口的高低电平。不同的只是高低电平的时间和控制的端口号而已。使用Putty登录Raspberry后，执行命令：    cd    mkdir –pv code/Python/bell    cd code/Python/bell    touch2py bell.py    vi bell.pybell.py的代码如下：      1 #!/usr/bin/env Python      2 # -*- coding:utf-8 -*-      3 #Author  :hstking      4 #E-mail  :hstking@hotmail.com      5 #Ctime   :2015/08/30      6 #Mtime   :      7 #Version :      8      9 import RPi.GPIO as GPIO     10 import time     11 import sys     12 import string     13     14     15 ####  定义Bell类     16 class Bell（object）:     17 ####  定义Bell类的构造函数     18     def __init__（self,pin）:     19         self.pin = pin     20         self.pins = [5,6,12,13,16,17,18,19,20,21,22,23,24,25,26,27]     21         self.up_time = 1.5     22         self.down_time = 0.5     23         self.check_pin（pin）     24         self.run()     25     26     def run（self）:     27         self.setup（self.pin）     28         try:     29             self.loop（self.pin）     30         except KeyboardInterrupt:     31             self.destroy（self.pin）     32     33 ####  检查端口是否符合要求     34     def check_pin（self,pin）:     35         if pin in self.pins:     36             print（"%d 是有效编号"%pin）     37         else:     38             print（"只能输入以下有效的pin编号"）     39             for i in self.pins:     40                 print i,     41             exit()     42     43 ####  初始化端口     44     def setup（self,pin）:     45         #采用BCM编号     46         GPIO.setmode（GPIO.BCM）     47         #设置GPIO为输出状态，输入低电平     48         GPIO.setup（pin,GPIO.OUT）     49         GPIO.output（pin,GPIO.LOW）     50     51 ####  循环给端口输出高电平     52     def loop（self,pin）:     53         for i in xrange（1,10）:     54             GPIO.output（pin,GPIO.HIGH）     55             print（"bell up"）     56             time.sleep（self.up_time）     57             GPIO.output（pin,GPIO.LOW）     58             print（"bell down"）     59             time.sleep（self.down_time）     60     61     def destroy（self,pin）:     62         #恢复GPIO口状态     63         GPIO.output（pin,GPIO.LOW）     64         GPIO.setup（pin,GPIO.IN）     65     66 if __name__ == '__main__':     67     bell = Bell（18）好了，测试一下。直接在bell目录下执行命令sudo Python bell.py就可以看到结果了。注意这个实验比呼吸灯的实验仅多出了一个时间上的控制，几乎是没什么区别。 6.4　实战GPIO——超声波模块蜂鸣器模块只需要发出高电平信号即可。而超声波模块不断要发出高电平信号，而且还要检测收到的信号，仅比蜂鸣器模块稍微复杂一点点。本节的目的是初步了解超声波模块，使用Python编程驱动超声波模块，通过超声波模块进行测距。 6.4.1　准备实验物品本次的实验物品与LED二极管的差不多，多了一个超声波模块，如图6-11所示。 图6-11　超声波模块超声波模块给脉冲触发引脚（trig）输入一个长为20us的高电平方波。输入方波后，模块会自动发射8个40kHz的声波。与此同时，回波引脚（echo）端的电平会由0变为1（此时应该启动定时器计时）。当超声波返回被模块接收时，回波引脚端的电平会由1变为0（此时应该停止定时器计数）。定时器记下的这个时间即为超声波由发射到返回的总时长。根据声音在空气中的速度为344米/秒，即可计算出所测的距离。测试距离＝（高电平时间*声速（340m/s））/2。该模块使用电压DC5V，静态电流小于2mA，高电平输出5V，低电平输出0V，探测距离2cm~450cm。共有4个针脚，VCC针脚外接5V电压；GND针脚外接GND；Trig针脚外接GPIO的控制端口，作为控制端口；echo针脚外接GPIO控制端口，作为接收信号端口。这里我选择的是GPIO控制端口的23号端口连接trip引脚，24号端口连接echo引脚，如图6-12模块。 图6-12　超声波模块实验硬件组装完毕，下面准备Python控制。 6.4.2　Python控制超声波模块与LED二极管、蜂鸣器模块区别不大。只是针脚端口多一点点，也稍微复杂一点点，再就是最后多出了一个测距。使用Putty登录Raspberry后，执行命令：    cd    mkdir –pv code/Python/ultrasonic    cd code/Python/ ultrasonic    touch2py ultrasonic.py    vi ultrasonic.pyultrasonic.py的代码如下：      1 #!/usr/bin/env Python      2 # -*- coding:utf-8 -*-      3 #Author  :hstking      4 #E-mail  :hstking@hotmail.com      5 #Ctime   :2015/08/30      6 #Mtime   :      7 #Version :      8      9 import RPi.GPIO as GPIO     10 import time     11     12     13 ####  定义类Ultrasonic     14 class Ultrasonic（object）:     15 ####  类Ultrasonic的构造函数     16     def __init__（self,trig_pin,echo_pin）:     17         self.trig_pin = trig_pin     18         self.echo_pin = echo_pin     19         self.pins = [5,6,12,13,16,17,18,19,20,21,22,23,24,25,26,27]     20         self.check_pin（self.trig_pin,self.echo_pin）     21         self.run（self.trig_pin,self.echo_pin）     22     23 ####  check_pin函数检测输入的端口是否可用     24     def check_pin（self,trig_pin,echo_pin）:     25         if trig_pin in self.pins:     26             print（"%d 是有效编号"%trig_pin）     27         else:     28             print（"只能输入以下有效的pin编号"）     29             for i in self.pins:     30                 print i,     31             exit()     32         if echo_pin in self.pins:     33             print（"%d 是有效编号"%echo_pin）     34         else:     35             print（"只能输入以下有效的pin编号"）     36             for i in self.pins:     37                 print i,     38             exit()     39     40 ####  setup函数初始化GPIO口     41     def setup（self,trig_pin,echo_pin）:     42         #采用BCM编号     43         GPIO.setmode（GPIO.BCM）     44         GPIO.setwarnings（False）     45         #设置GPIO为输出状态，输入低电平     46         GPIO.setup（self.trig_pin,GPIO.OUT,initial=GPIO.LOW）     47         GPIO.setup（self.echo_pin,GPIO.IN）     48     49 ####  run函数测距     50     def run（self,trig_pin,echo_pin）:     51         self.setup（self.trig_pin,self.echo_pin）     52         #发出触发信号     53         GPIO.output（self.trig_pin,GPIO.HIGH）     54         #保持10us以上     55         time.sleep（0.000015）     56         GPIO.output（self.trig_pin,GPIO.LOW）     57         while not GPIO.input（self.echo_pin）:     58             pass     59         #echo端口发现高电平，开始计时     60         t1 = time.time()     61         while GPIO.input（self.echo_pin）:     62             pass     63         #echo端口高电平停止，结束计时     64         t2 = time.time()     65         length = （t2-t1）*340/2     66         print（"测试距离为 %0.2f m"%length）     67         return length     68     69     70 if __name__ == '__main__':     71     ul = Ultrasonic（23,24）好了，现在可以通过这个模块进行测距了。超声波模块测距精度比较高，但距离很短。只适合用在较特殊的场合。注意超声波模块实验稍微复杂一点点，明白了原理也很容易理解。这些都是比较简单的模块，它们仅涉及了高低电平的变化，没有涉及寄存器数据。第7章　实战：智能开门报警器第6章已经熟悉了几个模块了，单独的模块并没有什么太大的用处，但组合起来用处就比较多了。本节使用Raspberry和以上的模块组合起来打造一个开门报警器，作用是开启门的时候发出报警。本章主要内容包括：了解报警器需要的硬件了解报警器组装原理了解开发报警器需要的软件实现一个智能报警器 7.1　硬件准备既然是报警器，那可以通过声音报警和灯光报警，触发器可以是红外也可以选择超声波模块。所需的模块就是上章已经学习过的模块。本节将这几个模块组合起来学以致用，制作一个开门报警器。这个报警器使用的模块不多，功能简单。如果需要添加其他的功能，可以自行扩展。心有多大，天地就有多宽。用在这里似乎也很合适。 7.1.1　必需的硬件Raspberry及标准配件一套，这是必不可少的。蜂鸣器模块一个：既然是报警，蜂鸣器是必不可少的。Led二极管一个：有了声音报警，当然还得有报警灯了。超声波模块一个：把上几节使用的模块一网打尽。杜邦线：这个当然是必不可少的了。 7.1.2　可选硬件红外模块：实际上用红外模块做报警器是最好的选择。面包板：Raspberry pi2扩展板。有了它们会轻松很多。摄像头模块：有了它甚至可以拍照留底。移动电源一套。 7.1.3　组装及原理将Raspberry及标准配件组装好，连接上面包板、开发板，如图7-1所示。 图7-1　开门报警器这里二极管选择的是GPIO的12号端口，超声波模块选择的是23、24号端口，蜂鸣器选择的是18号端口。这个开门报警器主要是利用HC-SR04超声波模块。HC-SR04超声波测距模块的精准探测距离是2cm~450cm。在这个距离之内能保持最大的精度，超出450cm后仍能测出距离变化，但测量精度无法保证了。实际应用中我探测到的最大距离是1400cm。使用HC-SR04超声波模块进行测距。如果测出的距离是一个事先固定的距离则说明门没开，如果测出的距离变大，则说明门被打开了，就可以使用蜂鸣器发出警报，Led二极管开始闪烁，并自动给手机发出消息。其实报警器使用红外模块的效果可能会更好，如果加上了摄像头模块，还可以将开门的人摄像并发送到手机。 7.2　软件准备Python脚本的优点之一是可以非常方便地重利用代码。将原有的代码载入重利用，无须重复造轮子。代码的重利用有两种方法：第一种是将需要重用的代码直接拷贝到当前目录下当模块执行，如5.6.2中的重载getNip.py。第二种是在需要重载的代码目录下添加__init__.py，将其模块化。在需要该模块的脚本中执行sys.path.append命令，将其目录添加到sys.path列表中。 7.2.1　创建mylog模块在code文件夹下创建mylog/mylog.py，然后将其模块化导入到脚本中。演示第二种导入模块的方法。实际上很简单，就是在mylog文件夹下创建一个空的__init__.py文件。这样Python会认为这个文件夹是个包。使用Putty登录到Rasypberry，执行命令：    cd    cd code/Python    mkdir –pv mylog    cd $_    sudo mkdir –pv /root/log/    touch2py __init__.py    touch2py mylog.py    vi mylog.py以下是mylog.py的代码：      1 #!/usr/bin/env Python      2 # -*- coding:utf-8 -*-      3 #Author  :hstking      4 #E-mail  :hstking@hotmail.com      5 #Ctime   :2015/09/15      6 #Mtime   :      7 #Version :      8      9 import logging     10 import getpass     11 import os     12 import sys     13     14     15 #### 定义MyLog类     16 class MyLog（object）:     17 #### 类MyLog的构造函数     18     def __init__（self）:     19         self.user = getpass.getuser()     20         self.logger = logging.getLogger（self.user）     21         self.logger.setLevel（logging.DEBUG）     22 ####  日志目录     23         self.logPath = '/home/pi/log'     24 ####  日志文件名     25         self.logFile = self.logPath + os.sep + sys.argv[0][0:-3] + '.log'     26         self.formatter = logging.Formatter（'%（asctime）-12s %（levelname）-8s %（name）-10s %（message）-12s'）     27     28 ####  日志显示到屏幕上并输出到日志文件内     29         self.logHand = logging.FileHandler（self.logFile）     30         self.logHand.setFormatter（self.formatter）     31     32         self.logHandSt = logging.StreamHandler()     33         self.logHandSt.setFormatter（self.formatter）     34     35         self.logger.addHandler（self.logHand）     36         self.logger.addHandler（self.logHandSt）     37     38 ####  日志的5个级别对应以下的5个函数     39     def debug（self,msg）:     40         self.logger.debug（msg）     41     42     def info（self,msg）:     43         self.logger.info（msg）     44     45     def warn（self,msg）:     46         self.logger.warn（msg）     47     48     def error（self,msg）:     49         self.logger.error（msg）     50     51     def critical（self,msg）:     52         self.logger.critical（msg）     53     54 if __name__ == '__main__':     55     mylog = MyLog()     56     mylog.debug（"I'm debug"）     57     mylog.info（"I'm info"）     58     mylog.warn（"I'm warn"）     59     mylog.error（"I'm error"）     60     mylog.critical（"I'm critical"）好了，现在已经将mylog模块化了。只需要使用sys.path.append命令将其加入模块路径中就可以直接使用了。注意使用__init__.py将文件夹模块化，再到需要导入的该模块的脚本中使用sys.path.append将该模块的路径导入模块路径。私人定制的模块，就是这么简单。 7.2.2　Python控制先将所需的脚本拷贝到当前目录下，以便于代码重用。也就是第一种方法的代码重用。再来构建报警器的主程序。执行命令：    cd    cd code/Python    mkdir –pv alarm    cd $_    cp ../sendMsg/* ./    touch2py alarm.py    vi alarm.py以下是alarm.py的代码：      1 #!/usr/bin/env Python      2 # -*- coding:utf-8 -*-      3 #Author  :hstking      4 #E-mail  :hstking@hotmail.com      5 #Ctime   :2015/09/15      6 #Mtime   :      7 #Version :      8      9 import RPi.GPIO as GPIO     10 import time     11 import sys     12 import string     13 mylogPath = '/home/pi/code/Python/mylog'     14 if not mylogPath in sys.path:     15     sys.path.append（mylogPath）     16 import mylog     17 ####  mylog模块是通过mylog目录下的__init__.py将目录模块化后导入的     18 import sendMsg     19 ####  sendMsg模块是将sendMsg.py直接拷贝到本地文件夹下直接导入的     20     21     22 ####  定义Bell类     23 class Bell（object）:     24 ####  Bell类的构造函数     25     def __init__（self,pin）:     26         self.pin = pin     27         self.pins = [5,6,12,13,16,17,18,19,20,21,22,23,24,25,26,27]     28         self.up_time = 1.5     29         self.down_time = 0.5     30         self.check_pin（pin）     31         self.run()     32     33     def run（self）:     34         self.setup（self.pin）     35         try:     36             self.loop（self.pin）     37         except KeyboardInterrupt:     38             self.destroy（self.pin）     39     40 ####  检查输入的端口是否合法     41     def check_pin（self,pin）:     42         if pin in self.pins:     43             print（"%d 是有效编号"%pin）     44         else:     45             print（"只能输入以下有效的pin编号"）     46             for i in self.pins:     47                 print i,     48             exit()     49     50     51 ####  初始化GPIO口     52     def setup（self,pin）:     53         #采用BCM编号     54         GPIO.setmode（GPIO.BCM）     55         #设置GPIO为输出状态，输入低电平     56         GPIO.setup（pin,GPIO.OUT）     57         GPIO.output（pin,GPIO.LOW）     58     59     def loop（self,pin）:     60         for i in xrange（1,10）:     61             GPIO.output（pin,GPIO.HIGH）     62             print（"bell up"）     63             time.sleep（self.up_time）     64             GPIO.output（pin,GPIO.LOW）     65             print（"bell down"）     66             time.sleep（self.down_time）     67     68     def destroy（self,pin）:     69 ####  恢复GPIO口状态     70         GPIO.output（pin,GPIO.LOW）     71         GPIO.setup（pin,GPIO.IN）     72     73 ####  定义了Light类     74 class Light（object）:     75 ####  Light类的构造函数     76     def __init__（self,pin）:     77         self.pin = pin     78         self.pins = [5,6,12,13,16,17,18,19,20,21,22,23,24,25,26,27]     79         self.up_time = 0.5     80         self.down_time = 0.5     81         self.check_pin（pin）     82         self.run()     83     84     def run（self）:     85         self.setup（self.pin）     86         try:     87             self.loop（self.pin）     88         except KeyboardInterrupt:     89             self.destroy（self.pin）     90     91     def check_pin（self,pin）:     92         if pin in self.pins:     93             print（"%d 是有效编号"%pin）     94         else:     95             print（"只能输入以下有效的pin编号"）     96             for i in self.pins:     97                 print i,     98             exit()     99    100    101 ####  初始化GPIO口    102     def setup（self,pin）:    103 ####  采用BCM编号    104         GPIO.setmode（GPIO.BCM）    105 ####  设置GPIO为输出状态，输入低电平    106         GPIO.setup（pin,GPIO.OUT）    107         GPIO.output（pin,GPIO.LOW）    108    109     def loop（self,pin）:    110         for i in xrange（1,10）:    111             GPIO.output（pin,GPIO.HIGH）    112             print（"light up"）    113             time.sleep（self.up_time）    114             GPIO.output（pin,GPIO.LOW）    115             print（"light down"）    116             time.sleep（self.down_time）    117    118     def destroy（self,pin）:    119 ####  恢复GPIO口状态    120         GPIO.output（pin,GPIO.LOW）    121         GPIO.setup（pin,GPIO.IN）    122    123 ####  定义Ultrasonic类    124 class Ultrasonic（object）:    125     def __init__（self,trig_pin,echo_pin）:    126         self.trig_pin = trig_pin    127         self.echo_pin = echo_pin    128         self.pins = [5,6,12,13,16,17,18,19,20,21,22,23,24,25,26,27]    129         self.check_pin（self.trig_pin,self.echo_pin）    130         self.run（self.trig_pin,self.echo_pin）    131    132     def check_pin（self,trig_pin,echo_pin）:    133         if trig_pin in self.pins:    134             print（"%d 是有效编号"%trig_pin）    135         else:    136             print（"只能输入以下有效的pin编号"）    137             for i in self.pins:    138                 print i,    139             exit()    140         if echo_pin in self.pins:    141             print（"%d 是有效编号"%echo_pin）    142         else:    143             print（"只能输入以下有效的pin编号"）    144             for i in self.pins:    145                 print i,    146             exit()    147    148    149 ####  初始化GPIO口    150     def setup（self,trig_pin,echo_pin）:    151 ####  采用BCM编号    152         GPIO.setmode（GPIO.BCM）    153         GPIO.setwarnings（False）    154 ####  设置GPIO为输出状态，输入低电平    155         GPIO.setup（self.trig_pin,GPIO.OUT,initial=GPIO.LOW）    156         GPIO.setup（self.echo_pin,GPIO.IN）    157    158     def run（self,trig_pin,echo_pin）:    159         self.setup（self.trig_pin,self.echo_pin）    160 ####  发出触发信号    161         GPIO.output（self.trig_pin,GPIO.HIGH）    162 ####  保持15us    163         time.sleep（0.000015）    164         GPIO.output（self.trig_pin,GPIO.LOW）    165         while not GPIO.input（self.echo_pin）:    166             pass    167 ####  echo端口发现高电平，开始计时    168         t1 = time.time()    169         while GPIO.input（self.echo_pin）:    170             pass    171 ####  echo端口高电平停止，结束计时    172         t2 = time.time()    173         length = （t2-t1）*340/2    174         print（"测试距离为 %0.2f m"%length）    175         return length    176    177 ####  定义Alarm类    178 class Alarm（object）:    179     def __init__（self）:    180         self.ptime = 5    181         self.tolerance = 0.05    182         self.mlog = mylog.MyLog()    183         self.run()    184    185 ####  通过超声波模块2次测距，如果测距的距离在可容忍的误差内则Pass    186 ####  如果明显测距距离不一样，则说明门被打开，点亮报警灯，打开蜂鸣器报警    187     def run（self）:    188         while True:    189             ul = Ultrasonic（23,24）    190             len1 = ul.run（23,24）    191             time.sleep（self.ptime）    192             len2 = ul.run（23,24）    193             if len1 &gt; （len2 - 0.5） or len1 &lt; （len2 + 0.5） :    194                 self.mlog.info（"初始位置 %f" %len1）    195                 self.mlog.info（"目前位置 %f" %len2）    196                 self.echo()    197             else:    198                 pass    199    200     def echo（self）:    201 ####  点亮报警灯    202         light = Light（12）    203 ####  打开报警器    204         bell = Bell（18）    205 ####  发送短信到手机    206         sendM = sendMsg.SendMail（'警告','门已开'）    207    208 if __name__ == '__main__':    209     al = Alarm()注意这个Python script演示了两种模块调用的方法。这两种方法的效果都是一样的，喜欢哪种就用哪种。好了，到了这一步已经差不多完成了。最后将这个自制的开门报警器放到距离门不超过1.2m的位置，执行命令：    cd     cd code/Python/alarm    sudo Python alarm.py现在可以放心地关门离开了。Raspberry会每5s检测一次与门之间的距离。如果门被打开则会立刻记入日志并发送短信息到手机上，如果觉得5s时间太长了，可以自行修改合适的间隔时间。如果有摄像头模块那就更好了，可以摄像存档。如果需要其他的功能，可以添加合适的模块，自行加入所需的功能。第8章　实战：移动小车（手机控制+网页控制）上章对单一模块进行了简单的组装应用，本章将对稍微复杂的模块进行组装应用，进一步了解Raspberry对模块的开发应用。本章组装一个Raspberry的移动小车，并让它运行。本章主要内容包括：移动小车所需要的硬件移动小车的组装原理实现移动小车的代码 8.1　硬件准备移动小车，至少得包括一辆用电机驱动的小车。控制小车才轮得到Raspberry大显身手。所需的硬件大部分都在前面章节介绍过了，本章是对本书前面所讲的内容进行一次总结汇总。 8.1.1　必需的硬件免驱无线网卡，如图8-1所示。 图8-1　免驱无线网卡移动小车（含直流减速电机4个），如图8-2所示。 图8-2　小车配件L298N电机驱动板模块，如图8-3所示。 图8-3　L298N驱动模块9V电池一个，如图8-4所示。 图8-4　电池移动电源一个，如图8-5所示。 图8-5　移动电源 8.1.2　可选的硬件面包板，Raspberry pi2扩展板。有了它们会轻松很多。如果没有也没关系。稍微麻烦点而已。超声波模块，有了这个可以添加移动小车的防撞功能。摄像头模块或者是摄像头，有了这个，可以实时地观看小车周边环境。添加这些可选模块可以为小车增加更多的功能。 8.2　组装及原理要想小车跑，就得先把小车组装好。本节详细地解说了移动小车的安装步骤和驱动原理。知其然后必知其所以然才能举一反三有所进步。 8.2.1　小车组装1．小车硬件先将移动小车的包装拆开，清理配件。配件包括底盘2片，如图8-6所示。 图8-6　小车底盘轮子4个，如图8-7所示。 图8-7　小车车轮测速码盘4个，如图8-8所示。 图8-8　小车测速码盘减速直流电机4个，如图8-9所示。 图8-9　直流电机M3x30螺丝8个，如图8-10所示。 图8-10　M3x30螺丝紧固片8片，如图8-11所示。 图8-11　紧固片M3x10螺丝6个（有多的备件），如图8-12所示。 图8-12　M3x10M3螺母14个（有多的备件），如图8-13所示。 图8-13　M3铜柱6个，如图8-14所示。 图8-14　铜柱2．组装小车先将底盘和固定片上的膜剥开。底盘和固定片本来应该是透明的，上面黄色的是一层贴膜。小心地将膜剥开，如图8-15所示。 图8-15　底盘（去包装）剥开固定片的膜，如图8-16所示。 图8-16　紧固片（去包装）再用2个固定片将直流电机固定到底盘上，电机引线铜片朝外，即轮子的一端。如图8-17所示。 图8-17　直流电机安装1按照以上的方法，依次将4个直流电机固定到底盘上，一定要将有铜片的那面朝外，即安装轮子的那面，如图8-18所示。 图8-18　直流电机安装2将4个测速码盘安装到直流电机的内侧。如图8-19所示。 图8-19　测速码盘安装将4个轮子安装到直流电机上，如图8-20所示。 图8-20　车轮安装1安装完4个轮子，将铜柱固定到小车的底板上，如图8-21所示。 图8-21　车轮安装2最后将顶盘用螺丝固定到铜柱上，如图8-22所示。 图8-22　底盘安装到这里小车已经基本安装完毕了，剩下的是与L298N电机驱动板模块的连接了。注意小车的原理极其简单，就是4个直流电机控制4个轮子的前进后退。 8.2.2　电机组装L298N驱动模块很简单。它只有4个针脚控制直流电机的旋转，其他的几个针脚是使能端。1．L298N接线原理L298N的接入图，如图8-23所示。 图8-23　L298N模块针脚OUT1和OUT2分别连接直流电机的正负极，同样OUT3和OUT4也是连接直流电机的正负极的。因为有4个直流电机，这里只打算用一个L298N电机控制，所以将同侧的两个直流电机并联到一起。这样的弊端就是同侧的电机会一起动作，没那么灵活。接入12V就是直流电源的正极接入端，这里要求的是12V，但实际上7V-35V都是没问题的。所以无须使用电池组了，直接给一个9V的电池就可以了。虽然动力不是很足，但小车本身不重，勉强可以带动。GND是接入直流电源的负极接入端，这就没什么好解释的了。5V接出是如果还有其他的设备需要供电，可以从这里取电供应，例如如果有个强劲的电池组则不需要移动电源给Raspberry供电，可以直接从这个端口给Raspberry供电。ENA和ENB分别为A、B电机的使能端，一开始ENA和ENB各自的上下两个针脚是用跳线帽连接起来的，拔掉就可以接线了。IN1-IN4分别是A、B电机的控制端。我们可以通过Raspberry上的Python脚本控制GPIO上的高低电平，间接地控制直流电机的转动与否。2．L298N连接直流电机直流电机接线接口比较小，需要比较细的导线。可以将杜邦线稍微修改一下用于模块和电机之间部件的连接。L298N电机比较小巧，可以把它放到小车的两块面板之间，4个直流电机的中间。打开小车的顶面板。先将直流电机连接到OUT1、OUT2接口，如图8-24所示。 图8-24　直流电机接线1同侧的两个直流电机的方向是相反的，接线的时候请注意方向。请看清楚杜邦线的颜色，最后接好的效果如图8-25所示。 图8-25　直流电机接线2将另一侧的两个电机按照顺序接好，最后电机的接入图，如图8-26所示。 图8-26　L298N接线3．L298N连接Raspberry/面包板将ENA、ENB的跳线拔出，用杜邦线接入这4个端口，如图8-27所示。 图8-27　使能端接线最后用杜邦线接入IN1-IN4这4个端口，如图8-28所示。 图8-28　控制端接线将所有接出的杜邦线理清顺序，从小车顶板的孔中穿出，将小车顶板固定。准备连接Raspberry设备，如图8-29所示。 图8-29　小车穿线在这里使用了面包版、扩展板等辅助设备。如果没有这些请仔细核对GPIO的端口，避免不必要的麻烦。将连接ENA和ENB的4根杜邦线连接到了5、6、13、19号端口。将连接IN1-IN4的4个杜邦线连接到了21、22、23、24号端口，如图8-30所示。 图8-30　GPIO接线    L298N不设计到寄存器数据，只需要控制电平的高低，也是非常简单的。4．L298N电源输入最后将连接电源接入口和GND的杜邦线连接到9V电池的正负极，如图8-31所示。 图8-31　电池接线将移动电源接入Raspberry的miniUSB接口，将无线网卡接入Raspberry的USB接口，小车硬件上已经准备完毕了，如图8-32。 图8-32　完整小车俯视图注意可以直接从Raspberry上给L298N模块取电，省去9V的电池。这样的缺点就是小车运行起来慢得让人绝望。 8.2.3　小车原理用Raspberry驱动L298N电机与上章的Raspberry驱动二极管、蜂鸣器、超声波模块可以说是没有任何区别。只是接入的线稍微多了一点点而已。现在接入Raspberry的GPIO上的共有8根线。4根线是使能端，这4个端口没什么好说的，直接给它个高电平就可以了，只有给它高电平直流电机才能运行。4根线是连接IN1-IN4的，这才是操作L298N电机的关键。其中IN1给高电平，将控制A电机的前进。IN2给高电平控制A电机的后退。IN3和IN4控制的是另一侧B电机的前进后退。了解到了这点，控制小车就没有什么难度了。注意还可以将超声波模块和摄像头加入进来。超声波模块做成防撞功能，视频模块可做成远程监控。 8.3　软件准备硬件准备完毕，再来看软件方面。只有软硬结合才能驱动小车运行。本节将使用Python脚本控制小车的前进、后退、转弯，之后进一步使用Web页面来控制小车。 8.3.1　Python控制只需要控制IN1~IN4这几个端口的高低电平，就可以控制小车了。使用Putty登录Raspberry，执行命令：    cd     mkdir –pv code/Python/car    cd $_    touch2py car.py    vi car.py以下是car.py的代码：      1 #!/usr/bin/env Python      2 # -*- coding:utf-8 -*-      3 #Author  :hstking      4 #E-mail  :hstking@hotmail.com      5 #Ctime   :2015/09/21      6 #Mtime   :      7 #Version :      8      9     10 import RPi.GPIO as GPIO     11 import time     12 import sys     13     14     15 ####  定义Car类     16 class Car（object）:     17     def __init__（self）:     18         self.enab_pin = [5,6,13,19]     19 ####  self.enab_pin是使能端的pin     20         self.inx_pin = [21,22,23,24]     21 ####  self.inx_pin是控制端in的pin     22         self.RightAhead_pin = self.inx_pin[0]     23         self.RightBack_pin = self.inx_pin[1]     24         self.LeftAhead_pin = self.inx_pin[2]     25         self.LeftBack_pin = self.inx_pin[3]     26 ####  分别是右轮前进，右轮退后，左轮前进，左轮退后的pin     27         self.setup()     28     29 ####  setup函数初始化端口     30     def setup（self）:     31         print "begin setup ena enb pin"     32         GPIO.setmode（GPIO.BCM）     33         GPIO.setwarnings（False）     34         for pin in self.enab_pin:     35             GPIO.setup（pin,GPIO.OUT）     36             GPIO.output（pin,GPIO.HIGH）     37 ####  初始化使能端pin，设置成高电平     38         pin = None     39         for pin in self.inx_pin:     40             GPIO.setup（pin,GPIO.OUT）     41             GPIO.output（pin,GPIO.LOW）     42 ####  初始化控制端pin，设置成低电平     43         print "setup ena enb pin over"     44     45 ####  fornt函数，小车前进     46     def front（self）:     47         self.setup()     48         GPIO.output（self.RightAhead_pin,GPIO.HIGH）     49         GPIO.output（self.LeftAhead_pin,GPIO.HIGH）     50     51 ####  leftFront函数，小车左拐弯     52     def leftFront（self）:     53         self.setup()     54         GPIO.output（self.RightAhead_pin,GPIO.HIGH）     55     56 ####  rightFront函数，小车右拐弯     57     def rightFront（self）:     58         self.setup()     59         GPIO.output（self.LeftAhead_pin,GPIO.HIGH）     60     61 ####  rear函数，小车后退     62     def rear（self）:     63         self.setup()     64         GPIO.output（self.RightBack_pin,GPIO.HIGH）     65         GPIO.output（self.LeftBack_pin,GPIO.HIGH）     66     67 ####  leftRear函数，小车左退     68     def leftRear（self）:     69         self.setup()     70         GPIO.output（self.RightBack_pin,GPIO.HIGH）     71     72 ####  rightRear函数，小车右退     73     def rightRear（self）:     74         self.setup()     75         GPIO.output（self.LeftBack_pin,GPIO.HIGH）     76     77 ####  定义main主函数     78 def main（status）:     79     car = Car()     80     if status == "front":     81         car.front()     82     elif status == "leftFront":     83         car.leftFront()     84     elif status == "rightFront":     85         car.rightFront()     86     elif status == "rear":     87         car.rear()     88     elif status == "leftRear":     89         car.leftRear()     90     elif status == "rightRear":     91         car.rightRear()     92     elif status == "stop":     93         car.setup()     94     95     96 if __name__ == '__main__':     97     main（sys.argv[1]）测试一下，执行命令：    Sudo Python ./car.py front    Sudo Python ./car.py leftFront    Sudo Python ./car.py rightFront    Sudo Python ./car.py rear    Sudo Python ./car.py rightRear    Sudo Python ./car.py leftRear    Sudo Python ./car.py stop此时4个直流电机应该是运转正常的。 8.3.2　Web控制和手机控制如果光是使用Putty来控制小车，未免太麻烦了一点。现在用网页来控制小车，进而使用手机来控制小车才行。使用Putty登录Raspberry，执行命令：    Cd    cd www    mkdir car    cd $_    ln –s /home/pi/code/Python/car/car.py    vi index.PHP将上节的car.py链接到本地目录下，方便调用。以下是index.PHP的代码：      1 &lt;html&gt;      2 &lt;head&gt;      3 &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;      4 &lt;title&gt; 小车控制&lt;/title&gt;      5 &lt;/head&gt;      6 &lt;body&gt;      7      8 &lt;form action="" method="GET"&gt;      9 &lt;h2&gt;小车控制&lt;/h2&gt;     10 向前左转&lt;input type="radio" name="radio" value="1"&gt;     11 前行&lt;input type="radio" name="radio" value="2"&gt;     12 向前右转&lt;input type="radio" name="radio" value="3"&gt;     13 &lt;br/&gt;     14 停车&lt;input type="radio" name="radio" value="0" checked="checked"&gt;     15 &lt;br/&gt;     16 向后左转&lt;input type="radio" name="radio" value="4"&gt;     17 后退&lt;input type="radio" name="radio" value="5"&gt;     18 向后右转&lt;input type="radio" name="radio" value="6"&gt;     19 &lt;br/&gt;     20 &lt;input type="submit" name ="submit" value="OK"&gt;     21 &lt;/form&gt;     22 &lt;?PHP     23 $var=$_GET["radio"] ;     24 switch （$var）     25 {     26 case "0" :     27     exec（"sudo Python ./car.py stop"）;     28     break;     29 case "1" :     30     exec（"sudo Python ./car.py leftFront"）;     31     break;     32 case "2" :     33     exec（"sudo Python ./car.py front"）;     34     break;     35 case "3" :     36     exec（"sudo Python ./car.py rightFront"）;     37     break;     38 case "4" :     39     exec（"sudo Python ./car.py leftRear"）;     40     break;     41 case "5" :     42     exec（"sudo Python ./car.py rear"）;     43     break;     44 case "6" :     45     exec（"sudo Python ./car.py rightRear"）;     46     break;     47 }     48 ?&gt;     49 &lt;/body&gt;     50 &lt;/html&gt;这里是使用PHP来调用car.py，因为car.py需要用到/dev/mem，需要使用root权限，所以用网页调用Python脚本时也必须要有root权限。最简单的方法，把www-data加入/etc/sudoers后面。执行命令：    sudo chmod 640 /etc/sudoers    sudo sed –i ‘$a www-data ALL=（ALL） NOPASSWD:\/usr\/bin\/Python’ /etc/sudoers    sudo chmod 440 /etc/sudoers注意在这里没有考虑到网络安全，仅作演示，实际操作中这种方法是极不可取的，正常情况应该是给car.py做个网络接口，这里只是采取最简单，最取巧的办法。好了，现在已经将www-data加入到了sudoers文件中了。此后在网页中也可以调用car.py了。浏览器打开网页，如图8-33所示。 图8-33　网页控制测试一下，电机转动没问题，再来进行下一步。使用手机连接到本地的无线网络，使用UC浏览器打开网页（用哪个浏览器区别不大，chrome、safari都是可以的），如图8-34所示。 图8-34　手机控制测试一下，现在手机也可以控制电机转动了。 8.3.3　无线设置在上几节的测试中Raspberry都是连在有线网卡上测试的。既然叫车总不能拖着根线跑吧。下面我们用无线网卡来代替有线网卡。使用Putty连接Raspberry，执行命令：    sudo ifconfig -a效果如图8-35所示。 图8-35　wlan0系统已经找到了无线网卡wlan0，下面开始设置wlan0，执行命令：    sudo vi /etc/network/interfaces以下是最后修改好的interfaces代码：    auto lo    iface lo inet loopback        auto eth0    allow-hotplug eth0    #iface eth0 inet manual    iface eth0 inet static    address 192.168.2.91    netmask 255.255.255.0    gateway 192.168.2.1        auto wlan0    allow-hotplug wlan0    iface wlan0 inet static    address 192.168.2.92    netmask 255.255.255.0    gateway 192.168.2.1    wpa-ssid yourssid    wpa-psk youpassword重启系统，执行命令：    sudo reboot好了，现在可以将有线网卡上的网线拔下来了。将小车的车轮安装好，电池充电器安装好，最后检查一遍，没有问题了。现在可以通过手机遥控小车了。\\
\end{document}